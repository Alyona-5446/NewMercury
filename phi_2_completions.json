{"spiral-matrix": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        res = []\n        \n        # top row\n        for i in range(len(matrix[0])):\n            res.append(matrix[0][i])\n        \n        # right column\n        for i in range(1, len(matrix)):\n            res.append(matrix[i][-1])\n        \n        # bottom row\n        if len(matrix) > 1:\n            for i in range(len(matrix[-1])-2, -1, -1):\n                res.append(matrix[-1][i])\n        \n        # left column\n        if len(matrix) > 1:\n            for i in range(len(matrix)-2, 0, -1):\n                res.append(matrix[i][0])\n        \n        # remove the visited elements\n        for i in range(1, len(matrix)-1):\n            for j in range(1, len(matrix[0])-1):\n                res.append(matrix[i][j])\n        \n        return res\n", "summary-ranges": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        result = []\n        \n        start = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i]!= nums[i-1] + 1:\n                if start == nums[i-1]:\n                    result.append(str(start))\n                else:\n                    result.append(str(start) + \"->\" + str(nums[i-1]))\n                start = nums[i]\n        \n        if start == nums[-1]:\n            result.append(str(start))\n        else:\n            result.append(str(start) + \"->\" + str(nums[-1]))\n            \n        return result\n", "distinct-subsequences": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u679a\u4e3e\n        # \u5982\u679cs\u4e3a\u7a7a\uff0c\u5219t\u4e3a\u7a7a\uff0c\u8fd4\u56de1\n        # \u5982\u679ct\u4e3a\u7a7a\uff0c\u5219s\u4e3a\u7a7a\uff0c\u8fd4\u56de0\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e0d\u4e3a\u7a7a\uff0c\u5219s\u4e3a\u7a7a\uff0ct\u4e0d\u4e3a\u7a7a\uff0c\u8fd4\u56de0\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0c\u8fd4\u56de1\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0cs\u4e0d\u4e3a\u7a7a\uff0ct\u4e0d\u4e3a\u7a7a\uff0c\u8fd4\u56de0\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0cs\u4e0d\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0c\u8fd4\u56de0\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0cs\u4e0d\u4e3a\u7a7a\uff0ct\u4e0d\u4e3a\u7a7a\uff0c\u8fd4\u56de1\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0c\u8fd4\u56de1\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0cs\u4e0d\u4e3a\u7a7a\uff0ct\u4e0d\u4e3a\u7a7a\uff0c\u8fd4\u56de0\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0cs\u4e0d\u4e3a\u7a7a\uff0ct\u4e3a\u7a7a\uff0c\u8fd4\u56de0\n        # \u5982\u679cs\u4e3a\u7a7a\uff0ct\ufffd", "first-missing-positive": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # 1\u3001\u5c06\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u90fd\u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u5b57\u7b26\u4e32\u4e2d", "permutation-sequence": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        # \u5148\u627e\u5230n!\u7684\u524dk\u4e2a\u6570\u5b57\uff0c\u7136\u540e\u6392\u5e8f\n        #", "two-sum-ii-input-array-is-sorted": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u54c8\u5e0c\u8868\n        # \u5148\u904d\u5386\u6570\u7ec4\uff0c\u6bcf\u6b21\u68c0\u67e5target-numbers[i]\u662f\u5426\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\u5982\u679c\u5b58\u5728\uff0c\u5219\u8fd4\u56de[i,hash_table[target-numbers[i]]]\n        # \u5982\u679c\u4e0d\u5b58\u5728\uff0c\u5219\u6dfb\u52a0numbers[i]\uff0chash_table[numbers[i]]=i\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        hash_table = {}\n        for i in range(len(numbers)):\n            if target - numbers[i] in hash_table:\n                return [i+1, hash_table[target - numbers[i]] + 1]\n            hash_table[numbers[i]] = i+1\n        return []\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "expression-add-operators": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, curr, prev, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            \n            for j in range(i, len(num)):\n                num1 = int(num[i:j+1])\n                dfs(j+1, curr+num1, num1, res)\n                dfs(j+1, curr-num1, -num1, res)\n                dfs(j+1, curr-prev+prev*num1, prev*num1, res)\n                \n        res = []\n        dfs(0, 0, 0, res)\n        return res\n", "sum-root-to-leaf-numbers": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # \u6df1\u5ea6\u4f18\u5148\u904d\u5386\n        def dfs(node, path):\n            if not node:\n                return\n            path += str(node.val)\n            if not node.left and not node.right:\n                res.append(int(path))\n            dfs(node.left, path)\n            dfs(node.right, path)\n        \n        res = []\n        dfs(root, '')\n        return sum(res)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "license-key-formatting": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # \u5206\u5272\u5b57\u7b26\u4e32\n        s_list = s.split(\"-\")\n        \n        # \u5224\u65ad\u5b57\u7b26\u4e32\u957f\u5ea6\n        if len(s_list) == 1:\n            return s_list[0].upper()\n        \n        # \u5224\u65ad\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u4e3ak\n        elif len(s_list) == k:\n            return \"-\".join(s_list).upper()\n        \n        # \u5224\u65ad\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u662fk\n        else:\n            # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u5927\u4e8ek\n            if len(s_list[0]) > k:\n                # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u5927\u4e8ek\n                if len(s_list[0]) > k:\n                    # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u5927\u4e8ek\n                    if len(s_list[0]) > k:\n                        # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u5927\u4e8ek\n                        if len(s_list[0]) > k:\n                            # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u5927\u4e8ek\n                            if len(s_list[0]) > k:\n                                # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u5927\u4e8ek\n                                if len(s_list[0]) > k:\n                                    # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u662f\u5426\u5927\u4e8ek\n                                    if len(s_list[0]) > k:\n                                        # \u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6", "gas-station": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 24 ms, faster than 98.67% of Python online submissions for Can I Complete a Circular Route.\n        # Memory Usage: 14.2 MB, less than 100.00% of Python online submissions for Can I Complete a Circular Route.\n        \n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        if total_gas < total_cost:\n            return -1\n        \n        start = 0\n        tank = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start if tank == 0 else -1\n", "burst-balloons": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for l in range(2, n):\n            for i in range(n - l):\n                j = i + l\n                for k in range(i, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k + 1][j])\n        \n        return dp[0][n - 1]\n", "plus-one": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.9 MB\n        \n        # Solution 1:\n        # Convert the array to a string, increment the string, and convert it back to an array.\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        \n        digits = list(map(str, digits))\n        digits = list(map(int, str(int(''.join(digits)) + 1)))\n        return digits\n        \n        \n        # Solution 2:\n        # Iterate through the digits from right to left, incrementing the digit if it is 9, and carry over to the next digit.\n        # Time complexity: O(n)\n        # Space complexity: O(1)\n        \n        carry = 1\n        for i in range(len(digits) - 1, -1, -1):\n            digits[i] += carry\n            if digits[i] == 10:\n                digits[i] = 0\n                carry = 1\n            else:\n                carry = 0\n                break\n        if carry == 1:\n            digits.insert(0, 1)\n        return digits\n        \n        \n        # Solution 3:\n        # Iterate through the digits from right to left, incrementing the digit if it is 9, and carry over to the next digit.\n        # If the digit is 0, set it to 9 and continue.\n        # If the digit is 9, set it to 0 and break.\n        # If the digit is not 9, set it to the incremented digit and break.\n        # If the loop ends without breaking, append a 1 to the beginning of the digits.\n        # Time complexity: O(n)\n        # Space complexity: O(1)\n        \n        carry = 1\n        for i in range(len(digits) - 1, -1, -1):\n            digits[i] += carry\n            if digits[i] == 10:\n                digits[i] = 0\n                carry = 1\n            elif digits[i] == 9:\n                digits[i] = 0\n                break\n            else:\n                carry = 0\n                break\n        if carry == 1:\n            digits.insert(0, 1)\n        return", "regular-expression-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i][j]\u8868\u793as[0:i]\u548cp[0:j]\u662f\u5426\u5339\u914d\n        # dp[i][j] = dp[i-1][j-1] if p[j] == s[i]\n        # dp[i][j] = dp[i-1][j] if p[j] == '.'\n        # dp[i][j] = dp[i][j-1] or dp[i-1][j-1] if p[j] == '*' and dp[i][j-1]\n        \n        # dp[i][j] = dp[i-1][j-1] if p[j] == s[i]\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j - 1]\n        \n        return dp[-1][-1]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "create-maximum-number": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u5206\u6cbb\u6cd5\n        def merge(nums1, nums2, k):\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            if k == 0:\n                return []\n            \n            if nums1[0] > nums2[0]:\n                return [nums1[0]] + merge(nums1[1:], nums2, k - 1)\n            else:\n                return [nums2[0]] + merge(nums1, nums2[1:], k - 1)\n        \n        return merge(nums1, nums2, k)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "perfect-number": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i!= num // i:\n                    divisors.append(num // i)\n        \n        return sum(divisors) == num\n", "fibonacci-number": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)\n", "dungeon-game": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + dungeon[i][j]\n        # dp[0][0] = 1\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j], dp[i][j-1]) - dungeon[i][j])\n        \n        # Time Limit Exceeded\n        \n        # dp[i][j] = max(1, min(dp[i-1][j", "find-k-th-smallest-pair-distance": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u5bf9\u6570\u7ec4\u8fdb\u884c\u6392\u5e8f\uff0c\u6bcf\u6b21\u6bd4\u8f83\u4e24\u4e2a\u6570\u7684\u5dee\u503c\uff0c\u5982\u679c\u5dee\u503c\u5c0f\u4e8ek\uff0c\u5219\u8fd4\u56de\u5dee\u503c\n        nums.sort()\n        n = len(nums)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if nums[j] - nums[i] < k:\n                    return nums[j] - nums[i]\n        return -1\n", "number-of-segments-in-a-string": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        segments = 0\n        \n        for i in range(len(s)):\n            if s[i] =='':\n                if i > 0:\n                    segments += 1\n            \n        return segments + 1\n", "reverse-vowels-of-a-string": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(['a','e','i','o','u','A','E','I','O','U'])\n        \n        s = list(s)\n        \n        i = 0\n        j = len(s) - 1\n        \n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        \n        return ''.join(s)\n", "longest-consecutive-sequence": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        nums = set(nums)\n        \n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                current = num\n                \n                while current in nums:\n                    current += 1\n                \n                longest = max(longest, current - num)\n                \n        return longest\n", "missing-number": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.3 MB\n        \n        # Sum of all numbers in the range [0, n]\n        total = n = len(nums)\n        \n        # Sum of all numbers in the array\n        array_sum = sum(nums)\n        \n        # The missing number is the difference between the sum of all numbers in the range and the sum of all numbers in the array\n        return total * (total + 1) // 2 - array_sum\n", "word-ladder": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # \u5b57\u5178\u6811\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u662f\u5b57\u7b26\u4e32\uff0c\u8282\u70b9\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u7684...\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u7684...\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u7684...\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u7684...\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u7684...\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u7684...\n        # \u5b57\u5178\u6811\u7684\u8282\u70b9\u7684\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u6811\u662f\u5b57\u7b26\u4e32\u7684", "add-binary": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.7 MB\n        return bin(int(a, 2) + int(b, 2))[2:]\n", "find-first-and-last-position-of-element-in-sorted-array": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        # \u5de6\u6307\u9488\u6307\u5411\u7b2c\u4e00\u4e2a\u5927\u4e8etarget\u7684\u5143\u7d20\n        # \u53f3\u6307\u9488\u6307\u5411\u7b2c\u4e00\u4e2a\u5c0f\u4e8etarget\u7684\u5143\u7d20\n        # \u5982\u679ctarget\u5728\u5de6\u6307\u9488\u548c\u53f3\u6307\u9488\u4e4b\u95f4\uff0c\u5219\u8fd4\u56de\u5de6\u6307\u9488\u548c\u53f3\u6307\u9488\n        # \u5982\u679ctarget\u4e0d\u5728\u5de6\u6307\u9488\u548c\u53f3\u6307\u9488\u4e4b\u95f4\uff0c\u5219\u8fd4\u56de-1\n        \n        if not nums:\n            return [-1,-1]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                left = mid\n                break\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        if left == len(nums) or nums[left]!= target:\n            return [-1,-1]\n        \n        left = left\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return [left,right]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "remove-duplicates-from-sorted-array": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        nums.sort()\n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j]!= nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        return i + 1\n", "jump-game-ii": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        # \u521d\u59cb\u5316\u8def\u5f84\n        dp = [float('inf')] * n\n        dp[0] = 0\n        \n        # \u679a\u4e3e\u8def\u5f84\n        for i in range(n):\n            for j in range(1, nums[i]+1):\n                if i+j < n:\n                    dp[i+j] = min(dp[i+j], dp[i]+1)\n        \n        return dp[-1]\n", "best-time-to-buy-and-sell-stock-iv": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(len(prices) - 1))\n        \n        # dp[i][j] means the max profit we can get by doing at most j transactions in the first i days\n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j], prices[i] - prices[i - 1] + dp[i - 1][j - 1])\n                \n        return dp[-1][-1]\n", "convert-a-number-to-hexadecimal": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        sign = \"-\" if num < 0 else \"\"\n        num = abs(num)\n        \n        hex_digits = \"0123456789abcdef\"\n        hex_string = \"\"\n        \n        while num > 0:\n            hex_string = hex_digits[num % 16] + hex_string\n            num //= 16\n        \n        return sign + hex_string\n", "first-unique-character-in-a-string": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 28 ms\n        # Memory: 13.3 MB\n        \n        # Hashmap\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a hashmap to store the frequency of each character\n        char_freq = {}\n        \n        # Iterate over the string\n        for char in s:\n            # If the character is already in the hashmap, increment its frequency\n            if char in char_freq:\n                char_freq[char] += 1\n            # If the character is not in the hashmap, add it with a frequency of 1\n            else:\n                char_freq[char] = 1\n        \n        # Iterate over the string again\n        for index, char in enumerate(s):\n            # If the frequency of the current character is 1, return its index\n            if char_freq[char] == 1:\n                return index\n        \n        # If no character has a frequency of 1, return -1\n        return -1\n", "contains-duplicate-iii": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if indexDiff == 0:\n            return False\n        \n        if len(nums) == 1:\n            return False\n        \n        if len(nums) == 2:\n            return True\n        \n        nums.sort()\n        \n        for i in range(len(nums) - 1):\n            if abs(nums[i] - nums[i+1]) <= valueDiff:\n                if i + indexDiff >= len(nums) or abs(nums[i] - nums[i+indexDiff]) <= valueDiff:\n                    return True\n        return False\n", "sort-colors": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # \u6839\u636e\u7ed9\u5b9a\u7684\u6570\u7ec4\u957f\u5ea6\uff0c\u5206\u522b\u8ba1\u7b97\u7ea2\u8272\u3001\u767d\u8272\u3001\u84dd\u8272\u7684\u4e2a\u6570\n        red, white, blue = 0, 0, len(nums) - 1\n        while white < blue:\n            if nums[white] == 0:\n                nums[red], nums[white] = nums[white], nums[red]\n                red += 1\n                white += 1\n            elif nums[white] == 1:\n                white += 1\n            else:\n                nums[white], nums[blue] = nums[blue], nums[white]\n                blue -= 1\n", "max-consecutive-ones": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count\n", "count-complete-tree-nodes": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u6c42\u51fa\u6700\u5927\u503c\n        def getMax(root):\n            if not root:\n                return 0\n            return max(getMax(root.left), getMax(root.right)) + 1\n        \n        max_val = getMax(root)\n        \n        # \u5982\u679c\u6700\u5927\u503c\u4e3a\u5947\u6570\uff0c\u5219\u8ba1\u7b97\u7b2c\u4e00\u5c42\u7684\u4e2a\u6570\n        if max_val & 1:\n            return pow(2, max_val - 1)\n        \n        # \u5982\u679c\u6700\u5927\u503c\u4e3a\u5076\u6570\uff0c\u5219\u8ba1\u7b97\u7b2c\u4e00\u5c42\u7684\u4e2a\u6570\u548c\u7b2c\u4e8c\u5c42\u7684\u4e2a\u6570\n        return pow(2, max_val) - 1\n", "add-strings": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Runtime: 36 ms\n        # Memory: 13.2 MB\n        \n        # Solution 1:\n        # Convert the strings to integers, add them, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 2:\n        # Convert the strings to lists of digits, add them, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 3:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 4:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 5:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 6:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 7:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 8:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 9:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime: O(n)\n        \n        # Solution 10:\n        # Convert the strings to lists of digits, add them digit by digit, and convert the result back to a string\n        # runtime: O(n)\n        # runtime", "basic-calculator": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        \n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if s[i] == '+' or s[i] == '-':\n                if len(stack) > 0:\n                    stack.append(num)\n                num = 0\n                sign = 1 if s[i] == '+' else -1\n            if s[i] == '(':\n                stack.append(num)\n                num = 0\n                sign = 1\n            if s[i] == ')':\n                num = num * sign + stack.pop()\n        \n        return num * sign\n", "ipo": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u4ece\u5de6\u5f80\u53f3\u904d\u5386\uff0c\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e00\u4e2a\u6709\u6700\u5927\u7684\uff0c\u7136\u540e\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e8c\u4e2a\u6709\u6700\u5927\u7684\n        # \u5982\u679c\u6709\u7b2c\u4e00\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5219\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e00\u4e2a\u6709\u6700\u5927\u7684\uff0c\u7136\u540e\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e8c\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5982\u679c\u6709\u7b2c\u4e8c\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5219\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e8c\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5982\u679c\u6709\u7b2c\u4e09\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5219\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e09\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5982\u679c\u6709\u7b2c\u56db\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5219\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u56db\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5982\u679c\u6709\u7b2c\u4e94\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5219\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e94\u4e2a\u6709\u6700\u5927\u7684\uff0c...\n        # \u5982\u679c\u6709\u7b2c\u4e00\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5219\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e00\u4e2a\u6709\u6700\u5927\u7684\uff0c\u7136\u540e\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e8c\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5982\u679c\u6709\u7b2c\u4e8c\u4e2a\u6709\u6700\u5927\u7684\uff0c\u5219\u6bcf\u6b21\u7ed9\u5b9a\u7b2c\u4e8c\u4e2a\u6709\u6700\u5927\u7684\ufffd", "valid-parentheses": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        \n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1]!= '(':\n                    return False\n                if i == ']' and stack[-1]!= '[':\n                    return False\n                if i == '}' and stack[-1]!= '{':\n                    return False\n                stack.pop()\n        \n        if len(stack) == 0:\n            return True\n        else:\n            return False\n", "next-permutation": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # \u6392\u5e8f\n        nums.sort()\n        \n        # \u5982\u679c\u662f\u6700\u540e\u4e00\u4e2a\u6570\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if nums[-1] == nums[-2] == nums[-3]:\n            return\n        \n        # \u5982\u679c\u6700\u540e\u4e00\u4e2a\u6570\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u6570\uff0c\u5219\u628a\u6700\u540e\u4e00\u4e2a\u6570\u653e\u5230\u524d\u9762\n        if nums[-1] <= nums[-2]:\n            nums.reverse()\n            return\n        \n        # \u5982\u679c\u6700\u540e\u4e00\u4e2a\u6570\u5927\u4e8e\u524d\u4e00\u4e2a\u6570\uff0c\u5219\u627e\u5230\u524d\u4e00\u4e2a\u6570\u5c0f\u4e8e\u6700\u540e\u4e00\u4e2a\u6570\u7684\u4f4d\u7f6e\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] < nums[-1]:\n                break\n        \n        # \u5c06\u6700\u540e\u4e00\u4e2a\u6570\u653e\u5230\u524d\u9762\n        nums[i], nums[-1] = nums[-1], nums[i]\n        \n        # \u5c06\u524d\u4e00\u4e2a\u6570\u5c0f\u4e8e\u6700\u540e\u4e00\u4e2a\u6570\u7684\u4f4d\u7f6e\u524d\u9762\u7684\u6570\u653e\u5230\u524d\u9762\n        for j in range(len(nums) - 1, i, -1):\n            if nums[j] > nums[i]:\n                nums[j], nums[i] = nums[i], nums[j]\n                break\n        \n        return nums\n", "contains-duplicate-ii": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u4f4d\u7f6e\n        # \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u5219\u66f4\u65b0\u5b57\u5178\u4e2d\u7684\u503c\n        # \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u4e14\u5f53\u524d\u4f4d\u7f6e-k\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u5219\u8fd4\u56deTrue\n        \n        # \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u4e14\u5f53\u524d\u4f4d\u7f6e-k\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u5219\u8fd4\u56deTrue\n        \n        # \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u4e14\u5f53\u524d\u4f4d\u7f6e-k\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u5219\u8fd4\u56deTrue\n        \n        # \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u4e14\u5f53\u524d\u4f4d\u7f6e-k\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u5219\u8fd4\u56deTrue\n        \n        # \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u4e14\u5f53\u524d\u4f4d\u7f6e-k\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u5219\u8fd4\u56deTrue\n        \n        # \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u51fa\u73b0\u4e86\u6570\u5b57\uff0c\u4e14\u5f53\u524d\u4f4d\u7f6e-k\u4f4d\u7f6e\u51fa\u73b0\ufffd", "maximum-gap": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u6392\u5e8f\n        nums.sort()\n        \n        # \u627e\u5230\u6700\u5927\u5dee\u503c\n        max_gap = 0\n        for i in range(len(nums) - 1):\n            max_gap = max(max_gap, nums[i + 1] - nums[i])\n        \n        return max_gap\n", "binary-tree-level-order-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\n        queue = []\n        \n        # \u521b\u5efa\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u6bcf\u4e00\u5c42\u8282\u70b9\u7684\u503c\n        result = []\n        \n        # \u5982\u679c\u6839\u8282\u70b9\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u6839\u8282\u70b9\u52a0\u5165\u961f\u5217\n        if root:\n            queue.append(root)\n        \n        # \u5f00\u59cb\u904d\u5386\u961f\u5217\uff0c\u5e76\u5c06\u6bcf\u4e00\u5c42\u8282\u70b9\u7684\u503c\u5b58\u50a8\u5230\u5217\u8868\u4e2d\n        while queue:\n            # \u5982\u679c\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u7ed3\u675f\u904d\u5386\n            if not queue:\n                break\n            \n            # \u521b\u5efa\u4e00\u4e2a\u5217\u8868\uff0c\u7528\u4e8e\u5b58\u50a8\u5f53\u524d\u5c42\u8282\u70b9\u7684\u503c\n            cur_level = []\n            \n            # \u5c06\u961f\u5217\u4e2d\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u63d0\u53d6\u51fa\u6765\uff0c\u5e76\u5c06\u5176\u503c\u5b58\u50a8\u5230\u5217\u8868\u4e2d\n            cur_node = queue.pop(0)\n            cur_level.append(cur_node.val)\n            \n            # \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u5de6\u5b50\u6811\u52a0\u5165\u961f\u5217\n            if cur_node.left:\n                queue.append(cur_node.left)\n            \n            # \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u53f3\u5b50\u6811\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u53f3\u5b50\u6811\u52a0\u5165\u961f\u5217\n            if cur_node.right:\n                queue.append(", "couples-holding-hands": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u5c06\u6240\u6709\u4eba\u5206\u6210\u4e24\u7ec4\uff0c\u7136\u540e\u5bf9\u6bcf\u7ec4\u8fdb\u884c\u6392\u5e8f\n        # \u7136\u540e\u5bf9\u6bcf\u7ec4\u8fdb\u884c\u6bd4\u8f83\uff0c\u5982\u679c\u4e24\u7ec4\u4e2d\u7684\u4e24\u4e2a\u4eba\u4e0d\u5728\u540c\u4e00\u7ec4\u4e2d\uff0c\u5219\u8fdb\u884c\u4ea4\u6362\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        # \u5206\u6210\u4e24\u7ec4\n        left = []\n        right = []\n        for i in range(0, len(row), 2):\n            left.append(row[i])\n            right.append(row[i+1])\n        \n        # \u6392\u5e8f\n        left.sort()\n        right.sort()\n        \n        # \u5bf9\u6bcf\u7ec4\u8fdb\u884c\u6bd4\u8f83\n        count = 0\n        for i in range(len(left)):\n            if left[i]!= right[i]:\n                count += 1\n                left[i], right[i] = right[i], left[i]\n        \n        return count\n", "interleaving-string": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\n        if len(s1) + len(s2)!= len(s3):\n            return False\n        \n        # \u521d\u59cb\u5316dp\n        dp = [[False for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n        \n        # \u521d\u59cb\u5316dp[0][0]\n        dp[0][0] = True\n        \n        # \u521d\u59cb\u5316dp[i][0]\n        for i in range(1, len(s1)+1):\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n        \n        # \u521d\u59cb\u5316dp[0][j]\n        for j in range(1, len(s2)+1):\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n        \n        # \u5176\u5b9e\u53ef\u4ee5\u7528dp[i][j] = dp[i-1][j] or dp[i][j-1]\n        # \u56e0\u4e3adp[i][j] \u53ea\u662f\u662fdp[i-1][j] \u548c dp[i][j-1] \u7684\u7ed3\u679c\u76f8\u52a0\uff0c\n        # \u56e0\u6b64\u53ef\u4ee5\u76f4\u63a5\u7528dp[i-1][j] \u548c dp[i][j-1] \u7684\u7ed3\u679c\u76f8\u52a0\uff0c\n        # \u6240\u4ee5\u53ef\u4ee5\u7528dp[i][j] = dp[i-1][j] or dp[i][j-1]\n        \n        # \u5176\u5b9e\u53ef\u4ee5\u7528dp[i][j] = dp[i-1][j] or dp[i][j-1]\n        # \u56e0\u4e3adp[i][j] \u53ea\u662f\u662fdp[i-1][j] \u548c dp[i][j-1", "assign-cookies": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = j = count = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                count += 1\n                i += 1\n            j += 1\n        return count\n", "keyboard-row": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u6a21\u62df\u7b54\u6848\n        # row1 = set(\"qwertyuiop\")\n        # row2 = set(\"asdfghjkl\")\n        # row3 = set(\"zxcvbnm\")\n        # res = []\n        # for word in words:\n        #     if set(word).issubset(row1) or set(word).issubset(row2) or set(word).issubset(row3):\n        #         res.append(word)\n        # return res\n        \n        # \u5229\u7528\u5b57\u5178\n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        \n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        \n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        \n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        \n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\u4e2a\u5355\u884c\u5b57\u6bcd\n        \n        # \u5229\u7528\u5b57\u5178\u6765\u5224\u65ad\u662f\u5426\u662f\u4e00\ufffd", "reverse-linked-list-ii": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # 1. \u5982\u679chead\u4e3a\u7a7a\uff0c\u8fd4\u56de\u7a7a\n        # 2. \u5982\u679cleft>right\uff0c\u8fd4\u56de\u7a7a\n        # 3. \u5982\u679cleft==right\uff0c\u8fd4\u56dehead\n        # 4. \u5982\u679cleft<=right\uff0c\u5219\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206\uff0cleft\u5230right\u4e4b\u95f4\u7684\u90e8\u5206\uff0cright\u5230\u6700\u540e\u7684\u90e8\u5206\n        # 5. \u5c06left\u5230right\u4e4b\u95f4\u7684\u90e8\u5206\u7684\u94fe\u8868\u53cd\u8f6c\n        # 6. \u5c06right\u5230\u6700\u540e\u7684\u90e8\u5206\u7684\u94fe\u8868\u63d2\u5165\u5230left\u5230right\u4e4b\u95f4\u7684\u90e8\u5206\u7684\u94fe\u8868\u4e0a\n        # 7. \u5c06left\u5230right\u4e4b\u95f4\u7684\u90e8\u5206\u7684\u94fe\u8868\u63d2\u5165\u5230\u6700\u540e\u7684\u90e8\u5206\u7684\u94fe\u8868\u4e0a\n        # 8. \u5c06right\u5230\u6700\u540e\u7684\u90e8\u5206\u7684\u94fe\u8868\u63d2\u5165\u5230\u6700\u540e\u7684\u90e8\u5206\u7684\u94fe\u8868\u4e0a\n        \n        # 1. \u5982\u679chead\u4e3a\u7a7a\uff0c\u8fd4\u56de\u7a7a\n        if not head:\n            return None\n        # 2. \u5982\u679cleft>right\uff0c\u8fd4\u56de\u7a7a\n        if left > right:\n            return None\n        # 3. \u5982\u679cleft==right\uff0c\u8fd4\u56dehead\n        if left == right:\n            return head\n        # 4. \u5982\u679cleft<=right\uff0c\u5219\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206\uff0cleft\u5230right\u4e4b\u95f4\u7684\u90e8\u5206\uff0cright\u5230\u6700\u540e\u7684\u90e8\u5206\n        cur = head\n        pre = None\n        while cur and left", "shortest-palindrome": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # \u65b9\u6cd5\u4e00\uff1a\u66b4\u529b\u6cd5\n        # \u5c06\u5b57\u7b26\u4e32s\u52a0\u4e0as\u7684\u53cd\u8f6c\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u76f8\u7b49\uff0c\u5219\u8fd4\u56des+s[::-1]\n        # \u5426\u5219\uff0c\u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56des+s[::-1][:len(s)-1]\n        \n        # \u65b9\u6cd5\u4e8c\uff1a\u89e3\u9898\u601d\u8def\uff1a\n        # \u5c06s\u52a0\u4e0as\u7684\u53cd\u8f6c\u540e\u7684\u5b57\u7b26\u4e32\uff0c\u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u76f8\u7b49\uff0c\u5219\u8fd4\u56des+s[::-1]\n        # \u5426\u5219\uff0c\u5982\u679c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56des+s[::-1][:len(s)-1]\n        # \u56e0\u4e3as+s[::-1]\u662f\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u6240\u4ee5\u53ef\u4ee5\u5224\u65ads+s[::-1]\u662f\u5426\u662f\u56de\u6587\u4e32\n        # \u56e0\u4e3as+s[::-1]\u662f\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u6240\u4ee5\u53ef\u4ee5\u5224\u65ads+s[::-1]\u662f\u5426\u662f\u56de\u6587\u4e32\n        # \u56e0\u4e3as+s[::-1]\u662f\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\ufffd", "minimum-window-substring": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        # \u5148\u5c06t\u5b57\u7b26\u4e32\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386s\uff0c\u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709t\u7684\u5b57\u7b26\uff0c\u5219\u79fb\u52a8start\u6307\u9488\uff0c\u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e32\u4e2d\u6709t\u7684\u5b57\u7b26\uff0c\u5219\u79fb\u52a8end\u6307\u9488\uff0c\u76f4\u5230start\u548cend\u6307\u9488\u6307\u5411\u7684\u5b57\u7b26\u4e32\u4e2d\u90fd\u5305\u542b\u6240\u6709t\u7684\u5b57\u7b26\u3002\n        # \u7136\u540e\u518d\u6c42\u6700\u5c0f\u7684\u5b50\u5b57\u7b26\u4e32\uff0c\u5982\u679c\u6ca1\u6709\u5b50\u5b57\u7b26\u4e32\u5c31\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\u3002\n        \n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        # \u601d\u8def\uff1a\n        # \u5c06t\u5b57\u7b26\u4e32\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386s\uff0c\u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709t\u7684\u5b57\u7b26\uff0c\u5219\u79fb\u52a8start\u6307\u9488\uff0c\u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e32\u4e2d\u6709t\u7684\u5b57\u7b26\uff0c\u5219\u79fb\u52a8end\u6307\u9488\uff0c\u76f4\u5230start\u548cend\u6307\u9488\u6307\u5411\u7684\u5b57\u7b26\u4e32\u4e2d\u90fd\u5305\u542b\u6240\u6709t\u7684\u5b57\u7b26\u3002\n        # \u7136\u540e\u518d\u6c42\u6700\u5c0f\u7684\u5b50\u5b57\u7b26\ufffd", "self-crossing": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # \u627e\u5230\u7b2c\u4e00\u4e2a\u70b9\uff0c\u7136\u540e\u6bcf\u6b21\u8ba1\u7b97\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u5982\u679c\u8ddd\u79bb\u5c0f\u4e8e1\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u5927\u4e8e1\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a1\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a2\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a3\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a4\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a5\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a6\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a7\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a8\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a9\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a10\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8ddd\u79bb\u4e3a11\uff0c\u5219\u8fdb\u5165\u4e0b\u4e00\u4e2a\u70b9\uff0c\u5982", "remove-duplicates-from-sorted-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # \u5148\u5224\u65ad\u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679c\u4e3a\u7a7a\uff0c\u76f4\u63a5\u8fd4\u56de\n        if not head:\n            return head\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u6307\u9488\n        cur = head\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u6307\u9488\n        prev = head\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u6307\u9488\n        next = head.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3a\u7a7a\uff0c\u5982\u679c\u4e3a\u7a7a\uff0c\u76f4\u63a5\u8fd4\u56de\n        while next:\n            \n            # \u5982\u679c\u4e24\u4e2a\u8282\u70b9\u76f8\u540c\uff0c\u5219\u5c06\u4e24\u4e2a\u8282\u70b9\u6307\u9488\u5408\u5e76\n            if cur.val == next.val:\n                \n                # \u5982\u679c\u4e24\u4e2a\u8282\u70b9\u5408\u5e76\u540e\uff0c\u4e24\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u4e0d\u662f\u540c\u4e00\u4e2a\u8282\u70b9\uff0c\u5219\u5c06\u4e24\u4e2a\u8282\u70b9\u5408\u5e76\n                if next.next:\n                    \n                    # \u5c06\u4e24\u4e2a\u8282\u70b9\u5408\u5e76\u540e\uff0c\u4e24\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u4e0b\u4e00\u4e2a\u8282", "longest-palindrome": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        s = sorted(s)\n        \n", "construct-binary-tree-from-inorder-and-postorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # base case\n        if len(inorder) == 0:\n            return None\n        \n        # find the root\n        root = TreeNode(postorder.pop())\n        \n        # find the index of root in inorder\n        root_index = inorder.index(root.val)\n        \n        # recursively build left and right subtrees\n        root.right = self.buildTree(inorder[root_index+1:], postorder)\n        root.left = self.buildTree(inorder[:root_index], postorder)\n        \n        return root\n", "cut-off-trees-for-golf-event": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(mn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u5173\u952e\u5728\u4e8e\u6309\u7167\u9ad8\u5ea6\u6392\u5e8f\uff0c\u627e\u5230\u6700\u9ad8\u7684\u90a3\u4e2a\uff0c\u7136\u540e\u628a\u5176\u88ab\u5220\u9664\uff0c\u7136\u540e\u628a\u5176\u90a3\u4e2a\u7684\u90a3\u4e2a\u66ff\u6362\uff0c\u76f4\u5230\u6240\u6709\u7684\u88ab\u5220\u9664\n        # \u6240\u4ee5\u9700\u8981\u4e00\u4e2a\u6307\u9488\u6307\u5411\u6700\u9ad8\u7684\u90a3\u4e2a\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u5411\u6700\u4f4e\u7684\u90a3\u4e2a\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u5411\u6700\u5de6\u7684\u90a3\u4e2a\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u5411\u6700\u53f3\u7684\u90a3\u4e2a\uff0c\n        # \u5e76\u4e14\u6bcf\u6b21\u66f4\u65b0\u4e00\u4e2a\u6307\u9488\uff0c\u7136\u540e\u66f4\u65b0\u5176\u4ed6\u6307\u9488\uff0c\u76f4\u5230\u6240\u6709\u7684\u88ab\u5220\u9664\n        \n        # M2. \u53cc\u6307\u9488 + \u53cc\u6307\u9488\u6bd4\u8f83\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(mn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u5173\u952e\u5728\u4e8e\u6309\u7167\u9ad8\u5ea6\u6392\u5e8f\uff0c\u627e\u5230\u6700\u9ad8\u7684\u90a3\u4e2a\uff0c\u7136\u540e\u628a\u5176\u88ab\u5220\u9664\uff0c\u7136\u540e\u628a\ufffd", "minimum-depth-of-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1\n", "count-of-range-sum": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i][j] \u8868\u793a nums[i:j] \u7684\u548c\u5728 [lower, upper] \u4e4b\u95f4\u7684\u6570\u91cf\n        # dp[i][j] = dp[i][j-1] + nums[j] if nums[j] >= lower\n        # dp[i][j] = dp[i][j-1] if nums[j] < lower\n        # dp[i][j] = dp[i][j-1] if nums[j] > upper\n        # dp[i][j] = dp[i][j-1] if nums[j] <= upper\n        # dp[i][j] = dp[i][j-1] + dp[i][j-2] if nums[j] == lower\n        # dp[i][j] = dp[i][j-1] + dp[i][j-2] if nums[j] == upper\n        \n        dp = [[0] * (len(nums) + 1) for _ in range(len(nums) + 1)]\n        \n        for i in range(1, len(nums) + 1):\n            dp[i][i] = nums[i - 1]\n        \n        for i in range(1, len(nums) + 1):\n            for j in range(i, len(nums) + 1):\n                if nums[j - 1] >= lower:\n                    dp[i][j] = dp[i][j - 1] + nums[j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1]\n                \n                if nums[j - 1] <= upper:\n                    dp[i][j] = dp[i][j]\n                else:\n                    dp[i][j] = dp[i][j - 1]\n                \n                if nums[j - 1] == lower:\n                    dp[i][j] = dp[i][j] + dp[i][j - 2]\n                el", "arranging-coins": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u6c42\u51fa\u6240\u6709\u53ef\u80fd\u7684\u7ec4\u5408\n        # \u5148\u6c42\u51fa\u6240\u6709\u53ef\u80fd\u7684\u7ec4\u5408\uff0c\u7136\u540e\u6c42\u51fa\u7ec4\u5408\u4e2d\u7684\u548c\u4e3an\u7684\u7ec4\u5408\n        # \u5229\u7528\u8d2a\u5fc3\u7b97\u6cd5\uff0c\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u6bcf\u6b21\u4ece\u5927\u5230\u5c0f\u7684\u7ec4\u5408\u4e2d\u5220\u9664\u4e00\u4e2a\uff0c\u76f4\u5230\u6ca1\u6709\u7ec4\u5408\n        # \u6ce8\u610f\uff1a\u8fd9\u91cc\u7684\u7ec4\u5408\u662f\u6309\u7167\u6bcf\u884c\u7684\u6570\u91cf\u6392\u5e8f\u7684\uff0c\u800c\u4e0d\u662f\u6309\u7167\u6bcf\u884c\u7684\u6570\u91cf\u7684\u548c\u6392\u5e8f\u7684\n        # \u5176\u5b9e\u8fd9\u91cc\u7684\u7ec4\u5408\u662f\u6309\u7167\u6bcf\u884c\u7684\u6570\u91cf\u7684\u548c\u6392\u5e8f\u7684\uff0c\u800c\u4e0d\u662f\u6309\u7167\u6bcf\u884c\u7684\u6570\u91cf\u7684\u548c\u6392\u5e8f\u7684\n        # \u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u8981\u6c42\u51fa\u6240\u6709\u53ef\u80fd\u7684\u7ec4\u5408\uff0c\u7136\u540e\u6c42\u51fa\u7ec4\u5408\u4e2d\u7684\u548c\u4e3an\u7684\u7ec4\u5408\n        # \u6ce8\u610f\uff1a\u8fd9\u91cc\u7684\u7ec4\u5408\u662f\u6309\u7167\u6bcf\u884c\u7684\u6570\u91cf\u7684\u548c\u6392\u5e8f\u7684\uff0c\u800c\u4e0d\u662f\u6309\u7167\u6bcf\u884c\u7684\u6570\u91cf\u7684\u548c\u6392\u5e8f\u7684\n        # \u5176\u5b9e\u8fd9\u91cc\u7684\u7ec4\u5408\u662f\u6309\u7167\u6bcf\u884c\u7684\u6570\u91cf\u7684\u548c\u6392\ufffd", "longest-uncommon-subsequence-i": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 28 ms\n        # Memory Usage: 13.9 MB\n        if a == b:\n            return -1\n        \n        if len(a) > len(b):\n            a, b = b, a\n        \n        for i in range(len(a)):\n            if a[i:] in b:\n                return len(a) - i\n        \n        return len(b) - len(a)\n", "binary-tree-level-order-traversal-ii": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # # Recursive\n        # if not root:\n        #     return []\n        # res = []\n        # def dfs(root, level):\n        #     if len(res) == level:\n        #         res.append([])\n        #     res[level].append(root.val)\n        #     if root.left:\n        #         dfs(root.left, level+1)\n        #     if root.right:\n        #         dfs(root.right, level+1)\n        # dfs(root, 0)\n        # return res[::-1]\n        \n        # # Iterative\n        # if not root:\n        #     return []\n        # queue = [root]\n        # res = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     res.append(level)\n        # return res[::-1]\n        \n        # # BFS\n        # if not root:\n        #     return []\n        # queue = collections.deque([root])\n        # res = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.popleft()\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     res.append(level)\n        # return res[::-1]\n        \n        # # BFS\n        # if not root:\n        #     return []\n        # queue = collections.deque([root])\n        # res = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.", "palindrome-number": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 48 ms\n        # Memory Usage: 14.1 MB\n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        x_str = str(x)\n        \n        left = 0\n        right = len(x_str) - 1\n        \n        while left < right:\n            if x_str[left]!= x_str[right]:\n                return False\n            \n            left += 1\n            right -= 1\n        \n        return True\n", "decode-ways": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        dp = [0 for _ in range(len(s) + 1)]\n        dp[0] = 1\n        dp[1] = 1 if s[0]!= '0' else 0\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1]!= '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2]!= '0' and 10 <= int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]\n", "is-subsequence": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if not s:\n            return True\n        \n        if not t:\n            return False\n        \n        i = 0\n        for c in t:\n            if i < len(s) and s[i] == c:\n                i += 1\n        \n        return i == len(s)\n", "gray-code": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\u72b6\u6001\n        res = [0]\n        for i in range(1, n+1):\n            res.append(res[-1] ^ (1 << i))\n        return res\n", "climbing-stairs": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] + dp[i-2]\n        \n        if n == 1:\n            return 1\n        \n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]\n", "word-break": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i] \u8868\u793a s[:i] \u662f\u5426\u53ef\u4ee5\u88ab\u5206\u5272\u6210\u5355\u8bcd\n        # dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u662f\u5355\u8bcd\uff0c\u5219 dp[i] = True\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\u679c s[:i] \u4e0d\u662f\u5355\u8bcd\uff0c\u5219 dp[i] = dp[i - 1] or s[:i] in wordDict\n        # \u5982\ufffd", "validate-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower = float('-inf'), upper = float('inf')):\n            if not node:\n                return True\n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            return True\n        return helper(root)\n", "insert-interval": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u5206\u6cbb\u6cd5\n        # \u5206\u6cbb\u6cd5\uff1a\n        # \u5206\u6cbb\u6cd5\uff1a\n        # \u65b9\u6cd5\u4e00\uff1a\n        # \u5206\u6cbb\u6cd5\uff1a\n        # \u65b9\u6cd5\u4e8c\uff1a\n        # \u65b9\u6cd5\u4e09\uff1a\n        # \u65b9\u6cd5\u56db\uff1a\n        # \u65b9\u6cd5\u4e94\uff1a\n        # \u65b9\u6cd5\u516d\uff1a\n        # \u65b9\u6cd5\u4e03\uff1a\n        # \u65b9\u6cd5\u516b\uff1a\n        # \u65b9\u6cd5\u4e5d\uff1a\n        # \u65b9\u6cd5\u5341\uff1a\n        # \u65b9\u6cd5\u5341\u4e00\uff1a\n        # \u65b9\u6cd5\u5341\u4e8c\uff1a\n        # \u65b9\u6cd5\u5341\u4e09\uff1a\n        # \u65b9\u6cd5\u5341\u56db\uff1a\n        # \u65b9\u6cd5\u5341\u4e94\uff1a\n        # \u65b9\u6cd5\u5341\u516d\uff1a\n        # \u65b9\u6cd5\u5341\u4e03\uff1a\n        # \u65b9\u6cd5\u5341\u516b\uff1a\n        # \u65b9\u6cd5\u5341\u4e5d\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u4e00\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u4e8c\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u4e09\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u56db\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u4e94\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u516d\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u4e03\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u516b\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u4e5d\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u5341\u4e00\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u5341\u4e8c\uff1a\n        # \u65b9\u6cd5\u5341\u5341\u5341", "palindrome-partitioning": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            \n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n                    \n        res = []\n        backtrack(s, [], res)\n        return res\n", "smallest-range-covering-elements-from-k-lists": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u6392\u5e8f\n        nums.sort()\n        \n        # \u8ba1\u7b97\u6700\u5de6\u8fb9\u754c\u548c\u6700\u53f3\u8fb9\u754c\n        left, right = nums[0][0], nums[-1][-1]\n        \n        # \u521d\u59cb\u5316\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\n        min_range = [left, right]\n        \n        # \u521d\u59cb\u5316\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\n        min_range[0] = nums[0][0]\n        min_range[1] = nums[0][-1]\n        \n        # \u521d\u59cb\u5316\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\n        max_range[0] = nums[-1][0]\n        max_range[1] = nums[-1][-1]\n        \n        # \u521d\u59cb\u5316\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\n        for i in range(1, len(nums)):\n            \n            # \u5224\u65ad\u5f53\u524d\u6570\u7ec4\u7684\u6700\u5de6\u8fb9\u754c\u548c\u6700\u53f3\u8fb9\u754c\n            left = min(left, nums[i][0])\n            right = max(right, nums[i][-1])\n            \n            # \u5224\u65ad\u5f53\u524d\u6570\u7ec4\u7684\u6700\u5de6\u8fb9\u754c\u548c\u6700\u53f3\u8fb9\u754c\n            if left > max_range[0]:\n                max_range[0] = left\n            if right < min_range[1]:\n                min_range[1] = right\n        \n        # \u8fd4\u56de\u6700\u5c0f\u7684\u8303\u56f4\n        return min_range\n", "poor-pigs": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i][j] \u8868\u793a\u7b2ci\u4e2apig\uff0c\u7b2cj\u4e2abucket\uff0c\u5230\u7b2cj\u4e2abucket\u4e4b\u540e\uff0c\u6700\u591a\u53ef\u4ee5\u8ba9i\u4e2apig\u90fd\u4e0d\u6b7b\n        dp = [[0] * buckets for _ in range(2)]\n        dp[0][0] = 1\n        for i in range(1, buckets):\n            dp[0][i] = dp[0][i-1] + 1\n        for i in range(1, 2):\n            dp[i][0] = dp[i-1][0] + 1\n        for i in range(1, buckets):\n            for j in range(1, buckets):\n                dp[i%2][j] = dp[(i-1)%2][j] + dp[i%2][j-1]\n        \n        # \u5224\u65ad\u6bcf\u4e2abucket\u662f\u5426\u53ef\u4ee5\u63a5\u53d7\n        for i in range(1, buckets):\n            if dp[0][i] + dp[1][i] >= minutesToDie:\n                return i\n        return buckets\n", "swim-in-rising-water": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        # \u521d\u59cb\u5316\n        n = len(grid)\n        if n == 0:\n            return 0\n        \n        # \u521d\u59cb\u5316\n        dp = [[float('inf') for _ in range(n)] for _ in range(n)]\n        dp[0][0] = 0\n        \n        # \u521d\u59cb\u5316\n        for i in range(n):\n            for j in range(n):\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j])\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n        \n        # \u5411\u4e0b\u79fb\u52a8\n        for i in range(n-2, -1, -1):\n            for j in range(n):\n                if i < n-1:\n                    dp[i][j] = min(dp[i][j], dp[i+1][j] + grid[i][j])\n                if j < n-1:\n                    dp[i][j] = min(dp[i][j], dp[i][j+1] + grid[i][j])\n        \n        # \u5411\u4e0a\u79fb\u52a8\n        for i in range(1, n):\n            for j in range(n):\n                if i < n-1:\n                    dp[i][j] = min(dp[i][j], dp[i+1][j] + grid[i][j])\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j])\n        \n        return dp[0][n-1]\n", "unique-paths": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u52a8\u6001\u89c4\u5212\n        # dp[i][j]\u8868\u793a\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # \u8fd9\u4e2a\u65b9\u6cd5\u662f\u6c42\u51fa\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\uff0c\u5373\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\u4e3a\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\u4e3a\u7b2ci\u884c\uff0cj-1\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\n        # \u5982\u679c\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\u4e3a\u7b2ci\u884c\uff0cj-1\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\uff0c\u90a3\u4e48\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\u4e3a\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\u4e3a\u7b2ci\u884c\uff0cj-1\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # \u5982\u679c\u7b2ci\u884c\uff0cj\u5217\u7684\u7b2c\u4e00\u4e2a\u8d70\u5230\u7684\u7ed3\u70b9\u4e3a\u7b2ci\u884c\uff0cj-1\u5217\u7684", "multiply-strings": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Runtime: 40 ms\n        # Memory: 13.3 MB\n        \n        # Convert num1 and num2 to list of digits\n        num1_list = [int(x) for x in num1]\n        num2_list = [int(x) for x in num2]\n        \n        # Initialize result list\n        result_list = [0] * (len(num1_list) + len(num2_list))\n        \n        # Multiply num1 and num2 digit by digit\n        for i in range(len(num1_list) - 1, -1, -1):\n            for j in range(len(num2_list) - 1, -1, -1):\n                result_list[i + j + 1] += num1_list[i] * num2_list[j]\n                result_list[i + j] += result_list[i + j + 1] // 10\n                result_list[i + j + 1] %= 10\n        \n        # Convert result list to string\n        result = \"\".join([str(x) for x in result_list])\n        \n        # Remove leading zeros\n        while result and result[0] == \"0\":\n            result = result[1:]\n        \n        return result\n", "best-time-to-buy-and-sell-stock-iii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(prices) < 2:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit\n", "combination-sum-ii": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u6bcf\u6b21\u9009\u62e9\u4e00\u4e2a\u6570\uff0c\u6c42\u51fa\u5269\u4f59\u6570\u7684\u7ec4\u5408\n        # \u6ce8\u610f\uff1a\n        # \u5982\u679c\u5f53\u524d\u6570\u4e0d\u80fd\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408\n        # \u5982\u679c\u5f53\u524d\u6570\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408\n        # \u6ce8\u610f\uff1a\n        # \u5982\u679c\u5f53\u524d\u6570\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408\n        # \u5982\u679c\u5f53\u524d\u6570\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408\n        # \u5982\u679c\u5f53\u524d\u6570\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408\n        # \u5982\u679c\u5f53\u524d\u6570\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408\n        # \u5982\u679c\u5f53\u524d\u6570\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408\n        # \u5982\u679c\u5f53\u524d\u6570\u548c\u5230\u76ee\u6807\u503c\uff0c\u90a3\u4e48\u5c31\u8981\u8003\u8651\u4ed6\u4eec\u7684\u7ec4\u5408", "detect-capital": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        \n        for i in range(1, len(word)):\n            if word[i].isupper() and word[i-1].islower():\n                return True\n            if word[i].islower() and word[i-1].isupper():\n                return True\n        \n        return False\n", "best-time-to-buy-and-sell-stock": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\n        if len(prices) < 2:\n            return 0\n        \n        # \u521d\u59cb\u5316\n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit\n", "binary-tree-inorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        res = []\n        if not root:\n            return res\n        \n        stack = []\n        curr = root\n        \n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res\n", "construct-binary-tree-from-preorder-and-inorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        \n        root_index = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root\n", "remove-invalid-parentheses": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u53ef\u80fd\u7684\u89e3\n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u53ef\u80fd\u7684\u89e3\n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u53ef\u80fd\u7684\u89e3\n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u53ef\u80fd\u7684\u89e3\n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u53ef\u80fd\u7684\u89e3\n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u53ef\u80fd\u7684\u89e3\n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                if count < 0:\n                    return False\n            return count ==", "merge-k-sorted-lists": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\n        lists = sorted(lists, key=lambda x: x.val)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u94fe\u8868\n        head = ListNode()\n        \n        # \u521b\u5efa\u4e00\u4e2a\u6307\u9488\n        cur = head\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\n        q = collections.deque()\n        \n        # \u5c06\u6bcf\u4e2a\u94fe\u8868\u6dfb\u52a0\u5230\u961f\u5217\u4e2d\n        for l in lists:\n            if l:\n                q.append(l)\n        \n        # \u5f00\u59cb\u5faa\u73af\n        while q:\n            # \u53d6\u51fa\u961f\u5217\u4e2d\u7684\u9996\u4e2a\u94fe\u8868\n            l = q.popleft()\n            \n            # \u5982\u679c\u94fe\u8868\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n            if not l:\n                continue\n            \n            # \u5982\u679c\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n            if not l.next:\n                cur.next = l\n                cur = l\n                continue\n            \n            # \u5982\u679c\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u6dfb\u52a0\u5230\u961f\u5217\u4e2d\n            q.append(l.next)\n            \n            # \u5982\u679c\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n            if not l.next:\n                cur.next = l\n                cur = l\n                continue\n            \n            # \u5982\u679c\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u4e0d\u4e3a", "palindrome-partitioning-ii": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u4f18\u5316\uff1a\u53ef\u4ee5\u5229\u7528dp[i][j]\u8868\u793as[i:j+1]\u662f\u5426\u4e3a\u56de\u6587\u4e32\uff0c\n        # \u56e0\u4e3as[i:j+1]\u662f\u56de\u6587\u4e32\uff0cdp[i][j] = dp[i+1][j-1] + 1\n        # \u5982\u679cs[i]!= s[j], dp[i][j] = dp[i+1][j] + dp[i][j-1] + 2\n        # \u5982\u679cs[i] == s[j], dp[i][j] = dp[i+1][j-1]\n        # \u5982\u679cs[i] == s[j] and i == j, dp[i][j] = 0\n        # \u5982\u679cs[i] == s[j] and i < j, dp[i][j] = dp[i+1][j-1] + 1\n        # \u5982\u679cs[i]!= s[j] and i == j, dp[i][j] = dp[i+1][j] + dp[i][j-1] + 2\n        # \u5982\u679cs[i] == s[j] and i < j, dp[i][j] = dp[i+1][j-1]\n        # \u5982\u679cs[i]!= s[j] and i > j, dp[i][j] = dp[i+1][j] + dp[i][j-1] + 2\n        # \u5982\u679cs[i] == s[j] and i > j, dp[i][j] = dp[i+1][j-1]\n        # \u5982\ufffd", "preimage-size-of-factorial-zeroes-function": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # \u6c42\u51fa\u6240\u6709\u7684 f(x) \u503c\uff0c\u7136\u540e\u6c42\u51fa\u6240\u6709\u7684 x \u4f7f f(x) = k\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        \n        # \u601d\u8def\uff1a\n        # \u6c42\u51fa\u6240\u6709\u7684 f(x) \u503c\uff0c\u7136\u540e\u6c42\u51fa\u6240\u6709\u7684 x \u4f7f f(x) = k\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        \n        # \u601d\u8def\uff1a\n        # \u6c42\u51fa\u6240\u6709\u7684 f(x) \u503c\uff0c\u7136\u540e\u6c42\u51fa\u6240\u6709\u7684 x \u4f7f f(x) = k\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        \n        # \u601d\u8def\uff1a\n        # \u6c42\u51fa\u6240\u6709\u7684 f(x) \u503c\uff0c\u7136\u540e\u6c42\u51fa\u6240\u6709\u7684 x \u4f7f f(x) = k\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        \n        # \u601d\u8def\uff1a\n        # \u6c42\u51fa\u6240\u6709\u7684 f(x) \u503c\uff0c\u7136\u540e\u6c42\u51fa\u6240\u6709\u7684 x \u4f7f f(x) = k\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(k)\n        \n        #", "palindrome-pairs": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u5b57\u5178\u6811\n        # \u5b57\u5178\u6811\u7684\u63d2\u5165\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\uff0c\u63d2\u5165\u64cd\u4f5c\u7684\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(nlog(n))\n        # \u5b57\u5178\u6811\u7684\u5220\u9664\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\uff0c\u5220\u9664\u64cd\u4f5c\u7684\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(nlog(n))\n        # \u5b57\u5178\u6811\u7684\u67e5\u627e\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\uff0c\u67e5\u627e\u64cd\u4f5c\u7684\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(nlog(n))\n        # \u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(nlog(n))\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\n        # \u5229\u7528\u5b57\u5178\u6811\u7684\u67e5\u627e\u64cd\u4f5c\uff0c\u67e5\u627e\u6bcf\u4e2a\u5b57\u7b26\u4e32\u7684\u6240\u6709\u53ef\u80fd\u7684\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u6784\u5efa\u4e00\u4e2a\u5b57\u5178\u6811\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4e32\u7684\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u662f\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\n        # \u5b57\u5178\u6811\u7684\u67e5\u627e\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\uff0c\u67e5\u627e\u64cd\u4f5c\u7684\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(nlog(n))\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\n", "convert-sorted-array-to-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # \u65b9\u6cd5\u4e00\uff1a\u9012\u5f52\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(h)\n        # \u4f18\u5316\uff1a\u9012\u5f52\u8c03\u7528\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\n        if not nums:\n            return None\n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root\n        \n        \n        # \u65b9\u6cd5\u4e8c\uff1a\u5806\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4f18\u5316\uff1a\u5806\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn)\n        import heapq\n        if not nums:\n            return None\n        nums = [-num for num in nums]\n        heapq.heapify(nums)\n        root = TreeNode(nums[0])\n        stack = [(root, nums)]\n        while stack:\n            node, nums = stack.pop()\n            if nums:\n                node.left = TreeNode(nums[0])\n                stack.append((node.left, nums[1:]))\n                node.right = TreeNode(nums[-1])\n                stack.append((node.right, nums[:-1]))\n        return root\n        \n        \n        # \u65b9\u6cd5\u4e09\uff1a\u9012\u5f52+\u6808\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(h)\n        # \u4f18\u5316\uff1a\u9012\u5f52\u8c03\u7528\u7684\u65f6\ufffd", "contain-virus": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\n        # \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5355\u5143\u683c\uff0c\u5982\u679c\u5355\u5143\u683c\u662f\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\u88ab\ufffd", "longest-increasing-path-in-a-matrix": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = 1 + dp[i][j-1] if matrix[i][j] > matrix[i][j-1] else 1\n                elif j == 0:\n                    dp[i][j] = 1 + dp[i-1][j] if matrix[i][j] > matrix[i-1][j] else 1\n                else:\n                    dp[i][j] = 1 + max(dp[i-1][j], dp[i][j-1]) if matrix[i][j] > matrix[i-1][j] and matrix[i][j] > matrix[i][j-1] else 1\n        \n        return max(max(row) for row in dp)\n", "number-of-digit-one": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        \n        while n:\n            count += n % 10\n            n //= 10\n            \n            if n:\n                count += n % 10 * 9 // 10 + 1\n                n //= 10\n                \n        return count\n", "word-break-ii": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u521d\u59cb\u5316\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        # \u5224\u65ad\n        if not dp[-1]:\n            return []\n        \n        res = []\n        self.dfs(s, wordDict, [], res, 0)\n        return res\n        \n    def dfs(self, s, wordDict, path, res, start):\n        if start == len(s):\n            res.append(\" \".join(path))\n            return\n        \n        for i in range(start, len(s)):\n            if dp[i] and s[start:i+1] in wordDict:\n                path.append(s[start:i+1])\n                self.dfs(s, wordDict, path, res, i+1)\n                path.pop()\n                \n        \n# Time:  O(n * m^2)\n# Space: O(m)\n# DP solution.\nclass Solution2(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        res = []\n        self.dfs(s, wordDict, [], res, 0)\n        return res\n        \n    def dfs(self, s, wordDict, path, res, start):\n        if start == len(s):\n", "binary-tree-zigzag-level-order-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if len(level) == 0:\n                break\n            \n            if len(result) % 2 == 0:\n                result.append(level)\n            else:\n                result.insert(0, level)\n                \n        return result\n", "binary-watch": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(n, m):\n            if n == 0:\n                return m\n            if m == 0:\n                return n\n            return get_time(n-1, m) + get_time(n, m-1)\n        \n        def get_time_str(n, m):\n            if n == 0:\n                return str(m)\n            if m == 0:\n                return str(n)\n            return get_time_str(n-1, m) + \":\" + get_time_str(n, m-1)\n        \n        return [get_time_str(n, m) for n in range(12) for m in range(60) if n + m == turnedOn]\n", "pascals-triangle": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        res = [[1]]\n        for i in range(1, numRows):\n            res.append([1])\n            for j in range(1, i):\n                res[i].append(res[i-1][j-1] + res[i-1][j])\n            res[i].append(1)\n        return res\n", "power-of-three": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.7 MB\n        if n == 0:\n            return False\n        \n        while n % 3 == 0:\n            n //= 3\n        \n        return n == 1\n", "binary-tree-maximum-path-sum": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # dfs\n        # time O(n) space O(n)\n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left + right + node.val)\n            \n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum\n        \n        \n        # dp\n        # time O(n) space O(n)\n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left + right + node.val)\n            \n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum\n        \n        \n        # bfs\n        # time O(n) space O(1)\n        if not root:\n            return 0\n        \n        self.max_sum = float('-inf')\n        queue = collections.deque([root])\n        \n        while queue:\n            node = queue.popleft()\n            \n            if node.left:\n                queue.append(node.left)\n            \n            if node.right:\n                queue.append(node.right)\n            \n            self.max_sum = max(self.max_sum, node.val + max(0, self.max_sum))\n        \n        return self.max_sum\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "trapping-rain-water-ii": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m = len(heightMap)\n        n = len(heightMap[0])\n        \n        left_max = [0] * n\n        right_max = [0] * n\n        \n        for i in range(m):\n            for j in range(n):\n                left_max[j] = max(left_max[j], heightMap[i][j])\n                \n        for i in range(m-1, -1, -1):\n            for j in range(n):\n                right_max[j] = max(right_max[j], heightMap[i][j])\n                \n        water = 0\n        for i in range(m):\n            for j in range(n):\n                water += min(left_max[j], right_max[j]) - heightMap[i][j]\n        \n        return water\n", "valid-palindrome": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # \u5220\u9664\u7a7a\u683c\n        s = s.replace(\" \", \"\")\n        \n        # \u5c06\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5c0f\u5199\n        s = s.lower()\n        \n        # \u5220\u9664\u975e\u5b57\u6bcd\u548c\u6570\u5b57\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # \u5224\u65ad\u662f\u5426\u662f\u56de\u6587\n        return s == s[::-1]\n", "sliding-window-median": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u627e\u4e2d\u4f4d\u6570\n        nums.sort()\n        res = []\n        for i in range(0, len(nums), k):\n            if i+k > len(nums):\n                res.append(nums[i] if len(nums) % 2 == 1 else (nums[i] + nums[i+1]) / 2)\n            else:\n                res.append(nums[i+k//2])\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "rotate-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # \u5148\u5224\u65ad\u662f\u5426\u4e3a\u7a7a\n        if not head:\n            return head\n        \n        # \u5224\u65adk\u662f\u5426\u4e3a0\n        if k == 0:\n            return head\n        \n        # \u5224\u65ad\u662f\u5426\u4e3a1\n        if k == 1:\n            return head.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3a2\n        if k == 2:\n            return head.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+1\n        if k == 2 * 10 ** 9 + 1:\n            return head\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+2\n        if k == 2 * 10 ** 9 + 2:\n            return head.next.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+3\n        if k == 2 * 10 ** 9 + 3:\n            return head.next.next.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+4\n        if k == 2 * 10 ** 9 + 4:\n            return head.next.next.next.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+5\n        if k == 2 * 10 ** 9 + 5:\n            return head.next.next.next.next.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+6\n        if k == 2 * 10 ** 9 + 6:\n            return head.next.next.next.next.next.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+7\n        if k == 2 * 10 ** 9 + 7:\n            return head.next.next.next.next.next.next.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+8\n        if k == 2 * 10 ** 9 + 8:\n            return head.next.next.next.next.next.next.next.next.next\n        \n        # \u5224\u65ad\u662f\u5426\u4e3ak+9\n        if k == 2 * 10 ** 9 + 9:\n            ", "ugly-number": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # \u65b9\u6cd5\u4e00\uff1a\n        # \u5982\u679cn\u4e3a1\uff0c\u5219\u8fd4\u56deTrue\n        if n == 1:\n            return True\n        \n        # \u5982\u679cn\u4e0d\u662f2\u30013\u30015\uff0c\u5219\u8fd4\u56deFalse\n        if n % 2 == 0 or n % 3 == 0 or n % 5 == 0:\n            return False\n        \n        # \u5982\u679cn\u4e0d\u662f2\u30013\u30015\uff0c\u5219\u5faa\u73af\u5224\u65adn\u7684\u4e0b\u4e00\u4e2a\u6570\n        while n!= 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n        \n        # \u5982\u679cn\u4e3a1\uff0c\u5219\u8fd4\u56deTrue\n        return True\n        \n        # \u65b9\u6cd5\u4e8c\uff1a\n        # \u5982\u679cn\u4e3a1\uff0c\u5219\u8fd4\u56deTrue\n        if n == 1:\n            return True\n        \n        # \u5982\u679cn\u4e0d\u662f2\u30013\u30015\uff0c\u5219\u8fd4\u56deFalse\n        if n % 2 == 0 or n % 3 == 0 or n % 5 == 0:\n            return False\n        \n        # \u5982\u679cn\u4e0d\u662f2\u30013\u30015\uff0c\u5219\u5faa\u73af\u5224\u65adn\u7684\u4e0b\u4e00\u4e2a\u6570\n        while n!= 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n        \n        # \u5982\u679cn\u4e3a1\uff0c\u5219\u8fd4\u56deTrue\n        return True\n        \n        # \u65b9\u6cd5\u4e09\uff1a\n        # \u5982\u679cn\u4e3a1\uff0c\u5219\u8fd4\u56deTrue\n        if n == 1:\n            return True\n        \n        # \ufffd", "falling-squares": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\n        res = [0] * len(positions)\n        \n        # \u6392\u5e8f\n        positions.sort(key = lambda x: x[0])\n        \n        # \u521d\u59cb\u5316\u72b6\u6001\n        dp = [0] * len(positions)\n        \n        # \u6839\u636e\u72b6\u6001\u8ba1\u7b97\n        for i in range(len(positions)):\n            for j in range(i):\n                if positions[i][1] > positions[j][1]:\n                    dp[i] = max(dp[i], dp[j])\n            dp[i] += positions[i][1]\n            res[i] = max(res[i], dp[i])\n        \n        return res\n", "sum-of-left-leaves": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 36 ms\n        # Memory: 13.6 MB\n        \n        # Solution 1:\n        # Recursive\n        \n        def helper(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right and is_left:\n                return node.val\n            return helper(node.left, True) + helper(node.right, False)\n        \n        return helper(root, False)\n        \n        # Solution 2:\n        # Iterative\n        \n        if not root:\n            return 0\n        \n        stack = [(root, False)]\n        \n        total = 0\n        while stack:\n            node, is_left = stack.pop()\n            if not node:\n                continue\n            if not node.left and not node.right and is_left:\n                total += node.val\n            else:\n                stack.append((node.right, False))\n                stack.append((node.left, True))\n        \n        return total\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "max-sum-of-rectangle-no-larger-than-k": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # \u521d\u59cb\u5316: dp[0][0] = matrix[0][0]\n        # \u7ed3\u675f\u6761\u4ef6: dp[m-1][n-1] = matrix[m-1][n-1]\n        # \u521d\u59cb\u5316: dp[i][j] = matrix[i][j]\n        # \u7ed3\u675f\u6761\u4ef6: dp[i][j] = matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        # dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + matrix[i][j]\n        ", "divide-two-integers": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if divisor == 0:\n            return 0\n        \n        if divisor > 0:\n            if dividend < 0:\n                dividend = -dividend\n                divisor = -divisor\n            \n            sign = 1\n        else:\n            if dividend > 0:\n                dividend = -dividend\n                divisor = -divisor\n            \n            sign = -1\n        \n        quotient = 0\n        \n        while dividend >= divisor:\n            temp = divisor\n            i = 1\n            while temp <= dividend:\n                temp += divisor\n                i += 1\n            \n            dividend -= divisor\n            quotient += i\n        \n        quotient = sign * quotient\n        \n        if quotient > 2**31 - 1:\n            return 2**31 - 1\n        elif quotient < -2**31:\n            return -2**31\n        \n        return quotient\n", "surrounded-regions": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u8fb9\u754c\n        if m == 1 or n == 1:\n            return\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u8fb9\u754c\n        if board[0][0] == 'O' or board[0][n-1] == 'O' or board[m-1][0] == 'O' or board[m-1][n-1] == 'O':\n            return\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u8fb9\u754c\n        for i in range(1, m-1):\n            for j in range(1, n-1):\n                if board[i][j] == 'O':\n                    if board[i-1][j] == 'O' or board[i+1][j] == 'O' or board[i][j-1] == 'O' or board[i][j+1] == 'O':\n                        board[i][j] = 'X'\n                    else:\n                        board[i][j] = 'O'\n        \n        # \u6253\u5370\n        for i in range(m):\n            for j in range(n):\n                print(board[i][j], end=' ')\n            print()\n", "two-sum": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n                \n", "24-game": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\n        cards.sort()\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[0] == cards[1] == cards[2] == cards[3]:\n            return cards[0] == 24\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[0] == cards[1] == cards[2]:\n            return cards[0] * cards[2] == 24\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[1] == cards[2] == cards[3]:\n            return cards[1] * cards[3] == 24\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[0] == cards[1] == cards[3]:\n            return cards[0] * cards[3] == 24\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[0] == cards[2] == cards[3]:\n            return cards[0] * cards[2] == 24\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[1] == cards[2] == cards[3]:\n            return cards[1] * cards[2] == 24\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[0] == cards[1] == cards[2]:\n            return cards[0] * cards[2] == 24\n        \n        # \u5982\u679c\u6570\u5b57\u76f8\u7b49\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        if cards[0]", "wildcard-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP\n        # dp[i][j] = True if s[:i] and p[:j] match\n        # dp[i][j] = False if s[:i] and p[:j] do not match\n        # dp[i][j] = dp[i-1][j-1] if s[i] and p[j] are the same\n        # dp[i][j] = dp[i-1][j] if p[j] is '?'\n        # dp[i][j] = dp[i][j-1] if p[j] is '*'\n        # dp[i][j] = False if i is 0 and j is 0 and p[j] is '*'\n        # dp[i][j] = False if i is 0 and j is 0 and p[j] is '?'\n        # dp[i][j] = False if i is 0 and j is 0 and p[j] is not '?' and p[j] is not '*'\n        # dp[i][j] = False if i is 0 and j is not 0 and p[j] is not '?' and p[j] is not '*'\n        # dp[i][j] = False if i is not 0 and j is 0 and p[j] is not '?' and p[j] is not '*'\n        # dp[i][j] = False if i is not 0 and j is not 0 and p[j] is not '?' and p[j] is not '*'\n        # dp[i][j] = False if i is not 0 and j is not 0 and p[j] is '*' and s[i] is not p[j-1]\n        # dp[i][j] = False if i is not 0 and j is not 0 and p[j] is '*' and s[i] is p[j-1]\n        # dp[i][j] = False if i is not 0 and j is not 0 and p[j] is '*' and s[i] is not p[j-1] and s[i] is not p[j-2]\n        # d", "majority-element": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u6c42\u89e3\n        # \u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u5b58\u50a8\u6bcf\u4e2a\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u7136\u540e\u67e5\u627e\u51fa\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u5927\u4e8en/2\u7684\u5143\u7d20\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u5b58\u50a8\u6bcf\u4e2a\u5143\u7d20\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u7136\u540e\u67e5\u627e\u51fa\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u5927\u4e8en/2\u7684\u5143\u7d20\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        # \u53cc\u6307\u9488+\u6392\u5e8f\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u53cc\u6307\u9488+\u6392\u5e8f+\u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u53cc\u6307\u9488+\u6392\u5e8f+\u54c8\u5e0c\u8868+\u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1a", "reconstruct-itinerary": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u521b\u5efa\u4e00\u4e2a\u5b57\u5178\uff0ckey\u4e3a\u6bcf\u4e2a\u70b9\uff0cvalue\u4e3a\u8fd9\u4e2a\u70b9\u7684\u51fa\u73b0\u6b21\u6570\n        dic = {}\n        for ticket in tickets:\n            dic[ticket[0]] = dic.get(ticket[0], 0) + 1\n        \n        # \u6784\u9020\u4e00\u4e2a\u56fe\uff0ckey\u4e3a\u6bcf\u4e2a\u70b9\uff0cvalue\u4e3a\u8fd9\u4e2a\u70b9\u7684\u51fa\u73b0\u6b21\u6570\n        graph = collections.defaultdict(list)\n        for ticket in tickets:\n            graph[ticket[0]].append(ticket[1])\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0ckey\u4e3a\u6bcf\u4e2a\u70b9\uff0cvalue\u4e3a\u8fd9\u4e2a\u70b9\u7684\u51fa\u73b0\u6b21\u6570\n        queue = collections.deque()\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0ckey\u4e3a\u6bcf\u4e2a\u70b9\uff0cvalue\u4e3a\u8fd9\u4e2a\u70b9\u7684\u51fa\u73b0\u6b21\u6570\n        queue = collections.deque()\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0ckey\u4e3a\u6bcf\u4e2a\u70b9\uff0cvalue\u4e3a\u8fd9\u4e2a\u70b9\u7684\u51fa\u73b0\u6b21\u6570\n        queue = collections.deque()\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0ckey\u4e3a\u6bcf\u4e2a\u70b9\uff0cvalue\u4e3a\u8fd9\u4e2a\u70b9\u7684\u51fa\u73b0\u6b21\u6570\n        queue = collections.deque()\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0ckey\u4e3a\u6bcf\u4e2a\u70b9\uff0cvalue\u4e3a\u8fd9\u4e2a\u70b9\u7684\u51fa\u73b0\u6b21\u6570\n        queue = collections.deque()\n        \n        # \ufffd", "4sum": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u5143\u7d20\u8fdb\u884c\u56db\u6570\u67e5\u627e\n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s < target:\n                        l += 1\n                    elif s > target:\n                        r -= 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n        return res\n\n# Time:  O(n^3)\n# Space: O(n^2)\nclass Solution2(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + num", "the-skyline-problem": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        buildings.sort(key=lambda x: (x[0], -x[2]))\n        \n        # \u521d\u59cb\u5316\u7ed3\u679c\n        result = []\n        \n        # \u521d\u59cb\u5316\u5de6\u8fb9\u754c\n        left = -float('inf')\n        \n        # \u521d\u59cb\u5316\u53f3\u8fb9\u754c\n        right = float('inf')\n        \n        # \u521d\u59cb\u5316\u9ad8\u5ea6\n        height = 0\n        \n        for lefti, righti, heighti in buildings:\n            \n            # \u5982\u679c\u5de6\u8fb9\u754c\u5c0f\u4e8e\u5f53\u524d\u7684\u5de6\u8fb9\u754c\uff0c\u5219\u66f4\u65b0\u5de6\u8fb9\u754c\n            if lefti < left:\n                left = lefti\n                \n            # \u5982\u679c\u53f3\u8fb9\u754c\u5927\u4e8e\u5f53\u524d\u7684\u53f3\u8fb9\u754c\uff0c\u5219\u66f4\u65b0\u53f3\u8fb9\u754c\n            if righti > right:\n                right = righti\n                \n            # \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u5927\u4e8e\u5f53\u524d\u7684\u9ad8\u5ea6\uff0c\u5219\u66f4\u65b0\u9ad8\u5ea6\n            if heighti > height:\n                height = heighti\n                \n            # \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u5c0f\u4e8e\u5f53\u524d\u7684\u9ad8\u5ea6\uff0c\u5219\u66f4\u65b0\u7ed3\u679c\n            if heighti < height:\n                result.append([left, height])\n                \n        # \u5982\u679c\u5f53\u524d\u9ad8\u5ea6\u5927\u4e8e\u5f53\u524d\u7684\u9ad8\u5ea6\uff0c\u5219\u66f4\u65b0\u7ed3\u679c\n        if height > 0:\n            result.append([right, 0])\n            \n        return result\n", "reverse-string": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        # Iterative\n        i, j = 0, len(s) - 1\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        \n        # Recursive\n        # def reverseString(self, s, i, j):\n        #     if i >= j:\n        #         return\n        #     s[i], s[j] = s[j], s[i]\n        #     self.reverseString(s, i + 1, j - 1)\n        #     \n        # reverseString(s, 0, len(s) - 1)\n        \n        # Iterative\n        # def reverseString(self, s):\n        #     i, j = 0, len(s) - 1\n        #     while i < j:\n        #         s[i], s[j] = s[j], s[i]\n        #         i += 1\n        #         j -= 1\n        \n        # Recursive\n        # def reverseString(self, s, i, j):\n        #     if i >= j:\n        #         return\n        #     s[i], s[j] = s[j], s[i]\n        #     reverseString(s, i + 1, j - 1)\n        #     \n        # reverseString(s, 0, len(s) - 1)\n        \n        # Iterative\n        # def reverseString(self, s):\n        #     i, j = 0, len(s) - 1\n        #     while i < j:\n        #         s[i], s[j] = s[j], s[i]\n        #         i += 1\n        #         j -= 1\n        \n        # Recursive\n        # def reverseString(self, s, i, j):\n        #     if i >= j:\n        #         return\n        #     s[i], s[j] = s[j], s[i]\n        #     reverseString(s, i + 1, j - 1)\n        #     \n        # reverseString(s, 0, len(s)", "reverse-linked-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        prev = None\n        while head:\n            next = head.next\n            head.next = prev\n            prev = head\n            head = next\n        return prev\n        \n        # recursive\n        if head is None:\n            return None\n        else:\n            return self.reverseList(head.next) + head\n", "triangle": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 20 ms\n        # Memory: 13.5 MB\n        dp = triangle[-1]\n        for i in range(len(triangle) - 2, -1, -1):\n            for j in range(len(triangle[i])):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n        return dp[0]\n", "integer-to-english-words": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        def convert(num):\n            if num == 0:\n                return \"Zero\"\n            \n            # \u5206\u6210\u5341\u4f4d\u3001\u767e\u4f4d\u3001\u5343\u4f4d\n            ten, hundred, thousand = 1, 10, 1000\n            \n            # \u5206\u6210\u5341\u3001\u767e\u3001\u5343\n            ten_words, hundred_words, thousand_words = [\"\", \"Ten\", \"One Hundred\", \"One Thousand\", \"One Million\", \"One Billion\", \"One Trillion\", \"One Quadrillion\", \"One Quintillion\", \"One Sesquillion\"], [\"\", \"Hundred\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\", \"Quadrillion\", \"Quintillion\", \"Sesquillion\", \"Sextillion\"], [\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\", \"Quadrillion\", \"Quintillion\", \"Sesquillion\", \"Sextillion\", \"Septillion\", \"Octillion\", \"Nonillion\", \"Decillion\"]\n            \n            # \u5206\u6210\u5341\u3001\u767e\u3001\u5343\u7684\u6570\u5b57\n            ten_num = num % ten\n            hundred_num = (num // ten) % ten\n            thousand_num = (num // hundred) % ten\n            \n            # \u5206\u6210\u5341\u3001\u767e\u3001\u5343\u7684\u6570\u5b57\u7684\u5355\u8bcd\n            ten_word = convert(ten_num) if ten_num!= 0 else \"\"\n            hundred_word = convert(hundred_num) if hundred_num!= 0 else \"\"\n            thousand_word = convert(thousand_num) if thousand_num!= 0 else \"\"\n            \n            # \u5408\u5e76\u5355\u8bcd\n            if ten_word and hundred_word:\n                return ten_word + \" \" + hundred_word\n            elif ten_word:\n                return ten_word\n            elif hundred_word:\n                return hundred_word\n            else:\n                return thousand_word\n        \n        return convert(num)\n", "k-inverse-pairs-array": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u5148\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u7684\u4e2a\u6570\uff0c\u7136\u540e\u518d\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u4e0e\u5176\u4ed6\u6570\u5b57\u7684\u5173\u7cfb\uff0c\u7136\u540e\u518d\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u4e0e\u5176\u4ed6\u6570\u5b57\u7684\u5173\u7cfb\u4e0e\u5176\u4ed6\u6570\u5b57\u7684\u5173\u7cfb\u7684\u5173\u7cfb\uff0c\u6700\u540e\u518d\u6c42\u51fa\u7ed3\u679c\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u65b9\u6cd5\u4e00\uff1a\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u7684\u4e2a\u6570\n        # \u65b9\u6cd5\u4e8c\uff1a\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u4e0e\u5176\u4ed6\u6570\u5b57\u7684\u5173\u7cfb\n        # \u65b9\u6cd5\u4e09\uff1a\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u4e0e\u5176\u4ed6\u6570\u5b57\u7684\u5173\u7cfb\u4e0e\u5176\u4ed6\u6570\u5b57\u7684\u5173\u7cfb\n        # \u65b9\u6cd5\u56db\uff1a\u6c42\u51fa\u7ed3\u679c\n        \n        # \u65b9\u6cd5\u4e00\uff1a\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u7684\u4e2a\u6570\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u65b9\u6cd5\u4e8c\uff1a\u6c42\u51fa\u6bcf\u4e2a\u6570\u5b57\u4e0e\u5176\u4ed6\u6570\u5b57\u7684\u5173\u7cfb\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\ufffd", "swap-nodes-in-pairs": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            \n            first = curr.next\n            second = curr.next.next\n            \n            first.next = second.next\n            second.next = first\n            curr.next = second\n            \n            curr = first\n            \n        return dummy.next\n", "path-sum": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, targetSum):\n            if not node:\n                return False\n            \n            if not node.left and not node.right and node.val == targetSum:\n                return True\n            \n            return helper(node.left, targetSum - node.val) or helper(node.right, targetSum - node.val)\n        \n        return helper(root, targetSum)\n", "partition-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # Definition for singly-linked list.\n        # class ListNode(object):\n        #     def __init__(self, val=0, next=None):\n        #         self.val = val\n        #         self.next = next\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #", "redundant-connection-ii": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\n        queue = collections.deque()\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u7236\u8282\u70b9\n        parent = collections.defaultdict(int)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u5b50\u8282\u70b9\n        child = collections.defaultdict(list)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u5165\u5ea6\n        in_degree = collections.defaultdict(int)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u51fa\u5ea6\n        out_degree = collections.defaultdict(int)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u7236\u8282\u70b9\n        ancestor = collections.defaultdict(int)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u5b50\u8282\u70b9\n        descendant = collections.defaultdict(list)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u5165\u5ea6\n        in_degree[1] = 0\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282\u70b9\u7684\u51fa\u5ea6\n        out_degree[1] = 0\n        \n        # \u521b\u5efa\u4e00\u4e2a\u961f\u5217\uff0c\u7528\u4e8e\u5b58\u50a8\u8282", "permutations-ii": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        res = []\n        nums.sort()\n        backtrack(nums, [], res)\n        return res\n", "add-digits": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.3 MB\n        if num == 0:\n            return 0\n        \n        while num >= 10:\n            num = sum(int(digit) for digit in str(num))\n        \n        return num\n", "single-number": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\uff0c\u6bcf\u6b21\u904d\u5386\u4e00\u6b21\uff0c\u5224\u65ad\u662f\u5426\u5b58\u5728\uff0c\u5982\u679c\u5b58\u5728\u5219\u5220\u9664\uff0c\u5426\u5219\u521b\u5efa\n        dic = {}\n        for num in nums:\n            if num in dic:\n                dic.pop(num)\n            else:\n                dic[num] = 1\n        return list(dic.keys())[0]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "length-of-last-word": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.6 MB\n        \n        # Split the string into a list of words\n        s_list = s.split()\n        \n        # Return the length of the last word\n        return len(s_list[-1])\n", "cherry-pickup": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u601d\u8def\uff1a\n        # \u4ece\u5de6\u4e0a\u89d2\u5f00\u59cb\uff0c\u6bcf\u6b21\u53ea\u80fd\u5411\u4e0b\u6216\u8005\u5411\u53f3\u79fb\u52a8\uff0c\u5982\u679c\u79fb\u52a8\u5230\u4e86\u7b2c\u4e00\u884c\u6216\u8005\u7b2c\u4e00\u5217\uff0c\u5219\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u6216\u8005\u53f3\u4e00\u5217\u3002\n        # \u5982\u679c\u79fb\u52a8\u5230\u4e86\u7b2c\u4e00\u884c\u6216\u8005\u7b2c\u4e00\u5217\uff0c\u5219\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u6216\u8005\u53f3\u4e00\u5217\u3002\n        # \u5982\u679c\u79fb\u52a8\u5230\u4e86\u7b2c\u4e00\u884c\u6216\u8005\u7b2c\u4e00\u5217\uff0c\u5219\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u6216\u8005\u53f3\u4e00\u5217\u3002\n        # \u5982\u679c\u79fb\u52a8\u5230\u4e86\u7b2c\u4e00\u884c\u6216\u8005\u7b2c\u4e00\u5217\uff0c\u5219\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u6216\u8005\u53f3\u4e00\u5217\u3002\n        # \u5982\u679c\u79fb\u52a8\u5230\u4e86\u7b2c\u4e00\u884c\u6216\u8005\u7b2c\u4e00\u5217\uff0c\u5219\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u6216\u8005\u53f3\u4e00\u5217\u3002\n        # \u5982\u679c\u79fb\u52a8\u5230\u4e86\u7b2c\u4e00\u884c\u6216\u8005\u7b2c\u4e00\u5217\uff0c\u5219\u79fb\u52a8\u5230\u4e0b\u4e00\u884c\u6216\u8005\u53f3\u4e00\u5217\u3002\n        # \u5982\u679c\u79fb\u52a8\u5230\u4e86\u7b2c\u4e00\u884c\u6216\u8005\u7b2c\u4e00\u5217\uff0c\u5219\u79fb\u52a8\ufffd", "student-attendance-record-ii": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        \n        # DP\n        # dp[i][j] = number of records of length i that have j absences\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j] + dp[i-1][j] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j] + dp[i-1][j] + dp[i-1][j] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j] + dp[i-1][j] + dp[i-1][j] + dp[i-1][j] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j] + dp[i-1][", "happy-number": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 24 ms\n        # Memory: 13.9 MB\n        \n        seen = set()\n        while n!= 1:\n            n = sum(int(digit) ** 2 for digit in str(n))\n            if n in seen:\n                return False\n            seen.add(n)\n        return True\n        ", "search-insert-position": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.9 MB\n        \n        # Binary search\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return left\n", "jump-game": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # \u521d\u59cb\u5316\u4e00\u4e2a\u6570\u7ec4\uff0c\u8bb0\u5f55\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\n        # \u521d\u59cb\u5316\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\u4e3a\u81ea\u8eab\u7684\u8ddd\u79bb\n        # \u5c06\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\u52a0\u4e0a\u81ea\u8eab\u7684\u8ddd\u79bb\n        # \u5982\u679c\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\uff0c\u5219\u8fd4\u56defalse\n        # \u5426\u5219\uff0c\u8fd4\u56detrue\n        \n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        # \u4f18\u5316\uff1a\n        # \u53ef\u4ee5\u5224\u65ad\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\u662f\u5426\u5c0f\u4e8e\u7b49\u4e8e\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\n        # \u5982\u679c\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\uff0c\u5219\u8fd4\u56defalse\n        # \u5426\u5219\uff0c\u8fd4\u56detrue\n        \n        if len(nums) == 1:\n            return True\n        \n        max_reach = nums[0]\n        for i in range(1, len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_", "minimum-path-sum": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i][j]\u8868\u793a\u4ece\u7b2ci\u884c\u7b2cj\u5217\u5f00\u59cb\u7684\u6700\u77ed\u8def\u5f84\u7684\u548c\n        # dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        # \u5982\u679ci==0\u6216j==0\uff0c\u5219dp[i][j] = grid[i][j]\n        # \u5982\u679ci==m-1\u6216j==n-1\uff0c\u5219dp[i][j] = grid[i][j]\n        # \u5982\u679ci>0\u6216j>0\uff0c\u5219dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n        \n        m, n = len(grid), len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            dp[i][0] = grid[i][0]\n        for j in range(n):\n            dp[0][j] = grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])\n                \n        return dp[-1][-1]\n", "count-and-say": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        s = self.countAndSay(n-1)\n        \n        res = \"\"\n        count = 1\n        \n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n            else:\n                res += str(count) + s[i-1]\n                count = 1\n        \n        res += str(count) + s[-1]\n        \n        return res\n", "split-array-largest-sum": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u89e3\u6cd5\uff0c\u6bcf\u6b21\u5206\u5272\u4e24\u4e2a\u5b50\u6570\u7ec4\uff0c\u8ba1\u7b97\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c\uff0c\u6bcf\u6b21\u9009\u62e9\u6700\u5c0f\u7684\u5b50\u6570\u7ec4\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        # \u5206\u6cbb\u6cd5\uff0c\u9012\u5f52\u5206\u5272\u5b50\u6570\u7ec4\uff0c\u8ba1\u7b97\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c\uff0c\u9009\u62e9\u6700\u5c0f\u7684\u5b50\u6570\u7ec4\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        \n        # \u5206\u6cbb\u6cd5\uff0c\u9012\u5f52\u5206\u5272\u5b50\u6570\u7ec4\uff0c\u8ba1\u7b97\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c\uff0c\u9009\u62e9\u6700\u5c0f\u7684\u5b50\u6570\u7ec4\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        \n        # \u5206\u6cbb\u6cd5\uff0c\u9012\u5f52\u5206\u5272\u5b50\u6570\u7ec4\uff0c\u8ba1\u7b97\u5b50\u6570\u7ec4\u7684\u6700\u5927\u548c\uff0c\u9009\u62e9\u6700\u5c0f\u7684\u5b50\u6570\u7ec4\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\n        \n        # \u5206\u6cbb\u6cd5\uff0c\u9012\u5f52\u5206\u5272\u5b50\u6570\u7ec4\uff0c\u8ba1\u7b97\u5b50\ufffd", "search-in-rotated-sorted-array": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 24 ms, faster than 98.79% of Python3 online submissions for Search in Rotated Sorted Array.\n        # Memory Usage: 13.9 MB, less than 100.00% of Python3 online submissions for Search in Rotated Sorted Array.\n        \n        if len(nums) == 0:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1", "letter-combinations-of-a-phone-number": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        self.digit_to_letters = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"pqrs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\"\n        }\n        \n        self.result = []\n        \n        self.dfs(digits, \"\", 0)\n        \n        return self.result\n    \n    def dfs(self, digits, current, index):\n        if index == len(digits):\n            self.result.append(current)\n            return\n        \n        for letter in self.digit_to_letters[digits[index]]:\n            self.dfs(digits, current + letter, index + 1)\n        \n        return\n", "combination-sum": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, index, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        \n        for i in range(index, len(candidates)):\n            if target < candidates[i]:\n                break\n            \n            self.dfs(candidates, target-candidates[i], i, path+[candidates[i]], res)\n", "find-the-closest-palindrome": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # \u6839\u636e\u5b57\u7b26\u4e32\u957f\u5ea6\u5224\u65ad\n        if len(n) == 1:\n            return '0'\n        \n        # \u6839\u636e\u5b57\u7b26\u4e32\u957f\u5ea6\u5224\u65ad\n        if len(n) == 2:\n            if n[0] == '1':\n                return '11'\n            elif n[0] == '0':\n                return '00'\n            else:\n                return '10'\n        \n        # \u6839\u636e\u5b57\u7b26\u4e32\u957f\u5ea6\u5224\u65ad\n        if n[0] == '1':\n            return '11' + self.nearestPalindromic(n[1:])\n        elif n[0] == '0':\n            return '00' + self.nearestPalindromic(n[1:])\n        else:\n            return '10' + self.nearestPalindromic(n[1:])\n", "spiral-matrix-ii": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        matrix = [[0] * n for _ in range(n)]\n        \n        x, y, dx, dy = 0, 0, 0, 1\n        \n        for i in range(1, n*n+1):\n            matrix[x][y] = i\n            \n            if x+dx < 0 or x+dx == n or y+dy < 0 or y+dy == n or matrix[x+dx][y+dy]!= 0:\n                dx, dy = dy, -dx\n            \n            x, y = x+dx, y+dy\n        \n        return matrix\n", "reverse-integer": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            return -self.reverse(-x)\n        \n        res = 0\n        while x > 0:\n            res = res * 10 + x % 10\n            x = x // 10\n            \n        if res > 2**31 - 1 or res < -2**31:\n            return 0\n        else:\n            return res\n", "rotate-image": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # \u6df1\u5ea6\u4f18\u5148\u641c\u7d22\n        # \u6bcf\u6b21\u5f80\u53f3\u79fb\u52a8\u4e00\u4e2a\u8282\u70b9\uff0c\u6bcf\u6b21\u5f80\u4e0a\u79fb\u52a8\u4e00\u4e2a\u8282\u70b9\n        # \u5982\u679c\u6ca1\u6709\u8fb9\u754c\uff0c\u5219\u76f4\u63a5\u79fb\u52a8\u5230\u53f3\u4e0b\u89d2\n        \n        if not matrix or not matrix[0]:\n            return\n        \n        n = len(matrix)\n        \n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                \n                temp = matrix[i][j]\n                \n                # \u53f3\u8fb9\u79fb\u52a8\n                matrix[i][j] = matrix[n-j-1][i]\n                \n                # \u4e0a\u8fb9\u79fb\u52a8\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                \n                # \u5de6\u8fb9\u79fb\u52a8\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                \n                # \u4e0b\u8fb9\u79fb\u52a8\n                matrix[j][n-i-1] = temp\n                \n        return matrix\n", "maximum-product-subarray": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u521d\u59cb\u5316dp\n        dp = [1] * len(nums)\n        # \u521d\u59cb\u5316\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(nums[i] * dp[i - 1], nums[i - 1] * dp[i - 2], nums[i - 2] * dp[i - 3])\n        \n        return dp[-1]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "frog-jump": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i] \u8868\u793a\u4ece\u7b2c i \u4e2a\u70b9\u5230\u6700\u540e\u4e00\u4e2a\u70b9\u7684\u6700\u5c0f\u8ddd\u79bb\n        # dp[i] = min(dp[i], dp[j] + 1)\n        # \u5982\u679c dp[i] == float('inf')\uff0c\u5219\u4e0d\u53ef\u80fd\u8df3\u5230\u6700\u540e\u4e00\u4e2a\u70b9\n        # \u5982\u679c dp[i] == 0\uff0c\u5219\u53ef\u4ee5\u8df3\u5230\u6700\u540e\u4e00\u4e2a\u70b9\n        \n        # \u521d\u59cb\u5316\n        dp = [float('inf')] * len(stones)\n        dp[0] = 0\n        \n        # \u6784\u5efa dp\n        for i in range(len(stones)):\n            for j in range(i):\n                if stones[i] - stones[j] <= 2:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[-1] == 0\n", "relative-ranks": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u8ba1\u6570\uff0c\u7136\u540e\u6392\u5e8f\n        score.sort(reverse=True)\n        count = collections.Counter(score)\n        rank = []\n        for i in range(len(score)):\n            if i == 0:\n                rank.append(\"Gold Medal\")\n            elif i == 1:\n                rank.append(\"Silver Medal\")\n            elif i == 2:\n                rank.append(\"Bronze Medal\")\n            else:\n                rank.append(str(i+1))\n        for i in range(3, len(score)):\n            if count[score[i]] == 1:\n                rank.append(str(i+1))\n            else:\n                rank.append(str(count[score[i]]))\n        return rank\n", "longest-substring-without-repeating-characters": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u5148\u6784\u9020\u4e00\u4e2a\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u5f53\u524d\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\n        # \u7136\u540e\u4ece\u5de6\u5f80\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e32\u4e2d\u5b58\u5728\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u5c06\u5f53\u524d\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u51cf\u53bb\u91cd\u590d\u5b57\u7b26\u7684\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\n        # \u5982\u679c\u5f53\u524d\u5b57\u7b26\u4e32\u4e2d\u5b58\u5728\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u5c06\u5f53\u524d\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u51cf\u53bb\u91cd\u590d\u5b57\u7b26\u7684\u7b2c\u4e8c\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\n        # \u6700\u540e\u8fd4\u56de\u6570\u7ec4\u4e2d\u6700\u5927\u503c\n        \n        if len(s) == 0:\n            return 0\n        \n        length = [0] * len(s)\n        max_length = 0\n        \n        for i in range(len(s)):\n            if length[i] == 0:\n                length[i] = 1\n                max_length = 1\n            else:\n                length[i] += 1\n                \n            for j in range(i):\n                if s[j] == s[i]:\n                    length[i] -= 1\n                    break\n                    \n            max_length = max(max_length, length[i])\n            \n        return max_length\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "substring-with-concatenation-of-all-words": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\n        words_len = len(words)\n        word_len = len(words[0])\n        word_set = set(words)\n        \n        # \u521d\u59cb\u5316\u7ed3\u679c\n        result = []\n        \n        # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n        result_dict = {}\n        \n        # \u521d\u59cb\u5316\u5b57\u5178\n        for word in word_set:\n            result_dict[word] = 0\n        \n        # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n        for i in range(word_len):\n            result_dict[s[i]] = 0\n        \n        # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n        for i in range(word_len):\n            result_dict[s[i]] += 1\n        \n        # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n        for i in range(word_len, len(s)):\n            # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n            result_dict[s[i]] = 0\n            \n            # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n            for j in range(word_len):\n                # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n                result_dict[s[i - j]] -= 1\n                \n                # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n                if result_dict[s[i - j]] == 0:\n                    del result_dict[s[i - j]]\n                \n                # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n                result_dict[s[i]] += 1\n                \n                # \u521d\u59cb\u5316\u7ed3\u679c\u5b57\u5178\n                if result_dict[s[i]] == words_len:\n                    result.append(i - word_len + 1)\n                    \n        return result\n", "max-chunks-to-make-sorted-ii": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u679a\u4e3e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        # \u601d\u8def\uff1a\u66b4\u529b\u679a\u4e3e\uff0c\u6bcf\u6b21\u5c06\u6570\u7ec4\u5206\u6210\u4e24\u4e2a\u5b50\u6570\u7ec4\uff0c\u5224\u65ad\u5b50\u6570\u7ec4\u662f\u5426\u5df2\u7ecf\u6392\u5e8f\uff0c\u5982\u679c\u4e0d\u5df2\u7ecf\u6392\u5e8f\uff0c\u5219\u5c06\u5b50\u6570\u7ec4\u6392\u5e8f\uff0c\u7136\u540e\u518d\u6b21\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6392\u5e8f\uff0c\u76f4\u5230\u6570\u7ec4\u5df2\u7ecf\u6392\u5e8f\u5b8c\u6210\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u5206\u6cbb\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u7a33\u5b9a\n        # \u601d\u8def\uff1a\u5206\u6cbb\u6cd5\uff0c\u5c06\u6570\u7ec4\u5206\u6210\u4e24\u4e2a\u5b50\u6570\u7ec4\uff0c\u5224\u65ad\u5b50\u6570\u7ec4\u662f\u5426\u5df2\u7ecf\u6392\u5e8f\uff0c\u5982\u679c\u4e0d\u5df2\u7ecf\u6392\u5e8f\uff0c\u5219\u5c06\u5b50\u6570\u7ec4\u6392\u5e8f\uff0c\u7136\u540e\u518d\u6b21\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6392\u5e8f\uff0c\u76f4\u5230\u6570\u7ec4\u5df2\u7ecf\u6392\u5e8f\u5b8c\u6210", "insertion-sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # \u5148\u5224\u65ad\u662f\u5426\u4e3a\u7a7a\n        if not head:\n            return None\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u662f\u5426\u4e3a\u7b2c\u4e00\u4e2a\u8282\u70b9\n        if head.next == None:\n            return head\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u503c\n        cur = head.next\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u503c\u662f\u5426\u5927\u4e8e\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u503c\n        while cur.next!= None:\n            if cur.val > head.val:\n                break\n            cur = cur.next\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u503c\u662f\u5426\u5927\u4e8e\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u503c\n        if cur.val > head.val:\n            cur.next = head\n            head = cur\n            return head\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u503c\u662f\u5426\u5927\u4e8e\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u503c\n        while cur.next!= None:\n            if cur.val > head.val:\n                break\n            cur = cur.next\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u503c\u662f\u5426\u5927\u4e8e\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u503c\n        if cur.val > head.val:\n            cur.next = head\n            head = cur\n            return head\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u503c\u662f\u5426\u5927\u4e8e\u524d\u4e00\u4e2a\u8282\u70b9\u7684\u503c\n        while cur.next!= None:\n            if cur.val > head.val:\n                break\n            cur = cur.next\n        \n        # \u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u503c\u662f\u5426\u5927\u4e8e\u524d\u4e00\u4e2a", "remove-duplicates-from-sorted-list-ii": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.4 MB\n        \n        # if not head:\n        #     return head\n        \n        # curr = head\n        # while curr:\n        #     while curr.next and curr.next.val == curr.val:\n        #         curr.next = curr.next.next\n        #     curr = curr.next\n        # return head\n        \n        # Runtime: 32 ms\n        # Memory: 13.4 MB\n        \n        # if not head:\n        #     return head\n        \n        # curr = head\n        # prev = head\n        # while curr:\n        #     while curr.next and curr.next.val == curr.val:\n        #         curr.next = curr.next.next\n        #     prev.next = curr\n        #     prev = curr\n        #     curr = curr.next\n        # return head\n        \n        # Runtime: 32 ms\n        # Memory: 13.4 MB\n        \n        # if not head:\n        #     return head\n        \n        # curr = head\n        # prev = head\n        # while curr:\n        #     while curr.next and curr.next.val == curr.val:\n        #         curr.next = curr.next.next\n        #     prev.next = curr\n        #     prev = curr\n        #     curr = curr.next\n        # return head\n        \n        # Runtime: 32 ms\n        # Memory: 13.4 MB\n        \n        # if not head:\n        #     return head\n        \n        # curr = head\n        # prev = head\n        # while curr:\n        #     while curr.next and curr.next.val == curr.val:\n        #         curr.next = curr.next.next\n        #     prev.next = curr\n        #     prev = curr\n        #     curr = curr.next\n        # return head\n        \n        # Runtime: 32 ms\n        # Memory: 13.4 MB\n        \n        # if not head:\n        #     return head\n        ", "3sum": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        \n        result = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            left, right = i+1, len(nums)-1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total < 0:\n                    left += 1\n                elif total > 0:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n        \n        return result\n", "edit-distance": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u6a21\u62df O(n^2)\n        # \u6bcf\u6b21\u904d\u5386\u4e00\u4e2a\u5b57\u7b26\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\u503c\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5927\u503c\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u503c\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u503c\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u503c\n        # \u6bcf\u6b21\u904d\u5386\u4e00\u4e2a\u5b57\u7b26\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u503c\n        # \u6bcf\u6b21\u904d\u5386\u4e00\u4e2a\u5b57\u7b26\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u503c\n        # \u6bcf\u6b21\u904d\u5386\u4e00\u4e2a\u5b57\u7b26\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u503c\n        # \u6bcf\u6b21\u904d\u5386\u4e00\u4e2a\u5b57\u7b26\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u4e4b\u95f4\u7684\u6700\u5927\u5dee\u503c\n        # \u6bcf\u6b21\u904d\u5386\u4e00\u4e2a\u5b57\u7b26\uff0c\u8bb0\u5f55\u524d\u4e00\u4e2a\u5b57\u7b26\u7684\u6700\u5c0f\ufffd", "hamming-distance": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 28 ms\n        # Memory: 13.9 MB\n        \n        # xor the two numbers\n        xor = x ^ y\n        \n        # count the number of set bits in the xor\n        count = 0\n        while xor:\n            count += xor & 1\n            xor >>= 1\n        \n        return count\n", "binary-tree-paths": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u56de\u6eaf\n        if not root:\n            return []\n        \n        self.result = []\n        self.dfs(root, [])\n        return self.result\n    \n    def dfs(self, root, path):\n        if not root.left and not root.right:\n            self.result.append(\"->\".join(map(str, path + [root.val])))\n        if root.left:\n            self.dfs(root.left, path + [root.val])\n        if root.right:\n            self.dfs(root.right, path + [root.val])\n", "reverse-pairs": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u6392\u5e8f\n        nums.sort()\n        \n        # \u5206\u6cbb\u6cd5\n        def count(nums):\n            if len(nums) == 1:\n                return 0\n            else:\n                mid = len(nums) // 2\n                left = nums[:mid]\n                right = nums[mid:]\n                \n                return count(left) + count(right) + self.merge(left, right)\n        \n        def merge(left, right):\n            i = j = 0\n            res = 0\n            while i < len(left) and j < len(right):\n                if left[i] > right[j]:\n                    res += len(left) - i\n                    j += 1\n                else:\n                    i += 1\n            return res\n        \n        return count(nums)\n", "reaching-points": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        # \u66b4\u529b\u679a\u4e3e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(2^n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4f18\u5316\uff1a\n        # \u53ef\u4ee5\u628a\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u8f6c\u6362\u4e3a\u4e00\u4e2a\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\uff0c\u6bcf\u4e00\u6b65\u90fd\u662f\u4e00\u4e2a\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\uff0c\n        # \u7136\u540e\u53ef\u4ee5\u7528\u52a8\u6001\u89c4\u5212\u89e3\u51b3\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n", "compare-version-numbers": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i >= len(v1):\n                v1.append(0)\n            if i >= len(v2):\n                v2.append(0)\n                \n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        \n        return 0\n", "best-time-to-buy-and-sell-stock-ii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\u6cd5\n        # \u53cc\u6307\u9488\u6cd5\uff0c\u4ece\u5de6\u5230\u53f3\uff0c\u6bcf\u6b21\u90fd\u8bb0\u5f55\u6700\u5c0f\u503c\uff0c\u7136\u540e\u8bb0\u5f55\u6700\u5927\u503c\uff0c\u6700\u5927\u503c-\u6700\u5c0f\u503c\u5373\u4e3a\u6700\u5927\u5229\u6da6\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        \n        return max_profit\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "course-schedule-iii": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # \u5206\u6790\n        # \u6bcf\u4e2a\u7b2ci\u4e2a\u8d77\u59cb\u65f6\u95f4\uff0c\u6700\u540e\u4e00\u4e2a\u7ed3\u675f\u65f6\u95f4\n        # \u6bcf\u4e2a\u7b2ci\u4e2a\u8d77\u59cb\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\n        # \u6bcf\u4e2a\u7b2ci\u4e2a\u8d77\u59cb\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\n        # \u6bcf\u4e2a\u7b2ci\u4e2a\u8d77\u59cb\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\n        #...\n        # \u6bcf\u4e2a\u7b2ci\u4e2a\u8d77\u59cb\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\n        #...\n        # \u6bcf\u4e2a\u7b2ci\u4e2a\u8d77\u59cb\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\n        #...\n        # \u6bcf\u4e2a\u7b2ci\u4e2a\u8d77\u59cb\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4\u7684\u6700\u5927\u7ed3\u675f\u65f6\u95f4", "reverse-nodes-in-k-group": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        cur = dummy\n        \n        while cur.next and k > 1:\n            prev = cur\n            cur = cur.next\n            \n            for _ in range(k-1):\n                next = cur.next\n                cur.next = prev\n                prev = cur\n                cur = next\n            \n            if cur.next:\n                dummy.next = cur\n                dummy = cur\n            else:\n                dummy.next = prev\n                return head\n        \n        return dummy.next\n", "repeated-substring-pattern": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return False\n        \n        if len(s) == 1:\n            return True\n        \n        if len(s) == 2:\n            return s[0] == s[1]\n        \n        for i in range(1, len(s)):\n            if len(s) % i == 0:\n                sub = s[:i]\n                if sub * (len(s) // i) == s:\n                    return True\n        \n        return False\n", "unique-binary-search-trees": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # dp[i] = sum(dp[j] * dp[n-j-1] for j in range(i))\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = 2\n        # dp[3] = 5\n        # dp[4] = 14\n        # dp[5] = 42\n        # dp[6] = 132\n        # dp[7] = 429\n        # dp[8] = 1430\n        # dp[9] = 4862\n        # dp[10] = 16796\n        # dp[11] = 58786\n        # dp[12] = 254016\n        # dp[13] = 716156\n        # dp[14] = 441006\n        # dp[15] = 1398776\n        # dp[16] = 665280\n        # dp[17] = 2799696\n        # dp[18] = 12098276\n        # dp[19] = 5242880\n        \n        # dp = [1] * 20\n        # for i in range(1, 20):\n        #     for j in range(i):\n        #         dp[i] += dp[j] * dp[i-j-1]\n        \n        # return dp[n]\n        \n        # Recursion\n        # dp[i] = sum(dp[j] * dp[n-j-1] for j in range(i))\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = 2\n        # dp[3] = 5\n        # dp[4] = 14\n        # dp[5] = 42\n        # dp[6] = 132\n        # dp[7] = 429\n        # dp[8] = 1430\n        # dp[9] = 4862\n        # dp[10] = 16796\n        # dp[11] = 58786\n        # dp[12] = 254016\n        # dp[13", "single-number-ii": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4f18\u5316\uff1a\u53cc\u6307\u9488\n        # \u4f7f\u7528\u53cc\u6307\u9488\uff0c\u6bcf\u6b21\u53ea\u9700\u8981\u79fb\u52a8\u4e00\u6b21\n        # \u53cc\u6307\u9488\u7684\u79fb\u52a8\u65b9\u6cd5\u662f\uff1a\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\u6b21\u79fb\u52a8\u4e00\u6b21\uff0c\u66f4\u65b0\u4e24\u4e2a\u6307\u9488\u7684\u4f4d\u7f6e\n        # \u4e00\ufffd", "stickers-to-spell-word": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\n        # \u6bcf\u4e2a\u5b57\u7b26\u7684\u51fa\u73b0\u6b21\u6570\n        count = {}\n        for c in target:\n            count[c] = count.get(c, 0) + 1\n        \n        # \u6bcf\u4e2a\u5b57\u7b26\u7684\u5b57\u5178\n        # \u5b57\u5178\u7684key\u4e3a\u5b57\u7b26\uff0cvalue\u4e3a\u5b57\u5178\u7684\u5b57\u5178\n        # \u5b57\u5178\u7684\u5b57\u5178\u7684key\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u7b26\uff0cvalue\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\n        # \u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684key\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u7b26\uff0cvalue\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\n        # \u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684key\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u7b26\uff0cvalue\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\n        # \u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684key\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\uff0cvalue\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\n        # \u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684key\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\uff0cvalue\u4e3a\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\u7684\u5b57\u5178\n        # \u5b57\u5178\u7684\ufffd", "strange-printer": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u6c42\u89e3\n        # \u5148\u627e\u51fa\u6240\u6709\u7684\u6700\u957f\u7684\u5b50\u4e32\uff0c\u7136\u540e\u518d\u627e\u51fa\u6240\u6709\u7684\u5b50\u4e32\u7684\u6700\u957f\u5b50\u4e32\n        # \u627e\u51fa\u6240\u6709\u7684\u6700\u957f\u5b50\u4e32\u7684\u6700\u5927\u957f\u5ea6\n        # \u627e\u51fa\u6240\u6709\u7684\u5b50\u4e32\u7684\u6700\u957f\u5b50\u4e32\u7684\u6700\u5927\u957f\u5ea6\n        # \u6700\u540e\u8fd4\u56de\u6700\u5927\u957f\u5ea6\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u66b4\u529b\u6c42\u89e3\n        # \u5148\u627e\u51fa\u6240\u6709\u7684\u6700\u957f\u7684\u5b50\u4e32\uff0c\u7136\u540e\u518d\u627e\u51fa\u6240\u6709\u7684\u5b50\u4e32\u7684\u6700\u957f\u5b50\u4e32\n        # \u627e\u51fa\u6240\u6709\u7684\u6700\u957f\u5b50\u4e32\u7684\u6700\u5927\u957f\u5ea6\n        # \u627e\u51fa\u6240\u6709\u7684\u5b50\u4e32\u7684\u6700\u957f\u5b50\u4e32\u7684\u6700\u5927\u957f\u5ea6\n        # \u6700\u540e\u8fd4\u56de\u6700\u5927\u957f\u5ea6\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        # \u66b4\u529b\u6c42\u89e3\n        # \u5148\u627e\u51fa\u6240\u6709\u7684\u6700\u957f\u7684\u5b50\u4e32\uff0c\u7136\u540e\u518d\u627e\u51fa\u6240\u6709\u7684\u5b50\u4e32\u7684\u6700\u957f\u5b50\u4e32\n        # \u627e\u51fa\u6240\u6709\u7684\u6700\u957f\u5b50\u4e32\u7684\u6700\u5927\u957f\u5ea6\n        # \u627e\u51fa\u6240\u6709\u7684\u5b50\u4e32\u7684\u6700\ufffd", "sqrtx": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif x < mid * mid:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n", "roman-to-integer": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        \n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i - 1]]:\n                result += roman_dict[s[i]] - 2 * roman_dict[s[i - 1]]\n            else:\n                result += roman_dict[s[i]]\n        \n        return result\n", "contains-duplicate": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        return len(nums)!= len(set(nums))\n        \n        # Runtime: 32 ms\n        ", "sliding-window-maximum": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        # \u5148\u627e\u5230\u7b2c\u4e00\u4e2a\u6700\u5927\u503c\uff0c\u7136\u540e\u79fb\u52a8\u4e00\u4f4d\uff0c\u6bcf\u6b21\u79fb\u52a8\u4e00\u4f4d\uff0c\u66f4\u65b0\u6700\u5927\u503c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        if not nums or k == 0:\n            return []\n        \n        res = []\n        \n        left = 0\n        right = k - 1\n        \n        while right < len(nums):\n            if nums[right] > nums[left]:\n                res.append(nums[right])\n            \n            while right < len(nums) and nums[right] <= nums[left]:\n                right += 1\n            \n            left += 1\n            right -= 1\n        \n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "median-of-two-sorted-arrays": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2\n        else:\n            return nums1[len(nums1) // 2]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "find-minimum-in-rotated-sorted-array": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Limit Exceeded\n        # def findMin(self, nums):\n        #     if not nums:\n        #         return None\n        #     if len(nums) == 1:\n        #         return nums[0]\n        #     if len(nums) == 2:\n        #         return min(nums)\n        #     if len(nums) == 3:\n        #         return min(nums)\n        #     if len(nums) == 4:\n        #         return min(nums[0], nums[1], nums[3])\n        #     if len(nums) == 5:\n        #         return min(nums[0], nums[1], nums[3], nums[4])\n        #     if len(nums) == 6:\n        #         return min(nums[0], nums[1], nums[3], nums[4], nums[5])\n        #     if len(nums) == 7:\n        #         return min(nums[0], nums[1], nums[3], nums[4], nums[5], nums[6])\n        #     if len(nums) == 8:\n        #         return min(nums[0], nums[1], nums[3], nums[4], nums[5], nums[6], nums[7])\n        #     if len(nums) == 9:\n        #         return min(nums[0], nums[1], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8])\n        #     if len(nums) == 10:\n        #         return min(nums[0], nums[1], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9])\n        #     if len(nums) == 11:\n        #         return min(nums[0], nums[1], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8", "pascals-triangle-ii": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        row = [1]\n        for i in range(rowIndex):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row\n", "path-sum-ii": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        result = []\n        \n        def dfs(root, path, target):\n            if root.left is None and root.right is None:\n                if root.val == target:\n                    result.append(path + [root.val])\n            \n            if root.left is not None:\n                dfs(root.left, path + [root.val], target - root.val)\n            \n            if root.right is not None:\n                dfs(root.right, path + [root.val], target - root.val)\n        \n        dfs(root, [], targetSum)\n        \n        return result\n", "construct-the-rectangle": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # \u627e\u5230\u6700\u5927\u7684\u56e0\u6570\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u80fd\u88ab\u6574\u9664\n        # \u6ce8\u610f\uff1a\u6700\u5927\u56e0\u6570\u4e0d\u80fd\u8d85\u8fc7sqrt(area)\n        \n        # \u627e\u5230\u6700\u5927\u56e0\u6570\n        max_num = int(math.sqrt(area))\n        \n        # \u5224\u65ad\u662f\u5426\u80fd\u88ab\u6574\u9664\n        for i in range(max_num, 0, -1):\n            if area % i == 0:\n                return [area//i, i]\n        \n        return [1, area]\n", "word-ladder-ii": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # \u6784\u9020\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u53ef\u80fd\u7684\u7ed3\u679c\uff0ckey\u4e3a\u7ed3\u679c\uff0cvalue\u4e3a\u7ed3\u679c\u7684\u8def\u5f84\n        result = {}\n        \n        # \u5c06beginWord\u548cendWord\u52a0\u5165\u5b57\u5178\u4e2d\n        result[beginWord] = [[beginWord]]\n        result[endWord] = [[endWord]]\n        \n        # \u5c06wordList\u4e2d\u7684\u6240\u6709\u5143\u7d20\u52a0\u5165\u5b57\u5178\u4e2d\n        for word in wordList:\n            result[word] = [[word]]\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u8def\u5f84\u7684\u957f\u5ea6\n        length = {}\n        for word in wordList:\n            length[word] = 1\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u8def\u5f84\u7684\u957f\u5ea6\n        length[beginWord] = 0\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u8def\u5f84\u7684\u957f\u5ea6\n        length[endWord] = 0\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u8def\u5f84\u7684\u957f\u5ea6\n        length[beginWord] = 0\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u8def\u5f84\u7684\u957f\u5ea6\n        length[endWord] = 0\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u8def\u5f84\u7684\u957f\u5ea6\n        length[endWord] = 0\n        \n        # \u521d\u59cb\u5316\u4e00\u4e2a\u5b57\u5178\uff0c\u5b58\u50a8\u6240\u6709\u8def", "balanced-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def check(node):\n            if not node:\n                return 0\n            \n            left = check(node.left)\n            right = check(node.right)\n            \n            if abs(left - right) > 1:\n                return -1\n            \n            return 1 + max(left, right)\n        \n        return check(root) >= 0\n", "power-of-two": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        return n > 0 and (n & (n - 1)) == 0\n", "subsets-ii": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        \n        res = [[]]\n        \n        for num in nums:\n            res += [curr + [num] for curr in res]\n            \n        return res\n", "largest-rectangle-in-histogram": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u6bcf\u4e2a\u4f4d\u7f6e\u7684\u6700\u5927\u9762\u79ef\u4e3aheights[i]*(i+1) - max(heights[:i+1])\n        # \u521d\u59cb\u5316dp[i]\u4e3a0\n        # \u521d\u59cb\u5316dp[0]\u4e3aheights[0]\n        # \u5faa\u73afdp[i] = max(dp[i], dp[i-1] + heights[i])\n        # \u6c42\u6700\u5927\u503c\n        \n        dp = [0] * len(heights)\n        dp[0] = heights[0]\n        for i in range(1, len(heights)):\n            dp[i] = max(dp[i-1] + heights[i], heights[i])\n        return max(dp) * len(heights)\n", "evaluate-reverse-polish-notation": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                elif token == \"/\":\n                    stack.append(a // b)\n            else:\n                stack.append(int(token))\n        return stack[0]\n", "perfect-rectangle": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u91cd\u53e0\n        def isOverlap(rect1, rect2):\n            return not (rect1[0] > rect2[2] or rect1[2] < rect2[0] or rect1[1] > rect2[3] or rect1[3] < rect2[1])\n        \n        # \u627e\u5230\u6700\u5c0f\u7684\u77e9\u5f62\n        def findMinRect(rectangles):\n            min_x = min(rectangles, key=lambda x: x[0])[0]\n            min_y = min(rectangles, key=lambda x: x[1])[1]\n            max_x = max(rectangles, key=lambda x: x[2])[2]\n            max_y = max(rectangles, key=lambda x: x[3])[3]\n            return [min_x, min_y, max_x - min_x, max_y - min_y]\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u91cd\u53e0\n        def isOverlap(rect1, rect2):\n            return not (rect1[0] > rect2[2] or rect1[2] < rect2[0] or rect1[1] > rect2[3] or rect1[3] < rect2[1])\n        \n        # \u627e\u5230\u6700\u5c0f\u7684\u77e9\u5f62\n        def findMinRect(rectangles):\n            min_x = min(rectangles, key=lambda x: x[0])[0]\n            min_y = min(rectangles, key=lambda x: x[1])[1]\n            max_x = max(rectangles, key=lambda x: x[2])[2]\n            max_y = max(rectangles, key=lambda x: x[3])[3]\n            return [min_x, min_y, max_x - min_x, max_y - min_y]\n        \n        # \u5224\u65ad\u662f\u5426\u6709\u91cd\u53e0\n        def isOverlap(rect1, rect2):\n            return not (rect1[0] > rect2[2", "excel-sheet-column-title": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2c\u4e00\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2c\u4e8c\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        #...\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+1\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+2\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        #...\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+k\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+k+1\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        #...\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+k+k+1\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+k+k+k+1\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        #...\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+k+k+k+k+k+1\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        # \u6bcf\u4e2a\u6570\u5b57\u7684\u7b2cn+k+k+k+k+k+k+k+1\u4f4d\u7684\u6570\u5b57\u662f\u6570\u5b57\u7684\u6570\u5b57\u503c-1\n        ", "maximum-subarray": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 48 ms\n        # Memory Usage: 14.2 MB\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n        \n        # Runtime: 48 ms\n        # Memory Usage: 14.2 MB\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n        \n        # Runtime: 48 ms\n        # Memory Usage: 14.2 MB\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n        \n        # Runtime: 48 ms\n        # Memory Usage: 14.2 MB\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n        \n        # Runtime: 48 ms\n        # Memory Usage: 14.2 MB\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n        \n        # Runtime: 48 ms\n        # Memory Usage: 14.2 MB\n        max_sum = float('-inf')\n        curr_sum = 0\n        for num in nums:\n            curr_sum = max(num, curr_sum + num)\n            max_sum = max(max_sum, curr_sum", "sliding-puzzle": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def get_neighbors(board):\n            neighbors = []\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        continue\n                    if i > 0:\n                        neighbors.append([i-1, j, board[i-1][j]])\n                    if i < 1:\n                        neighbors.append([i+1, j, board[i+1][j]])\n                    if j > 0:\n                        neighbors.append([i, j-1, board[i][j-1]])\n                    if j < 2:\n                        neighbors.append([i, j+1, board[i][j+1]])\n            return neighbors\n        \n        def is_solved(board):\n            return board == [[1,2,3],[4,5,0]]\n        \n        def swap(board, i, j):\n            board[i][j], board[j][i] = board[j][i], board[i][j]\n        \n        queue = collections.deque([(board, 0)])\n        visited = set([tuple(map(tuple, board))])\n        \n        while queue:\n            curr_board, curr_moves = queue.popleft()\n            if is_solved(curr_board):\n                return curr_moves\n            for neighbor in get_neighbors(curr_board):\n                if tuple(map(tuple, neighbor[0])) not in visited:\n                    queue.append((neighbor[0], curr_moves+1))\n                    visited.add(tuple(map(tuple, neighbor[0])))\n        return -1\n", "isomorphic-strings": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # \u521b\u5efa\u5b57\u5178\uff0c\u5b58\u50a8\u5b57\u7b26\u4e32s\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32t\u7684\u5bf9\u5e94\u5173\u7cfb\n        # \u5b57\u5178\u7684key\u4e3a\u5b57\u7b26\u4e32s\u7684\u5143\u7d20\uff0cvalue\u4e3a\u5b57\u7b26\u4e32t\u7684\u5143\u7d20\n        mapping = {}\n        \n        # \u5982\u679c\u5b57\u5178\u4e2d\u5b58\u5728key\uff0c\u5219\u68c0\u67e5value\u662f\u5426\u76f8\u7b49\uff0c\u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56deFalse\n        for i in range(len(s)):\n            if s[i] in mapping:\n                if mapping[s[i]]!= t[i]:\n                    return False\n            else:\n                if t[i] in mapping.values():\n                    return False\n                mapping[s[i]] = t[i]\n        \n        return True\n", "search-in-rotated-sorted-array-ii": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "unique-paths-ii": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 0:\n                    if i > 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j > 0:\n                        dp[i][j] += dp[i][j - 1]\n                    \n        return dp[m - 1][n - 1]\n", "decode-ways-ii": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i] \u8868\u793a\u4ee5 s[:i] \u4e3a\u89e3\u7801\u7684\u65b9\u6cd5\u6570\n        # dp[0] = 1\n        # dp[1] = 1 if s[0]!= '0' else 0\n        # dp[i] = dp[i-1] + dp[i-2] if s[i-1]!= '0' and s[i-1] <= '6' else dp[i-1]\n        # dp[i] = dp[i-1] if s[i-1] == '*'\n        # return dp[-1] % (10**9 + 7)\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i] \u8868\u793a\u4ee5 s[:i] \u4e3a\u89e3\u7801\u7684\u65b9\u6cd5\u6570\n        # dp[0] = 1\n        # dp[1] = 1 if s[0]!= '0' else 0\n        # dp[i] = dp[i-1] + dp[i-2] if s[i-1]!= '0' and s[i-1] <= '6' else dp[i-1]\n        # dp[i] = dp[i-1] if s[i-1] == '*'\n        # return dp[-1] % (10**9 + 7)\n        \n        # \u52a8\u6001\u89c4\u5212\n        # dp[i] \u8868\u793a\u4ee5 s[:i] \u4e3a\u89e3\u7801\u7684\u65b9\u6cd5\u6570\n        # dp[0] = 1\n        # dp[1] = 1 if s[0]!= '0' else 0\n        # dp[i] = dp[i-1] + dp[i-2] if s[i-1]!= '0' and s[i-1] <= '6' else dp[i-1]\n        # dp[i] = dp[i-1] if", "3sum-closest": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        \n        closest = float('inf')\n        \n        for i in range(len(nums)-2):\n            \n            left, right = i+1, len(nums)-1\n            \n            while left < right:\n                \n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                    \n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n                    \n        return closest\n", "maximum-depth-of-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        \n        return max(left, right) + 1\n", "intersection-of-two-arrays-ii": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Runtime: 28 ms\n        # Memory: 13.6 MB\n        \n        # Sort both arrays\n        nums1.sort()\n        nums2.sort()\n        \n        # Initialize the result array\n        result = []\n        \n        # Iterate through both arrays\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            # If the current elements in both arrays are equal, append to the result array and increment both indices\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            # If the current element in nums1 is smaller, increment the index of nums1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            # If the current element in nums2 is smaller, increment the index of nums2\n            else:\n                j += 1\n        \n        return result\n", "minimum-absolute-difference-in-bst": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # \u524d\u5e8f\u904d\u5386\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u653e\u5165\u4e00\u4e2a\u6570\u7ec4\uff0c\u7136\u540e\u518d\u6bd4\u8f83\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u7684\u5dee\u503c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        if not root:\n            return 0\n        \n        nums = []\n        self.preOrder(root, nums)\n        \n        min_diff = float('inf')\n        for i in range(1, len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\n        \n        return min_diff\n        \n    def preOrder(self, root, nums):\n        if not root:\n            return\n        \n        self.preOrder(root.left, nums)\n        nums.append(root.val)\n        self.preOrder(root.right, nums)\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "find-mode-in-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u6839\u636e\u5c42\u5e8f\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5c42\u7684\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\n        # \u5982\u679c\u5f53\u524d\u503c\u5927\u4e8e\u6700\u5927\u503c\uff0c\u5219\u66f4\u65b0\u6700\u5927\u503c\n        # \u5982\u679c\u5f53\u524d\u503c\u5c0f\u4e8e\u6700\u5c0f\u503c\uff0c\u5219\u66f4\u65b0\u6700\u5c0f\u503c\n        # \u5982\u679c\u5f53\u524d\u503c\u548c\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u76f8\u7b49\uff0c\u5219\u6dfb\u52a0\u5230\u6700\u5c0f\u503c\u5217\u8868\u4e2d\n        # \u5982\u679c\u5f53\u524d\u503c\u548c\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u4e0d\u76f8\u7b49\uff0c\u5219\u6dfb\u52a0\u5230\u6700\u5927\u503c\u5217\u8868\u4e2d\n        \n        # \u521d\u59cb\u5316\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\n        max_val = float('-inf')\n        min_val = float('inf')\n        \n        # \u521d\u59cb\u5316\u6700\u5c0f\u503c\u5217\u8868\n        min_list = []\n        \n        # \u521d\u59cb\u5316\u6700\u5927\u503c\u5217\u8868\n        max_list = []\n        \n        # \u5c42\u5e8f\u904d\u5386\n        self.dfs(root, max_val, min_val, max_list, min_list)\n        \n        # \u5982\u679c\u6700\u5c0f\u503c\u5217\u8868\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56de\u6700\u5927\u503c\u5217\u8868\n        if len(min_list) == 0:\n            return max_list\n        \n        # \u5982\u679c\u6700\u5927\u503c\u5217\u8868\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56de\u6700\u5c0f", "find-the-index-of-the-first-occurrence-in-a-string": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1\n", "strong-password-checker": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # \u4e00\u4e2a\u957f\u5ea6\u4e3a1\u7684\u5b57\u7b26\uff0c\u9700\u8981\u66f4\u591a\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u4e3a1\n        # \u5982\u679c\u4e0d\u662f\u957f\u5ea6\u4e3a1\u7684\u5b57\u7b26\uff0c\u5219\u9700\u8981\u66f4\u591a\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u4e3a\u6700\u5927\u7684\u64cd\u4f5c\n        # \u5982\u679c\u4e0d\u662f\u957f\u5ea6\u4e3a1\u7684\u5b57\u7b26\uff0c\u5219\u9700\u8981\u66f4\u591a\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u4e3a\u6700\u5927\u7684\u64cd\u4f5c\n        # \u5982\u679c\u4e0d\u662f\u957f\u5ea6\u4e3a1\u7684\u5b57\u7b26\uff0c\u5219\u9700\u8981\u66f4\u591a\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u4e3a\u6700\u5927\u7684\u64cd\u4f5c\n        # \u5982\u679c\u4e0d\u662f\u957f\u5ea6\u4e3a1\u7684\u5b57\u7b26\uff0c\u5219\u9700\u8981\u66f4\u591a\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u4e3a\u6700\u5927\u7684\u64cd\u4f5c\n        # \u5982\u679c\u4e0d\u662f\u957f\u5ea6\u4e3a1\u7684\u5b57\u7b26\uff0c\u5219\u9700\u8981\u66f4\u591a\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u9700\u8981\u6700\u5c11\u7684\u64cd\u4f5c\u4e3a\u6700\u5927\u7684\u64cd\u4f5c\n        # \u5982\u679c\u4e0d\u662f\u957f\u5ea6\u4e3a1\u7684\u5b57\u7b26\uff0c\u5219\u9700\u8981\u66f4\u591a\u7684\u64cd\u4f5c\uff0c\u56e0\u6b64\u9700\u8981\ufffd", "factorial-trailing-zeroes": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 20 ms\n        # Memory: 13.7 MB\n        \n        # Solution 1:\n        # n! = n * (n - 1) * (n - 2) *... * 3 * 2 * 1\n        # The number of trailing zeros in n! is equal to the number of 5s in n!.\n        # The number of 5s in n! is equal to n // 5 + n // 25 + n // 125 +... + n // 5^k\n        # where k is the largest integer such that 5^k <= n.\n        \n        # Solution 2:\n        # The number of trailing zeros in n! is equal to the number of 5s in n!.\n        # The number of 5s in n! is equal to n // 5 + n // 25 + n // 125 +... + n // 5^k\n        # where k is the largest integer such that 5^k <= n.\n        \n        # Solution 3:\n        # The number of trailing zeros in n! is equal to the number of 5s in n!.\n        # The number of 5s in n! is equal to n // 5 + n // 25 + n // 125 +... + n // 5^k\n        # where k is the largest integer such that 5^k <= n.\n        \n        # Solution 4:\n        # The number of trailing zeros in n! is equal to the number of 5s in n!.\n        # The number of 5s in n! is equal to n // 5 + n // 25 + n // 125 +... + n // 5^k\n        # where k is the largest integer such that 5^k <= n.\n        \n        # Solution 5:\n        # The number of trailing zeros in n! is equal to the number of 5s in n!.\n        # The number of 5s in n! is equal to n // 5 + n // 25 + n // 125 +... + n // 5^k\n        # where k is the largest integer such that 5^k <= n.\n        \n        # Solution 6:\n        # The number of trailing zeros in n! is equal to the number of 5s in n!.\n        # The number of 5s in n! is equal to n // 5 + n // 25 + n // 125 +... + n // 5^k\n", "zigzag-conversion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [''] * numRows\n        \n        for i, c in enumerate(s):\n            res[i % numRows] += c\n        \n        return ''.join(res)\n", "trapping-rain-water": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4f18\u5316\uff1a\n        # \u6392\u5e8f\u540e\uff0c\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e24\u4e2a\u53f3\u8fb9\u754c\uff0c\u6240\u4ee5\u53ef\u4ee5\u4ece\u5de6\u5411\u53f3\u904d\u5386\uff0c\u6bcf\u4e2a\u70b9\u53ea\u9700\u8981\u8ba1\u7b97\u4e24\u4e2a\u53f3\u8fb9\u754c\u4e4b\u95f4\u7684\u6700\u5c0f\u503c\uff0c\n        # \u5e76\u4e14\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e24\u4e2a\u5de6\u8fb9\u754c\uff0c\u6240\u4ee5\u53ef\u4ee5\u4ece\u53f3\u5411\u5de6\u904d\u5386\uff0c\u6bcf\u4e2a\u70b9\u53ea\u9700\u8981\u8ba1\u7b97\u4e24\u4e2a\u5de6\u8fb9\u754c\u4e4b\u95f4\u7684\u6700\u5927\u503c\u3002\n        # \u6240\u4ee5\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3aO(1)\u3002\n        \n        if not height:\n            return 0\n        \n        n = len(height)\n        \n        left_max = [0] * n\n        right_max = [0] * n\n        \n        left_max[0] = height[0]\n        for i in range(1, n):\n            left_max[i] = max(left_max[i-1], height[i])\n        \n        right_max[n-1] = height[n-1]\n        for i in range(n-2, -1, -1):\n            right_max[i] = max(right_max[i+1], height[i])\n        \n        res = 0\n        for i in range(n):\n            res += min(left_max[i], right_max[i]) - height", "find-all-numbers-disappeared-in-an-array": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            while nums[i]!= i + 1:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        \n        return [i + 1 for i in range(len(nums)) if nums[i]!= i + 1]\n", "count-of-smaller-numbers-after-self": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        # \u6bcf\u6b21\u6bd4\u8f83\u5de6\u8fb9\u7684\u503c\uff0c\u5982\u679c\u5927\u4e8e\u5f53\u524d\u503c\uff0c\u5219\u5c06\u5f53\u524d\u503c\u52a01\n        # \u5426\u5219\uff0c\u6307\u9488\u5411\u53f3\u79fb\u52a8\n        # \u5982\u679c\u6307\u9488\u6307\u5411\u7a7a\uff0c\u5219\u5c06\u5f53\u524d\u503c\u52a01\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        counts = [0] * len(nums)\n        \n        left = 0\n        for right in range(len(nums)):\n            while left < right and nums[left] >= nums[right]:\n                left += 1\n            counts[right] = left\n        \n        left = len(nums) - 1\n        for right in range(len(nums) - 1, -1, -1):\n            while left > right and nums[left] <= nums[right]:\n                left -= 1\n            counts[right] += left + 1\n        \n        return counts\n", "set-intersection-size-at-least-two": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u6392\u5e8f + \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4ece\u5de6\u5230\u53f3\u6392\u5e8f\uff0c\u6bcf\u6b21\u53d6\u4e24\u4e2a\u533a\u95f4\u7684\u5de6\u8fb9\u754c\uff0c\u5982\u679c\u5de6\u8fb9\u754c\u76f8\u540c\uff0c\u5219\u53f3\u8fb9\u754c\u76f8\u540c\uff0c\u5219\u53ef\u4ee5\u7ee7\u7eed\u6bd4\u8f83\u4e24\u4e2a\u533a\u95f4\u7684\u53f3\u8fb9\u754c\u3002\n        # \u5982\u679c\u5de6\u8fb9\u754c\u4e0d\u540c\uff0c\u5219\u53ef\u4ee5\u7ee7\u7eed\u6bd4\u8f83\u4e24\u4e2a\u533a\u95f4\u7684\u5de6\u8fb9\u754c\u3002\n        # \u5982\u679c\u53f3\u8fb9\u754c\u4e0d\u540c\uff0c\u5219\u53ef\u4ee5\u7ee7\u7eed\u6bd4\u8f83\u4e24\u4e2a\u533a\u95f4\u7684\u53f3\u8fb9\u754c\u3002\n        # \u6bcf\u6b21\u6bd4\u8f83\u4e24\u4e2a\u533a\u95f4\u7684\u53f3\u8fb9\u754c\uff0c\u5982\u679c\u53f3\u8fb9\u754c\u76f8\u540c\uff0c\u5219\u53ef\u4ee5\u7ee7\u7eed\u6bd4\u8f83\u4e24\u4e2a\u533a\u95f4\u7684\u5de6\u8fb9\u754c\u3002\n        # \u5982\u679c\u5de6\u8fb9\u754c\u4e0d\u540c\uff0c\u5219\u53ef\u4ee5\u7ee7\u7eed\u6bd4\u8f83\u4e24\u4e2a\u533a\u95f4\u7684\u5de6\u8fb9\u754c\u3002\n        # \u5982\u679c\u53f3\u8fb9\u754c\u4e0d\u540c\uff0c\u5219\u53ef\u4ee5\u7ee7\u7eed\u6bd4\u8f83\u4e24\u4e2a\u533a\u95f4\u7684\u53f3\u8fb9\u754c\u3002\n        # \u5982\u679c\u53f3\u8fb9\u754c", "symmetric-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        \n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\n        \n", "number-of-atoms": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        \n        for i in range(len(formula)):\n            if formula[i].isupper():\n                stack.append(formula[i])\n            elif formula[i].islower():\n                stack.append(formula[i])\n            elif formula[i].isdigit():\n                stack.append(formula[i])\n            elif formula[i] == '(':\n                stack.append(formula[i])\n            elif formula[i] == ')':\n                while stack[-1]!= '(':\n                    stack.pop()\n                stack.pop()\n                \n        stack.reverse()\n        \n        result = ''\n        \n        for i in range(len(stack)):\n            if stack[i].isupper():\n                result += stack[i]\n                count = 1\n                \n                for j in range(i+1, len(stack)):\n                    if stack[j].isdigit():\n                        count = count * 10 + int(stack[j])\n                    else:\n                        break\n                \n                result += str(count)\n                \n        return result\n", "binary-tree-preorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res\n", "power-of-four": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n        \n        return n == 1\n", "invert-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not root:\n            return None\n        \n        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n        \n        return root\n", "generate-parentheses": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left-1, right, s+\"(\", ans)\n            if right > left:\n                generate(left, right-1, s+\")\", ans)\n        \n        ans = []\n        generate(n, n, \"\", ans)\n        return ans\n", "patching-array": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 28 ms\n        # Memory: 13.6 MB\n        \n        # dp = [0] * (n + 1)\n        # for num in nums:\n        #     if num <= n:\n        #         dp[num] += 1\n        #     else:\n        #         for i in range(num, n + 1):\n        #             dp[i] += dp[i - num]\n        # return dp[n]\n        \n        # Runtime: 28 ms\n        # Memory: 13.6 MB\n        \n        # dp = [0] * (n + 1)\n        # for num in nums:\n        #     if num <= n:\n        #         dp[num] += 1\n        #     else:\n        #         for i in range(num, n + 1):\n        #             dp[i] += dp[i - num]\n        # return len(nums) - dp[n]\n        \n        # Runtime: 28 ms\n        # Memory: 13.6 MB\n        \n        # dp = [0] * (n + 1)\n        # for num in nums:\n        #     if num <= n:\n        #         dp[num] += 1\n        #     else:\n        #         for i in range(num, n + 1):\n        #             dp[i] += dp[i - num]\n        # return len(nums) - sum(dp)\n        \n        # Runtime: 28 ms\n        # Memory: 13.6 MB\n        \n        # dp = [0] * (n + 1)\n        # for num in nums:\n        #     if num <= n:\n        #         dp[num] += 1\n        #     else:\n        #         for i in range(num, n + 1):\n        #             dp[i] += dp[i - num]\n        # return len(nums) - sum(dp[1:])\n        \n        # Runtime: 28 ms\n        # Memory: 13.6 MB\n        \n        # dp = [0] * (n + 1)\n        # for num in nums:\n        #     if num <= n:\n        #         dp[num", "longest-valid-parentheses": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = [-1]\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        \n        return max_len\n", "fraction-to-recurring-decimal": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == 0 and denominator == 0:\n            return \"0\"\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == 0:\n            return \"0.\" + \"0\" * (len(str(denominator)) - 1)\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if denominator == 0:\n            return \"0\"\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == denominator:\n            return \"0\"\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == -denominator:\n            return \"-\" + \"0\" * (len(str(denominator)) - 1)\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == -denominator:\n            return \"-\" + \"0\" * (len(str(denominator)) - 1)\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == -denominator:\n            return \"-\" + \"0\" * (len(str(denominator)) - 1)\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == denominator:\n            return \"0\"\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de0\n        if numerator == -denominator:\n            return \"-\" + \"0\" * (len(str(denominator)) - 1)\n        \n        # \u5982\u679c\u6574\u6570\u90fd\u662f0\uff0c\u5219\u8fd4\u56de", "sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n        second = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(second)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val <= right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        curr.next = left or right\n        \n        return dummy.next\n", "russian-doll-envelopes": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # \u521d\u59cb\u5316\n        dp = [1] * len(envelopes)\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j]+1)\n        \n        return max(dp)\n", "set-matrix-zeroes": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # \u627e\u52300\u7684\u884c\u548c\u5217\n        rows = set()\n        cols = set()\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        \n        # \u5220\u96640\u7684\u884c\u548c\u5217\n        for i in rows:\n            for j in range(len(matrix[0])):\n                matrix[i][j] = 0\n        for j in cols:\n            for i in range(len(matrix)):\n                matrix[i][j] = 0\n        \n        \n", "remove-nth-node-from-end-of-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Solution 1:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 2:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 3:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 4:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 5:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 6:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 7:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 8:\n        # O(n) time | O(1) space\n        # Iterate through the linked list and keep track of the head and tail\n        # When the tail reaches the nth node from the end, remove it\n        # Return the head\n        \n        # Solution 9:\n        # O(n) time | O(", "intersection-of-two-arrays": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # \u54c8\u5e0c\u8868\n        # \u5148\u5c06nums1\u4e2d\u7684\u5143\u7d20\u5b58\u5165\u4e00\u4e2a\u5b57\u5178\u4e2d\uff0c\u7136\u540e\u904d\u5386nums2\u4e2d\u7684\u5143\u7d20\uff0c\u5982\u679c\u5b58\u5728\u8fd9\u4e2a\u5143\u7d20\u5728\u5b57\u5178\u4e2d\uff0c\u5219\u5c06\u5176\u52a0\u5165\u5230\u7b54\u6848\u4e2d\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        \n        d = {}\n        for i in nums1:\n            d[i] = True\n        \n        res = []\n        for i in nums2:\n            if i in d:\n                res.append(i)\n                del d[i]\n        \n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "super-washing-machines": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4e0d\u7a33\u5b9a\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1a", "kth-smallest-number-in-multiplication-table": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # \u53cc\u6307\u9488\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n log n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u601d\u8def\uff1a\n        # \u6309\u7167\u7b2c\u4e00\u5217\u7684\u503c\u6392\u5e8f\uff0c\u7136\u540e\u6309\u7167\u7b2c\u4e8c\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u4e09\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u56db\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u4e94\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u516d\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u4e03\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u516b\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u4e5d\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u5341\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u5341\u4e00\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u5341\u4e8c\u5217\u7684\u503c\u6392\u5e8f\uff0c\n        # \u7136\u540e\u6309\u7167\u7b2c\u5341\u4e09\u5217\u7684\u503c\u6392\u5e8f\uff0c\n", "convert-sorted-list-to-binary-search-tree": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root\n", "merge-two-sorted-lists": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Solution 1:\n        # We can use a dummy head to keep track of the merged list\n        # We can then iterate through the two lists simultaneously\n        # If the current node in list1 is smaller than the current node in list2, we append it to the merged list\n        # Otherwise, we append the current node in list2 to the merged list\n        # We continue this process until we reach the end of one of the lists\n        # Finally, we append the remaining nodes in the other list to the merged list\n        \n        dummy = ListNode(0)\n        curr = dummy\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        curr.next = list1 or list2\n        \n        return dummy.next\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "maximal-rectangle": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u5148\u6c42\u51fa\u6bcf\u4e00\u884c\u7684\u6700\u5927\u957f\u5ea6\uff0c\u7136\u540e\u6c42\u51fa\u6bcf\u4e00\u5217\u7684\u6700\u5927\u957f\u5ea6\n        # \u518d\u6c42\u51fa\u6700\u5927\u533a\u57df\u7684\u9762\u79ef\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        if not matrix:\n            return 0\n        \n        max_area = 0\n        row = len(matrix)\n        col = len(matrix[0])\n        \n        # \u6c42\u51fa\u6bcf\u4e00\u884c\u7684\u6700\u5927\u957f\u5ea6\n        height = [0] * col\n        for i in range(row):\n            for j in range(col):\n                if matrix[i][j] == '0':\n                    height[j] = 0\n                else:\n                    height[j] += 1\n            \n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # \u6c42\u51fa\u6bcf\u4e00\u5217\u7684\u6700\u5927\u957f\u5ea6\n        width = [0] * row\n        for i in range(row):\n            for j in range(col):\n                if matrix[i][j] == '0':\n                    width[i] = 0\n                else:\n                    width[i] += 1\n            \n            max_area = max(max_area, self.largestRectangleArea(width))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        # \u52a8\u6001\u89c4\u5212\n        # \u5148\u6c42\u51fa\u6bcf\u4e00\u4e2a\u9ad8\u5ea6\u7684\u6700\u5927\u533a\u57df\n        # \u6c42\u51fa\u6700\u5927\u533a\u57df\u7684\u9762\u79ef\n        # \u65f6\u95f4\ufffd", "subsets": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u5148\u628a\u7b2c\u4e00\u4e2a\u5143\u7d20\u653e\u5165\u7ed3\u679c\u96c6\u5408\n        res = [[]]\n        \n        for num in nums:\n            res += [curr + [num] for curr in res]\n        \n        return res\n", "find-minimum-in-rotated-sorted-array-ii": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u6cd5\n        # \u4ece\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5f00\u59cb\u6bd4\u8f83\uff0c\u5982\u679c\u6bd4\u8f83\u7ed3\u679c\u5927\u4e8e0\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u5927\u4e8e0\u7684\u5143\u7d20\uff0c\u5426\u5219\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        if not nums:\n            return None\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "valid-number": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # \u5224\u65ad\u662f\u5426\u5b58\u5728\u7b26\u53f7\n        if s[0] in \"+-\":\n            s = s[1:]\n        # \u5224\u65ad\u662f\u5426\u5b58\u5728\u70b9\n        if \".\" in s:\n            s = s.split(\".\")\n            if len(s) == 1:\n                return False\n            if s[0] == \"\" or s[1] == \"\":\n                return False\n        # \u5224\u65ad\u662f\u5426\u5b58\u5728e\n        if \"e\" in s:\n            s = s.split(\"e\")\n            if len(s) == 1:\n                return False\n            if s[0] == \"\" or s[1] == \"\":\n                return False\n        # \u5224\u65ad\u662f\u5426\u5b58\u5728\u6570\u5b57\n        if s[0] == \"\":\n            return False\n        for i in s:\n            if i not in \"0123456789\":\n                return False\n        return True\n", "integer-to-roman": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # \u5229\u7528\u5b57\u5178\u5b58\u50a8\n        # \u5b57\u5178\u7684\u952e\u4e3a\u6570\u5b57\uff0c\u503c\u4e3a\u5b57\u7b26\u4e32\n        # \u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u6bcf\u4e2a\u5b57\u7b26\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u6570\u5b57\n        # \u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u4e32\u957f\ufffd", "find-the-difference": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.8 MB\n        \n        # Count the frequency of each letter in s and t\n        count_s = collections.Counter(s)\n        count_t = collections.Counter(t)\n        \n        # Return the letter that is in t but not in s\n        for letter in count_t:\n            if letter not in count_s:\n                return letter\n            \n            # If the letter is in s, remove it from count_s\n            count_s[letter] -= 1\n            \n            # If the letter is in s but count_s[letter] is negative, return the letter\n            if count_s[letter] < 0:\n                return letter\n", "sudoku-solver": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def check(row, col, val):\n            # check row\n            for i in range(9):\n                if board[row][i] == val:\n                    return False\n            # check col\n            for i in range(9):\n                if board[i][col] == val:\n                    return False\n            # check 3x3 box\n            box_row = row - row % 3\n            box_col = col - col % 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row + i][box_col + j] == val:\n                        return False\n            return True\n        \n        def solve():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for val in range(1, 10):\n                            if check(i, j, str(val)):\n                                board[i][j] = str(val)\n                                solve()\n                                board[i][j] = '.'\n                        return\n            return True\n        \n        solve()\n        return board\n", "recover-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # Definition for a binary tree node.\n        # class TreeNode(object):\n        #     def __init__(self, val=0, left=None, right=None):\n        #         self.val = val\n        #         self.left = left\n        #         self.right = right\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        \n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n        # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #", "palindrome-linked-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.3 MB\n        \n        # Two pointers\n        # 1. Reverse the second half of the list\n        # 2. Compare the two halves\n        \n        # Edge case\n        if not head or not head.next:\n            return True\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the list\n        prev = None\n        while slow:\n            next_node = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next_node\n        \n        # Compare the two halves\n        first = head\n        second = prev\n        while second:\n            if first.val!= second.val:\n                return False\n            first = first.next\n            second = second.next\n        \n        return True\n        ", "valid-perfect-square": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 32 ms\n        # Memory: 13.9 MB\n        \n        # binary search\n        left, right = 0, num\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n        \n        # # Runtime: 32 ms\n        # # Memory: 13.9 MB\n        #\n        # # binary search\n        # left, right = 0, num\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if mid * mid == num:\n        #         return True\n        #     elif mid * mid < num:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return False\n        \n        # # Runtime: 32 ms\n        # # Memory: 13.9 MB\n        #\n        # # binary search\n        # left, right = 0, num\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if mid * mid == num:\n        #         return True\n        #     elif mid * mid < num:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return False\n        \n        # # Runtime: 32 ms\n        # # Memory: 13.9 MB\n        #\n        # # binary search\n        # left, right = 0, num\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if mid * mid == num:\n        #         return True\n        #     elif mid * mid < num:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return False\n        \n        # # Runtime: 32 ms\n        # # Memory: 13.9 MB\n        #\n        # # binary search\n        # left, right = 0, num\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     ", "counting-bits": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Runtime: 20 ms\n        # Memory Usage: 14.3 MB\n        ans = [0]\n        for i in range(1, n + 1):\n            ans.append(ans[i >> 1] + (i & 1))\n        return ans\n", "remove-linked-list-elements": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 28 ms\n        # Memory: 13.5 MB\n        \n        # Iterative\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n        \n        \n        # Recursive\n        # def removeElements(self, head, val):\n        #     if not head:\n        #         return None\n        #     if head.val == val:\n        #         return self.removeElements(head.next, val)\n        #     head.next = self.removeElements(head.next, val)\n        #     return head\n        \n        # return self.removeElements(head, val)\n        \n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # Iterative\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next\n        \n        \n        # Recursive\n        # def removeElements(self, head, val):\n        #     if not head:\n        #         return None\n        #     if head.val == val:\n        #         return self.removeElements(head.next, val)\n        #     head.next = self.removeElements(head.next, val)\n        #     return head\n        \n        # return self.removeElements(head, val)\n        \n        \n        # Time: O(n)\n        # Space: O(1)\n        \n        # Iterative\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.val == val:\n                prev", "scramble-string": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) == 1 or len(s1) == len(s2):\n            return s1 == s2\n        \n        if sorted(s1)!= sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False\n", "simplify-path": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # \u5206\u6790\u94fe\u8868\n        # \u5206\u6790\u94fe\u8868\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u60f3\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a\n        # \u5206\u6790\u94fe\u8868\u7684\u601d\u8def\uff1a", "word-search-ii": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u5148\u6784\u5efa\u4e00\u4e2a\u5b57\u5178\uff0c\u5b57\u5178\u7684key\u662f\u5355\u8bcd\uff0cvalue\u662f\u5355\u8bcd\u7684\u957f\u5ea6\n        dic = {}\n        for word in words:\n            dic[word] = len(word)\n        \n        # \u521b\u5efa\u4e00\u4e2a\u5b57\u5178\uff0c\u5b57\u5178\u7684key\u662f\u5355\u8bcd\uff0cvalue\u662f\u5355\u8bcd\u7684\u957f\u5ea6\uff0c\u5b58\u50a8\u4e86\u5355\u8bcd\u7684\u6240\u6709\u975e\u7a7a\u5b50\u4e32\n        sub_dic = {}\n        for word in words:\n            for i in range(len(word)):\n                sub_dic[word[:i+1]] = sub_dic.get(word[:i+1], 0) + 1\n        \n        # \u521b\u5efa\u4e00\u4e2a\u5b57\u5178\uff0c\u5b57\u5178\u7684key\u662f\u5355\u8bcd\uff0cvalue\u662f\u5355\u8bcd\u7684\u957f\u5ea6\uff0c\u5b58\u50a8\u4e86\u5355\u8bcd\u7684\u6240\u6709\u975e\u7a7a\u5b50\u4e32\uff0c\u4ee5\u53ca\u5176\u6240\u6709\u5355\u8bcd\u7684\u975e\u7a7a\u5b50\u4e32\u7684\u957f\u5ea6\n        sub_dic_len = {}\n        for word in words:\n            for i in range(len(word)):\n                sub_dic_len[word[:i+1]] = sub_dic_len.get(word[:i+1], 0) + 1\n                \n        # \u521b\u5efa\u4e00\u4e2a\u5b57\u5178\uff0c\u5b57\u5178\u7684key\u662f\u5355\u8bcd\uff0cvalue\u662f\u5355\u8bcd\u7684\u957f\u5ea6\uff0c\u5b58\u50a8\u4e86\u5355\u8bcd\u7684\u6240\u6709\u975e\u7a7a\u5b50\u4e32\uff0c\u4ee5\u53ca\u5176\u6240\u6709\u5355\u8bcd\u7684\u975e\u7a7a\u5b50\u4e32\uff0c\u4ee5\u53ca\u5176\u6240\u6709\u5355\u8bcd\u7684\u975e\u7a7a\u5b50\u4e32\u7684\u957f\ufffd", "valid-anagram": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # Runtime: 40 ms\n        # Memory: 13.8 MB\n        \n        # Hashmap solution\n        if len(s)!= len(t):\n            return False\n        \n        s_hash = {}\n        t_hash = {}\n        \n        for char in s:\n            if char in s_hash:\n                s_hash[char] += 1\n            else:\n                s_hash[char] = 1\n        \n        for char in t:\n            if char in t_hash:\n                t_hash[char] += 1\n            else:\n                t_hash[char] = 1\n        \n        return s_hash == t_hash\n", "valid-sudoku": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # Solution 1\n        # O(n^2) time | O(n^2) space\n        # where n is the size of the board\n        #\n        # The idea is to use a dictionary to store the number of times each number appears in each row, column, and 3x3 box.\n        # If a number appears more than once, then the board is not valid.\n        #\n        # We can use a nested for loop to iterate over each cell in the board.\n        # For each cell, we can check if the number is already in the dictionary.\n        # If it is, then the board is not valid.\n        # If it is not, then we can add the number to the dictionary and continue to the next cell.\n        #\n        # If we reach the end of the board without finding any invalid numbers, then the board is valid.\n        \n        rows = [{} for _ in range(9)]\n        cols = [{} for _ in range(9)]\n        box = [{} for _ in range(9)]\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    continue\n                \n                if board[i][j] in rows[i]:\n                    return False\n                \n                rows[i][board[i][j]] = 1\n                \n                if board[j][i] in cols[j]:\n                    return False\n                \n                cols[j][board[j][i]] = 1\n                \n                box_i = (i // 3) * 3\n                box_j = (j // 3) * 3\n                \n                if board[box_i][box_j] in box[box_i][box_j]:\n                    return False\n                \n                box[box_i][box_j][board[box_i][box_j]] = 1\n                \n        return True\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "fizz-buzz": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u521d\u59cb\u5316\u7ed3\u679c\u5217\u8868\n        res = []\n        \n        # \u5224\u65ad\u6570\u5b57\u662f\u5426\u662f3\u30015\u300115\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                res.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                res.append(\"Fizz\")\n            elif i % 5 == 0:\n                res.append(\"Buzz\")\n            else:\n                res.append(str(i))\n        \n        return res\n", "reverse-words-in-a-string": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # \u5206\u8bcd\n        words = s.split()\n        # \u5206\u5272\n        words = list(map(lambda x: x.strip(), words))\n        # \u5408\u5e76\n        return \" \".join(words[::-1])\n", "excel-sheet-column-number": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u5b57\u5178\u6811\n        # time complexity: O(n), space complexity: O(n)\n        # runtime: 52ms\n        d = {'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10, 'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15, 'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20, 'U': 21, 'V': 22, 'W': 23, 'X': 24, 'Y': 25, 'Z': 26}\n        res = 0\n        for i in range(len(columnTitle)):\n            res += d[columnTitle[i]] * (26 ** (len(columnTitle) - i - 1))\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "candy": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not ratings:\n            return 0\n        \n        n = len(ratings)\n        \n        candies = [1 for _ in range(n)]\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)\n", "same-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # \u5229\u7528\u9012\u5f52\n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val!= q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        \n        \n        # \u5229\u7528\u53cc\u6307\u9488\n        p_stack = []\n        q_stack = []\n        \n        while p!= None or q!= None:\n            if p!= None:\n                p_stack.append(p)\n                p = p.left\n            else:\n                p = p_stack.pop()\n                if q!= None:\n                    q_stack.append(q)\n                    q = q.right\n                else:\n                    q = q_stack.pop()\n                    if p!= None:\n                        return False\n                    else:\n                        return True\n        \n        if len(p_stack)!= 0 or len(q_stack)!= 0:\n            return False\n        else:\n            return True\n        \n        \n        # \u5229\u7528\u53cc\u6307\u9488\n        p_stack = []\n        q_stack = []\n        \n        while p!= None or q!= None:\n            if p!= None:\n                p_stack.append(p)\n                p = p.left\n            else:\n                p = p_stack.pop()\n                if q!= None:\n                    q_stack.append(q)\n                    q = q.right\n                else:\n                    q = q_stack.pop()\n                    if p!= None:\n                        return False\n                    else:\n                        return True\n        \n        if len(p_stack)!= 0 or len(q_stack)!= 0:\n            return False\n        else:\n            return True\n        \n        \n        # \u5229\u7528\u53cc\u6307\u9488\n        p_stack = []\n        q_stack = []\n        \n        while p!= None or q!= None:\n            if p!= None:\n                p_stack.append(p)", "reorder-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # \u5148\u5224\u65ad\u94fe\u8868\u662f\u5426\u4e3a\u7a7a\n        if not head:\n            return head\n        \n        # \u5224\u65ad\u94fe\u8868\u957f\u5ea6\n        length = 0\n        temp = head\n        while temp:\n            length += 1\n            temp = temp.next\n        \n        # \u5224\u65ad\u94fe\u8868\u957f\u5ea6\u662f\u5426\u662f\u5947\u6570\n        if length % 2 == 0:\n            return head\n        \n        # \u5224\u65ad\u94fe\u8868\u957f\u5ea6\u662f\u5426\u662f\u5076\u6570\n        mid = length // 2\n        \n        # \u5206\u522b\u5206\u5272\u94fe\u8868\n        left = head\n        right = head\n        for i in range(mid):\n            right = right.next\n        \n        # \u5206\u522b\u5206\u5272\u94fe\u8868\n        left = head\n        right = head\n        for i in range(mid):\n            left = left.next\n        \n        # \u5206\u522b\u5408\u5e76\u94fe\u8868\n        left_tail = left\n        right_tail = right\n        while right_tail.next:\n            right_tail = right_tail.next\n        \n        right_tail.next = None\n        \n        while left_tail.next:\n            left_tail = left_tail.next\n            right_tail.next = left_tail\n            right_tail = right_tail.next\n        \n        # \u5206\u522b\u5408\u5e76\u94fe\u8868\n        left_tail.next = right\n        \n        return head\n", "word-pattern": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # \u5148\u5206\u522b\u628apattern\u548cs\u5206\u5272\u6210\u4e24\u4e2a\u5217\u8868\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u5339\u914d\n        pattern_list = pattern.split(' ')\n        s_list = s.split(' ')\n        \n        if len(pattern_list)!= len(s_list):\n            return False\n        \n        # \u5224\u65adpattern_list\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u5728s_list\u4e2d\n        pattern_set = set(pattern_list)\n        s_set = set(s_list)\n        \n        if len(pattern_set)!= len(pattern_list):\n            return False\n        \n        for i in range(len(pattern_list)):\n            if pattern_list[i] not in s_set:\n                return False\n            if s_list[i] not in pattern_set:\n                return False\n        \n        return True\n", "permutations": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # \u65b9\u6cd51\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd52\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd53\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd54\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd55\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd56\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd57\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd58\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd59\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd510\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd511\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd512\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd513\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd514\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd515\n        # \u5148\u6392\u5e8f\uff0c\u7136\u540e\u9012\u5f52\n        # \u65b9\u6cd516\n        # \u5148\u6392\u5e8f\uff0c\u7136\ufffd", "search-a-2d-matrix": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # \u66b4\u529b\u641c\u7d22\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(m * n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u4f18\u5316\uff1a\u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u53ef\u4ee5\u8f6c\u5316\u4e3a\u4e8c\u5206\u67e5\u627e\uff0c\u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(log(m * n))\n        \n        # \u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(log(m * n))\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if matrix[mid // n][mid % n] == target:\n                return True\n            \n            if matrix[mid // n][mid % n] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n", "add-two-numbers": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 28 ms\n        # Memory: 13.9 MB\n        \n        # Initialize variables\n        head = ListNode(0)\n        carry = 0\n        \n        # Iterate through the two lists\n        while l1 or l2 or carry:\n            # If either l1 or l2 is None, add the carry\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n                \n            # Append the new node to the head of the list\n            head.next = ListNode(carry % 10)\n            head = head.next\n            \n            # Update the carry\n            carry //= 10\n            \n        return head.next\n", "number-complement": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        return int(''.join(['1' if x == '0' else '0' for x in bin(num)[2:]]), 2)\n", "arithmetic-slices-ii-subsequence": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u5148\u6c42\u51fa\u6240\u6709\u5b50\u5e8f\u5217\uff0c\u7136\u540e\u518d\u6c42\u51fa\u8fd9\u4e9b\u5b50\u5e8f\u5217\u662f\u5426\u662f\u89c4\u5f8b\u5e8f\u5217\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^3)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u5148\u6c42\u51fa\u6240\u6709\u5b50\u5e8f\u5217\uff0c\u7136\u540e\u518d\u6c42\u51fa\u8fd9\u4e9b\u5b50\u5e8f\u5217\u662f\u5426\u662f\u89c4\u5f8b\u5e8f\u5217\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^3)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u5148\u6c42\u51fa\u6240\u6709\u5b50\u5e8f\u5217\uff0c\u7136\u540e\u518d\u6c42\u51fa\u8fd9\u4e9b\u5b50\u5e8f\u5217\u662f\u5426\u662f\u89c4\u5f8b\u5e8f\u5217\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^3)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u5148\u6c42\u51fa\u6240\u6709\u5b50\u5e8f\u5217\uff0c\u7136\u540e\u518d\u6c42\u51fa\u8fd9\u4e9b\u5b50\u5e8f\u5217\u662f\u5426\u662f\u89c4\u5f8b\u5e8f\u5217\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^3)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        \n        # \u66b4\u529b\u89e3\u6cd5\n        # \u5148\u6c42\u51fa\u6240\u6709\u5b50\u5e8f\u5217\uff0c\u7136\u540e\u518d\u6c42", "text-justification": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u5206\u6790\u9700\u8981\u7684\u7a7a\u683c\u6570\n        space_num = maxWidth - sum(map(len, words))\n        \n        # \u5206\u6790\u9700\u8981\u7684\u7a7a\u683c\u6570\u4e0b\u6807\n        space_index = [0]\n        for i in range(1, len(words)):\n            space_index.append(space_index[i-1] + len(words[i-1]) + 1)\n        \n        # \u5206\u6790\u9700\u8981\u7684\u7a7a\u683c\u6570\u4e0b\u6807\u4e0b\u6807\n        space_index_index = [0]\n        for i in range(1, len(space_index)):\n            space_index_index.append(space_index_index[i-1] + space_index[i])\n        \n        # \u5206\u6790\u9700\u8981\u7684\u7a7a\u683c\u6570\u4e0b\u6807\u4e0b\u6807\u4e0b\u6807\n        space_index_index_index = [0]\n        for i in range(1, len(space_index_index)):\n            space_index_index_index.append(space_index_index_index[i-1] + space_index_index[i])\n        \n        # \u5206\u6790\u9700\u8981\u7684\u7a7a\u683c\u6570\u4e0b\u6807\u4e0b\u6807\u4e0b\u6807\u4e0b\u6807\n        space_index_index_index_index = [0]\n        for i in range(1, len(space_index_index_index)):\n            space_index_index_index_index.append(space_index_index_index_index[i-1] + space_index_index_index[i])\n        \n        # \u5206\u6790\u9700\u8981\u7684\u7a7a\u683c\u6570\u4e0b\u6807\u4e0b\u6807\u4e0b\u6807\u4e0b\u6807\u4e0b\u6807\n        space_index_index_index_index_index = [0]\n        for i in range(1, len(space_index_index_index_index)):\n            space_index_index_index_index_", "binary-tree-postorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative Solution\n        # stack = []\n        # res = []\n        # if root:\n        #     stack.append(root)\n        #     while stack:\n        #         node = stack.pop()\n        #         res.append(node.val)\n        #         if node.right:\n        #             stack.append(node.right)\n        #         if node.left:\n        #             stack.append(node.left)\n        # return res[::-1]\n        \n        # Recursive Solution\n        res = []\n        def postorder(root):\n            if not root:\n                return\n            postorder(root.left)\n            postorder(root.right)\n            res.append(root.val)\n        postorder(root)\n        return res\n", "container-with-most-water": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u601d\u8def\uff1a\n        # \u5c06\u77e9\u9635\u4e2d\u7684\u6bcf\u4e00\u884c\u7684\u6700\u5927\u503c\u4f5c\u4e3a\u9ad8\u5ea6\uff0c\u7136\u540e\u7528\u4e24\u4e2a\u6307\u9488\uff0c\u5206\u522b\u4ece\u5de6\u53f3\u626b\u63cf\uff0c\u6bcf\u6b21\u66f4\u65b0\u6700\u5927\u503c\n        # \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5927\uff0c\u5219\u53f3\u6307\u9488\u5411\u5de6\u79fb\u52a8\uff0c\u5426\u5219\u5de6\u6307\u9488\u5411\u53f3\u79fb\u52a8\n        # \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5927\uff0c\u5219\u53f3\u6307\u9488\u5411\u5de6\u79fb\u52a8\uff0c\u5426\u5219\u5de6\u6307\u9488\u5411\u53f3\u79fb\u52a8\n        # \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5927\uff0c\u5219\u53f3\u6307\u9488\u5411\u5de6\u79fb\u52a8\uff0c\u5426\u5219\u5de6\u6307\u9488\u5411\u53f3\u79fb\u52a8\n        # \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5927\uff0c\u5219\u53f3\u6307\u9488\u5411\u5de6\u79fb\u52a8\uff0c\u5426\u5219\u5de6\u6307\u9488\u5411\u53f3\u79fb\u52a8\n        # \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5927\uff0c\u5219\u53f3\u6307\u9488\u5411\u5de6\u79fb\u52a8\uff0c\u5426\u5219\u5de6\u6307\u9488\u5411\u53f3\u79fb\u52a8\n        # \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5927\uff0c\u5219\ufffd", "concatenated-words": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # \u52a8\u6001\u89c4\u5212\n        # \u521d\u59cb\u5316 dp[i] \u8868\u793a words[i] \u53ef\u4ee5\u7531 words[0]... words[i-1] \u5206\u522b\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\n        # dp[i] = True \u662f\u5426\u53ef\u4ee5\u7531 words[0]... words[i-1] \u5206\u522b\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\n        # dp[i] = False \u662f\u5426\u53ef\u4ee5\u7531 words[0]... words[i-1] \u5206\u522b\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\n        # dp[i] = dp[j] and words[i] starts with words[j]\n        # dp[i] = dp[j] and words[i] ends with words[j]\n        # dp[i] = dp[j] and words[i] contains words[j]\n        # dp[i] = dp[j] and words[i] contains words[j] and words[i].startswith(words[j])\n        # dp[i] = dp[j] and words[i] contains words[j] and words[i].endswith(words[j])\n        # dp[i] = dp[j] and words[i] contains words[j] and words[i].startswith(words[j]) and words[i].endswith(words[j])\n        # dp[i] = dp[j] and words[i] contains words[j] and words[i].startswith(words[j]) and words[i].endswith(words[j]) and words[i].startswith(words[j]) and words[i].endswith(words[j])\n        # dp[i] = dp[j] and words[i] contains words[j] and words[i].startswith(words[j]) and words[i].endswith(words[j]) and words[i].startswith(words[j]) and words", "base-7": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        res = \"\"\n        \n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n            \n        return res\n", "nim-game": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # \u53ea\u6709\u4e00\u4e2a\u70b9\uff0c\u6211\u4eec\u80fd\u591f\u8d62\n        if n == 1:\n            return True\n        \n        # \u53ea\u6709\u4e24\u4e2a\u70b9\uff0c\u6211\u4eec\u80fd\u591f\u8d62\n        if n == 2:\n            return True\n        \n        # \u53ea\u6709\u4e09\u4e2a\u70b9\uff0c\u6211\u4eec\u80fd\u591f\u8d62\n        if n == 3:\n            return False\n        \n        # \u5426\u5219\uff0c\u6211\u4eec\u80fd\u591f\u8d62\n        return not self.canWinNim(n-1) or not self.canWinNim(n-2) or not self.canWinNim(n-3)\n        \n        ", "n-queens-ii": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(board, col, n):\n            if col >= n:\n                return 1\n            res = 0\n            for i in range(n):\n                if is_valid(board, i, col):\n                    board[col] = i\n                    res += backtrack(board, col + 1, n)\n            return res\n        \n        def is_valid(board, row, col):\n            for i in range(col):\n                if board[i] == row or abs(board[i] - row) == abs(col - i):\n                    return False\n            return True\n        \n        board = [-1] * n\n        return backtrack(board, 0, n)\n", "n-queens": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i] == col or \\\n                   board[i] - i == col - row or \\\n                   board[i] + i == col + row:\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(board)])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row] = col\n                    backtrack(board, row + 1)\n                    board[row] = '.'\n        \n        res = []\n        board = ['.'] * n\n        backtrack(board, 0)\n        return res\n", "word-search": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board or not board[0]:\n            return False\n        \n        m = len(board)\n        n = len(board[0])\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            \n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j]!= word[k]:\n                return False\n            \n            tmp = board[i][j]\n            board[i][j] = \"#\"\n            \n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\n            \n            board[i][j] = tmp\n            \n            return res\n        \n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0):\n                    return True\n        \n        return False\n", "merge-sorted-array": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # \u5c06nums2\u63d2\u5165\u5230nums1\u7684\u672b\u5c3e\n        for i in range(n):\n            nums1[m+i] = nums2[i]\n        \n        # \u5c06nums1\u4e2d\u7684\u5143\u7d20\u6392\u5e8f\n        nums1.sort()\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        ", "third-maximum-number": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # \u5206\u6cbb\u6cd5\n        # \u6bd4\u8f83\u6bcf\u4e2a\u6570\uff0c\u82e5\u5927\u4e8e\u7b2c\u4e00\u4e2a\uff0c\u5219\u7b2c\u4e00\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u4e8c\u4e2a\uff0c\u5219\u7b2c\u4e8c\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u4e09\u4e2a\uff0c\u5219\u7b2c\u4e09\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u56db\u4e2a\uff0c\u5219\u7b2c\u56db\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u4e94\u4e2a\uff0c\u5219\u7b2c\u4e94\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u516d\u4e2a\uff0c\u5219\u7b2c\u516d\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u4e03\u4e2a\uff0c\u5219\u7b2c\u4e03\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u516b\u4e2a\uff0c\u5219\u7b2c\u516b\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u4e5d\u4e2a\uff0c\u5219\u7b2c\u4e5d\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u5341\u4e2a\uff0c\u5219\u7b2c\u5341\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u5341\u4e00\u4e2a\uff0c\u5219\u7b2c\u5341\u4e00\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u5341\u4e8c\u4e2a\uff0c\u5219\u7b2c\u5341\u4e8c\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u5341\u4e09\u4e2a\uff0c\u5219\u7b2c\u5341\u4e09\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u5341\u56db\u4e2a\uff0c\u5219\u7b2c\u5341\u56db\u4e2a\u66f4\u65b0\uff0c\u82e5\u5927\u4e8e\u7b2c\u5341\u4e94\u4e2a\ufffd"}