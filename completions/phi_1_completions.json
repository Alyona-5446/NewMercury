{"spiral-matrix": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        \n        # define boundaries\n        top, bottom, left, right = 0, m-1, 0, n-1\n        \n        while top <= bottom and left <= right:\n            # traverse top row\n            for j in range(left, right+1):\n                res.append(matrix[top][j])\n            top += 1\n            \n            # traverse right column\n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            # traverse bottom row\n            if top <= bottom:\n                for j in range(right, left-1, -1):\n                    res.append(matrix[bottom][j])\n                bottom -= 1\n            \n            # traverse left column\n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res", "summary-ranges": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        ranges = []\n        start = end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(str(start) + \"->\" + str(end))\n                start = end = nums[i]\n        \n        if start == end:\n            ranges.append(str(start))\n        else:\n            ranges.append(str(start) + \"->\" + str(end))\n        \n        return ranges", "distinct-subsequences": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a 2D array to store the number of distinct subsequences\n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        # Fill the array using dynamic programming\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + 1\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        # Return the number of distinct subsequences\n        return dp[-1][-1]", "first-missing-positive": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            while 0 < nums[i] <= n and nums[nums[i]-1]!= nums[i]:\n                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]\n        for i in range(n):\n            if nums[i]!= i+1:\n                return i+1\n        return n+1", "permutation-sequence": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        fact = 1\n        for i in range(1, n+1):\n            fact *= i\n        \n        seq = []\n        for i in range(1, n+1):\n            seq.append(str(i))\n        \n        k -= 1\n        while k > 0:\n            k -= 1\n            new_seq = []\n            for i in range(n-1, -1, -1):\n                new_seq.append(seq[i])\n            for i in range(n):\n                new_seq.append(seq[k % len(seq)])\n                k //= len(seq)\n            seq = new_seq\n        \n        return ''.join(seq)", "two-sum-ii-input-array-is-sorted": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize pointers\n        left, right = 0, len(numbers) - 1\n        \n        # Loop until pointers meet\n        while left < right:\n            # Calculate current sum\n            current_sum = numbers[left] + numbers[right]\n            \n            # If current sum is equal to target, return indices\n            if current_sum == target:\n                return [left, right]\n            \n            # If current sum is less than target, move left pointer to the right\n            elif current_sum < target:\n                left += 1\n            \n            # If current sum is greater than target, move right pointer to the left\n            else:\n                right -= 1\n        \n        # If no two numbers add up to target, return empty list\n        return []", "expression-add-operators": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(start, path, res):\n            if start == len(num):\n                if eval(path) == target:\n                    res.append(path)\n                return\n            for i in range(start, len(num)):\n                if i > start and num[i] == '0':\n                    break\n                if num[start]!= '0' and (i == start or num[i-1]!= '0'):\n                    dfs(i+1, path+num[start]+'+', res)\n                if int(num[start:i+1]) >= 0 and int(num[start:i+1]) <= 9:\n                    dfs(i+1, path+num[start:i+1]+'*', res)\n        \n        res = []\n        dfs(0, '', res)\n        return res", "sum-root-to-leaf-numbers": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        stack = [root]\n        total = 0\n        \n        while stack:\n            node = stack.pop()\n            total = total * 10 + node.val\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return total", "license-key-formatting": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # Remove dashes from the string\n        s = s.replace('-', '')\n        \n        # Split the string into groups of k characters\n        groups = [s[i:i+k] for i in range(0, len(s), k)]\n        \n        # If the last group is shorter than k, add dashes to make it k characters long\n        if len(groups[-1]) < k:\n            groups[-1] += '-' * (k - len(groups[-1]))\n        \n        # Convert all lowercase letters to uppercase and join the groups with dashes\n        return '-'.join(groups).upper()", "gas-station": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        start = 0\n        total_gas = gas[start]\n        total_cost = cost[start]\n        \n        for i in range(1, n):\n            total_gas += gas[(start+i)%n] - gas[start]\n            total_cost += cost[(start+i)%n]\n            \n            if total_gas < 0:\n                total_gas += gas[start]\n                total_cost -= cost[start]\n                start = (start+i)%n\n                \n        return start if total_gas >= 0 else -1", "burst-balloons": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        dp = [0] * n\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, n):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i]*nums[i-1])\n        return dp[-1]", "plus-one": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        carry = 1\n        for i in range(len(digits)-1, -1, -1):\n            digits[i] += carry\n            if digits[i] == 10:\n                digits[i] = 0\n                carry = 1\n            else:\n                carry = 0\n        if carry == 1:\n            digits.insert(0, 1)\n        return digits", "regular-expression-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not s and not p:\n            return True\n        if not s or not p:\n            return False\n        if p[0] == '.':\n            return self.isMatch(s, p[1:])\n        if p[0] == '*':\n            return (self.isMatch(s, p[1:]) or (s and (self.isMatch(s[1:], p) or self.isMatch(s, p[2:]))))\n        return False", "create-maximum-number": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each digit in nums1 and nums2\n        freq = {}\n        for num in nums1 + nums2:\n            for digit in str(num):\n                freq[digit] = freq.get(digit, 0) + 1\n        \n        # create a list to store the k digits with the highest frequency\n        result = []\n        for digit in freq:\n            if freq[digit] >= k:\n                result.extend([int(digit)] * (k))\n            else:\n                result.extend([int(digit)] * freq[digit])\n        \n        return result", "perfect-number": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        divisors_sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors_sum += i\n                if i!= num // i:\n                    divisors_sum += num // i\n        return divisors_sum == num", "fibonacci-number": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)\n    \n    def fibonacci_number(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return self.fib(n-1) + self.fib(n-2)\n    \n    def fibonacci_sequence(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        sequence = []\n        for i in range(n+1):\n            sequence.append(self.fibonacci_number(i))\n        return sequence", "dungeon-game": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a 2D list to store the minimum health required to reach each room\n        min_health = [[float('inf') for _ in range(len(dungeon[0]))] for _ in range(len(dungeon))]\n        \n        # Set the minimum health required to reach the bottom-right room to be the value of the bottom-right room\n        min_health[-1][-1] = dungeon[-1][-1]\n        \n        # Iterate over the rooms in reverse order from bottom to top\n        for i in range(len(dungeon)-2, -1, -1):\n            for j in range(len(dungeon[0])-2, -1, -1):\n                \n                # Check if the current room is a wall or a magic orb\n                if dungeon[i][j] == -1 or dungeon[i][j] == 0:\n                    min_health[i][j] = 0\n                \n                # Check the minimum health required to reach the room above\n                if i+1 < len(dungeon):\n                    min_health[i][j] = min(min_health[i][j], min_health[i+1][j] + dungeon[i][j])\n                \n                # Check the minimum health required to reach the room to the left\n                if j+1 < len(dungeon[0]):\n                    min_health[i][j] = min(min_health[i][j], min_health[i][j+1] + dungeon[i][j])\n        \n        # Return the minimum health required to reach the top-left room\n        return min_health[0][0]", "find-k-th-smallest-pair-distance": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = float('inf')\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if nums[j] - nums[i] <= nums[i+1] - nums[j]:\n                    res = min(res, j-i)\n                    if res == k-1:\n                        return nums[j] - nums[i]\n        return -1", "number-of-segments-in-a-string": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        count = 0\n        in_segment = False\n        \n        # Iterate through each character in the string\n        for char in s:\n            if char == \" \":\n                # If we encounter a space, check if we are currently in a segment\n                if in_segment:\n                    count += 1\n                    in_segment = False\n            else:\n                # If we encounter a non-space character, we are currently in a segment\n                in_segment = True\n        \n        return count", "reverse-vowels-of-a-string": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])\n        s = list(s)\n        i, j = 0, len(s) - 1\n        \n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        \n        return ''.join(s)", "longest-consecutive-sequence": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        longest_seq = 0\n        \n        for num in nums_set:\n            if num - 1 not in nums_set:\n                current_num = num\n                current_seq = 1\n                \n                while current_num + 1 in nums_set:\n                    current_num += 1\n                    current_seq += 1\n                \n                longest_seq = max(longest_seq, current_seq)\n        \n        return longest_seq", "missing-number": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        expected_sum = (n+1)*(n+2)//2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum", "word-ladder": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # Create a set of words for faster lookup\n        word_set = set(wordList)\n        \n        # Create a queue for BFS\n        queue = [(beginWord, 1)]\n        \n        # Create a set to keep track of visited words\n        visited = set()\n        \n        # BFS\n        while queue:\n            curr_word, curr_len = queue.pop(0)\n            \n            # Check if we have reached the end word\n            if curr_word == endWord:\n                return curr_len\n            \n            # Check if we have already visited this word\n            if curr_word in visited:\n                continue\n            \n            # Mark this word as visited\n            visited.add(curr_word)\n            \n            # Generate all possible next words by changing one letter at a time\n            for i in range(len(curr_word)):\n                for j in range(26):\n                    next_word = curr_word[:i] + chr(ord('a') + j) + curr_word[i+1:]\n                    \n                    # Check if the next word is in the word set and not visited\n                    if next_word in word_set and next_word not in visited:\n                        queue.append((next_word, curr_len+1))\n        \n        # If we have not found a path to the end word, return 0\n        return 0", "add-binary": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        carry = 0\n        result = \"\"\n        \n        i = len(a) - 1\n        j = len(b) - 1\n        \n        while i >= 0 or j >= 0 or carry:\n            \n            sum = carry\n            \n            if i >= 0:\n                sum += int(a[i])\n                i -= 1\n            \n            if j >= 0:\n                sum += int(b[j])\n                j -= 1\n            \n            result = str(sum % 2) + result\n            carry = sum // 2\n        \n        return result", "find-first-and-last-position-of-element-in-sorted-array": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        result = [-1, -1]\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                result[0] = mid\n                result[1] = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return result", "remove-duplicates-from-sorted-array": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # YOUR CODE HERE\n        k = len(nums)\n        i = 0\n        while i < k:\n            if i == k - 1 or nums[i]!= nums[i+1]:\n                nums[i] = nums[i+1]\n                k -= 1\n            else:\n                i += 1\n        return k", "jump-game-ii": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return 0\n        \n        jumps = 1\n        max_reach = nums[0]\n        steps = nums[0]\n        \n        for i in range(1, len(nums)):\n            if i == len(nums) - 1:\n                return jumps\n            \n            max_reach = max(max_reach, i + nums[i])\n            steps -= 1\n            \n            if steps == 0:\n                jumps += 1\n                steps = max_reach - i\n        \n        return -1", "best-time-to-buy-and-sell-stock-iv": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(prices[i+1] - prices[i] for i in range(len(prices)-1))\n        \n        dp = [[0] * (k+1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k+1):\n                dp[i][j] = max(dp[i-1][j], prices[i] + dp[i-1][j-1] - prices[i-1])\n        \n        return dp[-1][-1]", "convert-a-number-to-hexadecimal": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_digits = '0123456789abcdef'\n        hex_num = ''\n        \n        while num > 0:\n            remainder = num % 16\n            hex_num = hex_digits[remainder] + hex_num\n            num //= 16\n        \n        return hex_num if hex_num else '0'", "first-unique-character-in-a-string": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with count 1\n        for i in range(len(s)):\n            if char_count[s[i]] == 1:\n                return i\n        \n        # if no character with count 1 is found, return -1\n        return -1", "contains-duplicate-iii": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n                    return True\n        return False", "sort-colors": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Initialize pointers i, j, and k\n        i, j, k = 0, 0, 0\n        \n        # Loop through the array\n        while k < len(nums):\n            # If the current element is 0, swap it with the element at the next position\n            if nums[k] == 0:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n                j += 1\n            # If the current element is 1, swap it with the element at the next position\n            elif nums[k] == 1:\n                nums[i], nums[j] = nums[j], nums[i]\n                j += 1\n            # If the current element is 2, swap it with the element at the next position\n            else:\n                nums[i], nums[k] = nums[k], nums[i]\n                i += 1\n            k += 1", "max-consecutive-ones": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_ones = 0\n        current_ones = 0\n        \n        for num in nums:\n            if num == 1:\n                current_ones += 1\n                max_ones = max(max_ones, current_ones)\n            else:\n                current_ones = 0\n                \n        return max_ones", "count-complete-tree-nodes": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return 1 + left + right\n    \n    def countNodes_iterative(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        queue = [root]\n        count = 1\n        \n        while queue:\n            level_size = len(queue)\n            count += level_size\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        return count", "add-strings": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        carry = 0\n        result = \"\"\n        \n        i, j = len(num1)-1, len(num2)-1\n        \n        while i >= 0 or j >= 0 or carry:\n            \n            sum_ = carry\n            \n            if i >= 0:\n                sum_ += int(num1[i])\n                i -= 1\n            \n            if j >= 0:\n                sum_ += int(num2[j])\n                j -= 1\n            \n            result = str(sum_ % 10) + result\n            carry = sum_ // 10\n        \n        return result", "basic-calculator": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # YOUR CODE HERE\n        stack = []\n        num = 0\n        sign = 1\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                stack.append(sign * num)\n                num = 0\n                sign = 1\n            elif c == '-':\n                stack.append(sign * num)\n                num = 0\n                sign = -1\n            elif c == '(':\n                stack.append(sign)\n                stack.append('(')\n                sign = 1\n            elif c == ')':\n                stack.append(sign * num)\n                num = 0\n                while stack[-2]!= '(':\n                    stack[-3] += stack[-1] * stack[-2]\n                    stack.pop()\n                stack.pop()\n                stack.pop()\n        stack.append(sign * num)\n        stack.pop()\n        return sum(stack)", "ipo": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(profits)\n        dp = [[0 for _ in range(w+1)] for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            for j in range(1, w+1):\n                if j >= capital[i-1]:\n                    dp[i][j] = max(dp[i-1][j], profits[i-1] + dp[i-1][j-capital[i-1]])\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        return dp[n][w]", "valid-parentheses": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        \n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char]!= top_element:\n                    return False\n            else:\n                stack.append(char)\n        \n        return not stack", "next-permutation": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        n = len(nums)\n        if n <= 1:\n            return\n        \n        # Find the first i such that nums[i] < nums[i+1]\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # If no such index is found, the array is already the largest possible permutation\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # Find the largest j such that nums[j] > nums[i]\n        j = n - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the suffix starting at index i+1\n        nums[i+1:] = reversed(nums[i+1:])\n        \n        return", "contains-duplicate-ii": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j] and abs(i-j) <= k:\n                    return True\n        \n        return False", "maximum-gap": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            gap = nums[i] - nums[i-1]\n            if gap > max_gap:\n                max_gap = gap\n        \n        return max_gap", "binary-tree-level-order-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result", "couples-holding-hands": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        swaps = 0\n        for i in range(0, n, 2):\n            if row[i]!= row[i+1]:\n                for j in range(i+2, n, 2):\n                    if row[j] == row[i] and row[j+1] == row[i+1]:\n                        row[i+1], row[i+2] = row[i+2], row[i+1]\n                        swaps += 1\n        return swaps", "interleaving-string": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2)!= len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0 or len(s2) == 0 or len(s3) == 0:\n            return False\n        \n        dp = [[False for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]\n        \n        for i in range(len(s1)+1):\n            for j in range(len(s2)+1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    if s1[i-1] == s3[j-1]:\n                        dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    if s2[j-1] == s3[i-1]:\n                        dp[i][j] = dp[i-1][j]\n                else:\n                    if s1[i-1] == s3[j-1] and dp[i-1][j]:\n                        dp[i][j] = True\n                    if s2[j-1] == s3[i-1] and dp[i][j-1]:\n                        dp[i][j] = True\n        \n        return dp[-1][-1]", "assign-cookies": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the children in descending order of their greed factors\n        children = sorted(range(len(g)), key=lambda i: g[i], reverse=True)\n        \n        # Initialize the number of content children and the remaining size of the cookies\n        num_content = 0\n        remaining_s = sum(s)\n        \n        # Iterate over the children and assign cookies to them\n        for child in children:\n            # If the child can satisfy the cookie, assign it and update the remaining size\n            if s[child] >= g[child]:\n                num_content += 1\n                remaining_s -= g[child]\n                s[child] = 0\n            # If the child cannot satisfy the cookie, move on to the next child\n            else:\n                continue\n            \n            # If all children have satisfied the cookie, break out of the loop\n            if remaining_s == 0:\n                break\n        \n        return num_content", "keyboard-row": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a set of the letters in the first row\n        row1 = set(\"qwertyuiop\")\n        \n        # Create a set of the letters in the second row\n        row2 = set(\"asdfghjkl\")\n        \n        # Create a set of the letters in the third row\n        row3 = set(\"zxcvbnm\")\n        \n        # Create a set of all the letters in the alphabet\n        alphabet = set(\"abcdefghijklmnopqrstuvwxyz\")\n        \n        # Find the intersection of the three sets of letters\n        common_letters = row1.intersection(row2, row3)\n        \n        # Create a list of words that can be typed using only the common letters\n        result = []\n        for word in words:\n            if set(word).issubset(common_letters):\n                result.append(word)\n        \n        return result", "reverse-linked-list-ii": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or left > right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        for i in range(left-1):\n            prev = curr\n            curr = curr.next\n        \n        first = prev.next\n        second = curr\n        \n        for i in range(right-left):\n            temp = second.next\n            second.next = first\n            first = second\n            second = temp\n        \n        first.next = second\n        \n        return dummy.next", "shortest-palindrome": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Check if s is already a palindrome\n        if s == s[::-1]:\n            return s\n        \n        # Find the longest palindrome that can be formed by adding characters to the front of s\n        for i in range(len(s), 0, -1):\n            if s[:i] == s[:i][::-1]:\n                return s[:i] + s + s[i:]\n        \n        # If no palindrome can be formed, return an empty string\n        return \"\"", "minimum-window-substring": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Create a dictionary to store the frequency of characters in t\n        t_freq = {}\n        for char in t:\n            t_freq[char] = t_freq.get(char, 0) + 1\n        \n        # Initialize variables to keep track of the start and end of the window\n        start = 0\n        end = 0\n        min_start = 0\n        min_end = float('inf')\n        count = len(t_freq)\n        \n        # Initialize a dictionary to keep track of the frequency of characters in the current window\n        window_freq = {}\n        for i in range(start, end+1):\n            char = s[i]\n            window_freq[char] = window_freq.get(char, 0) + 1\n            \n            # If the current window contains all characters in t, move the start pointer to minimize the window size\n            if window_freq[char] == count:\n                while window_freq[char] == count:\n                    char = s[start]\n                    window_freq[char] -= 1\n                    start += 1\n                \n                # Update the minimum window size if necessary\n                if end - start < min_end - min_start:\n                    min_start, min_end = start, end\n        \n        # Return the minimum window substring\n        if min_start == 0:\n            return \"\"\n        else:\n            return s[min_start:min_end+1]\n        \n        # Initialize variables to keep track of the start and end of the window\n        start = 0\n        end = 0\n        min_start = 0\n        min_end = float('inf')\n        count = len(t_freq)\n        \n        # Initialize a dictionary to keep track of the frequency of characters in the current window\n        window_freq = {}\n        for i in range(start, end+1):\n            char = s[i]\n            window_freq[char] = window_freq.get(char, 0) + 1\n            \n            # If the current window contains all characters in t, move the end pointer to minimize the window size\n            if window_freq[char] == count:\n                while window_freq", "self-crossing": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # If the distance is 0, then there is no path\n        if distance[0] == 0:\n            return False\n        \n        # If the distance is 1, then there is a single path\n        if distance[1] == 1:\n            return True\n        \n        # If the distance is 2, then there are two paths\n        if distance[2] == 2:\n            return True\n        \n        # If the distance is greater than 2, then there are two possible paths\n        for i in range(3, len(distance)):\n            if distance[i] == distance[i-1] + distance[i-2]:\n                return True\n        \n        # If none of the above conditions are met, then there is no path\n        return False", "remove-duplicates-from-sorted-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            if curr.val == prev.val:\n                curr = curr.next\n            else:\n                prev.next = curr\n                prev = curr\n                curr = curr.next\n        \n        prev.next = None\n        \n        return head", "longest-palindrome": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the frequency of each character in the string\n        char_freq = {}\n        for char in s:\n            if char in char_freq:\n                char_freq[char] += 1\n            else:\n                char_freq[char] = 1\n        \n        # Count the number of characters with odd frequency\n        odd_freq_count = 0\n        for freq in char_freq.values():\n            if freq % 2 == 1:\n                odd_freq_count += 1\n        \n        # If there are no characters with odd frequency, the longest palindrome is the length of the string\n        if odd_freq_count == 0:\n            return len(s)\n        \n        # If there is only one character with odd frequency, it can be placed in the middle of the palindrome\n        else:\n            return len(s) - odd_freq_count + 1", "construct-binary-tree-from-inorder-and-postorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[root_idx+1:], postorder[root_idx:-1])\n        root.left = self.buildTree(inorder[:root_idx], postorder[:root_idx:-1])\n        \n        return root", "cut-off-trees-for-golf-event": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Find the starting point\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 0:\n                    start = (i, j)\n                    break\n        \n        # If there is no tree in the starting point, return -1\n        if start is None:\n            return -1\n        \n        # Use breadth-first search to find the shortest path to reach all trees\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            curr, steps = queue.pop(0)\n            if forest[curr[0]][curr[1]] == 1:\n                # All trees have been cut off\n                return steps\n            visited.add(curr)\n            for neighbor in [(curr[0]-1, curr[1]), (curr[0]+1, curr[1]), (curr[0], curr[1]-1), (curr[0], curr[1]+1)]:\n                if 0 <= neighbor[0] < len(forest) and 0 <= neighbor[1] < len(forest[0]) and forest[neighbor[0]][neighbor[1]] > 0 and neighbor not in visited:\n                    queue.append((neighbor, steps+1))\n        \n        # If no path is found, return -1\n        return -1", "minimum-depth-of-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))", "count-of-range-sum": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        prefix_sum = 0\n        prefix_sums = {0: 1}\n        \n        for num in nums:\n            prefix_sum += num\n            \n            for i in range(lower, upper+1):\n                prefix_sums[i] = prefix_sums.get(i, 0) + prefix_sum\n                \n            count += prefix_sums.get(upper+1, 0) - prefix_sums.get(lower-1, 0)\n            \n        return count", "arranging-coins": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # The maximum number of coins that can be used to build a staircase with k rows is k*(k+1)/2\n        # We can use the formula for the sum of an arithmetic series to calculate the number of complete rows\n        # We can then use integer division and modulo to determine the number of incomplete rows\n        \n        complete_rows = (n * (n+1)) // 2\n        incomplete_rows = n - complete_rows\n        \n        return incomplete_rows", "longest-uncommon-subsequence-i": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        def get_subsequences(s):\n            if not s:\n                return {''}\n            subsequences = set()\n            for subsequence in get_subsequences(s[1:]):\n                subsequences.add(subsequence)\n                subsequences.add(s[0] + subsequence)\n            return subsequences\n        \n        a_subsequences = get_subsequences(a)\n        b_subsequences = get_subsequences(b)\n        \n        longest_uncommon_subsequence = ''\n        for subsequence in a_subsequences:\n            if subsequence not in b_subsequences and len(subsequence) > len(longest_uncommon_subsequence):\n                longest_uncommon_subsequence = subsequence\n        \n        return len(longest_uncommon_subsequence)", "binary-tree-level-order-traversal-ii": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result[::-1]", "palindrome-number": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        elif x < 10:\n            return True\n        else:\n            num_str = str(x)\n            mid = len(num_str) // 2\n            left = num_str[:mid]\n            right = num_str[mid + len(num_str) % 2:]\n            return left == right[::-1]", "decode-ways": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][0] represents the number of ways to decode s[:i]\n        # dp[i][1] represents the number of ways to decode s[:i+1]\n        # if s[i] is 0, then dp[i][0] = dp[i-1][0]\n        # if s[i] is not 0, then dp[i][0] = dp[i-1][0] + dp[i-1][1]\n        # if s[i] is between 10 and 26, then dp[i][1] = dp[i-1][0]\n        \n        n = len(s)\n        dp = [[0, 0] for _ in range(n)]\n        dp[0][0] = 1\n        dp[0][1] = 0 if s[0] == '0' else 1\n        \n        for i in range(1, n):\n            if s[i] == '0':\n                dp[i][0] = dp[i-1][0]\n            elif s[i] == '1':\n                dp[i][0] = dp[i-1][0] + dp[i-1][1]\n            elif s[i] == '2':\n                dp[i][0] = dp[i-1][0]\n            elif s[i] == '3':\n                dp[i][0] = dp[i-1][0] + dp[i-1][1]\n            elif s[i] == '4':\n                dp[i][0] = dp[i-1][0]\n            elif s[i] == '5':\n                dp[i][0] = dp[i-1][0] + dp[i-1][1]\n            elif s[i] == '6':\n                dp[i][0] = dp[i-1][0]\n            elif s[i] == '7':\n                dp[i][0] = dp[i-1][0] + dp[i-1][1]\n            elif s[i] == '8':\n                dp[i", "is-subsequence": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if not s:\n            return True\n        if not t:\n            return False\n        if s[0] == t[0]:\n            return self.isSubsequence(s[1:], t[1:])\n        else:\n            return self.isSubsequence(s[1:], t) or self.isSubsequence(s, t[1:])", "gray-code": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the first two rows of the gray code sequence\n        row1 = [0, 1]\n        row2 = [1, 0]\n        \n        # Generate the rest of the gray code sequence\n        for i in range(2, n+1):\n            # Calculate the new row by taking the previous two rows and flipping their bits\n            new_row = []\n            for j in range(len(row1)):\n                new_row.append(row1[j] ^ row2[j])\n            \n            # Update the previous two rows\n            row1 = row2\n            row2 = new_row\n        \n        # Return the final row\n        return row2", "climbing-stairs": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            dp = [0] * (n+1)\n            dp[1] = 1\n            dp[2] = 2\n            for i in range(3, n+1):\n                dp[i] = dp[i-1] + dp[i-2]\n            return dp[n]", "word-break": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize a set of words to store all possible segments of s\n        possible_segments = set()\n        \n        # Define a recursive helper function to find all possible segments of s\n        def find_segments(s, segment):\n            # If the current segment is a valid word, add it to the set of possible segments\n            if segment in wordDict:\n                possible_segments.add(segment)\n            \n            # If the current segment is longer than the remaining string s, return\n            if len(segment) > len(s):\n                return\n            \n            # If the current segment is shorter than the remaining string s, try to find all possible segments starting from each word in wordDict\n            for word in wordDict:\n                if s.startswith(word):\n                    find_segments(s[len(word):], segment + \" \" + word)\n        \n        # Call the helper function to find all possible segments of s\n        find_segments(s, \"\")\n        \n        # If there is at least one possible segment, return True\n        return bool(possible_segments)", "validate-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def is_bst(node, min_val, max_val):\n            if not node:\n                return True\n            if node.val <= min_val or node.val >= max_val:\n                return False\n            return is_bst(node.left, min_val, node.val) and is_bst(node.right, node.val, max_val)\n        \n        return is_bst(root, float('-inf'), float('inf'))", "insert-interval": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not intervals:\n            return [newInterval]\n        \n        start, end = newInterval\n        \n        if start <= intervals[0][0] <= end or start <= intervals[-1][1] <= end:\n            return intervals + [newInterval]\n        \n        idx = 0\n        while idx < len(intervals) and (intervals[idx][0] <= end or intervals[idx][1] >= start):\n            idx += 1\n        \n        return intervals[:idx] + [newInterval] + intervals[idx:]", "palindrome-partitioning": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        if not s:\n            return []\n        \n        res = []\n        n = len(s)\n        \n        def backtrack(start, path):\n            if start == n:\n                res.append(path[:])\n                return\n            \n            for end in range(start+1, n+1):\n                if is_palindrome(s[start:end]):\n                    path.append(s[start:end])\n                    backtrack(end, path)\n                    path.pop()\n        \n        backtrack(0, [])\n        return res", "smallest-range-covering-elements-from-k-lists": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Find the smallest and largest numbers in the input list\n        smallest = float('inf')\n        largest = float('-inf')\n        for lst in nums:\n            smallest = min(smallest, min(lst))\n            largest = max(largest, max(lst))\n        \n        # If there are no numbers in the input list, return [0, 0]\n        if smallest == float('inf') or largest == float('-inf'):\n            return [0, 0]\n        \n        # Find the smallest range that includes at least one number from each of the k input lists\n        smallest_range = [smallest, largest]\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if min(nums[i]) > smallest_range[0] and max(nums[i]) < smallest_range[1]:\n                    smallest_range = [min(nums[i]), max(nums[i])]\n                if min(nums[j]) > smallest_range[0] and max(nums[j]) < smallest_range[1]:\n                    smallest_range = [min(nums[j]), max(nums[j])]\n        \n        return smallest_range", "poor-pigs": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the buckets as a list of empty buckets\n        buckets = [False] * buckets\n        \n        # Initialize the number of pigs needed to test\n        pigs_needed = 0\n        \n        # Keep feeding pigs until time runs out\n        while minutesToDie > 0:\n            # Keep track of which pigs have died\n            pigs_die = [False] * buckets\n            \n            # Keep feeding pigs until time runs out\n            while minutesToDie > 0 and pigs_die.count(True) < buckets:\n                # Choose a random bucket to feed the pig\n                bucket = random.randint(0, buckets-1)\n                \n                # If the pig dies, mark it as deceased\n                if pigs_die[bucket]:\n                    pigs_die[bucket] = False\n                \n                # If the pig dies on the bucket, feed it to a random other bucket\n                if pigs_die[bucket]:\n                    for i in range(buckets):\n                        if not pigs_die[i]:\n                            other_bucket = (i + 1) % buckets\n                            if pigs_die[other_bucket]:\n                                pigs_die[other_bucket] = False\n                                pigs_die[bucket] = True\n                                break\n                \n                # If the pig dies on a bucket that was already fed, feed it to a random other bucket\n                for i in range(buckets):\n                    if pigs_die[i]:\n                        other_bucket = (i + 1) % buckets\n                        if pigs_die[other_bucket]:\n                            pigs_die[other_bucket] = False\n                            pigs_die[bucket] = True\n                            break\n                \n                # Increment the number of pigs needed\n                pigs_needed += 1\n            \n            # Time to test the pigs\n            minutesToTest -= 1\n            \n            # If all pigs have died, return the number of pigs needed\n            if all(pigs_die):\n                return pigs_needed\n        \n        # If time runs out without finding a poisonous bucket, return -1\n        return -1", "swim-in-rising-water": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, t):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] <= t:\n                return float('inf')\n            if i == len(grid) - 1 and j == len(grid[0]) - 1:\n                return 0\n            res = float('inf')\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                res = min(res, dfs(i + di, j + dj, t))\n            return res + 1\n        \n        res = float('inf')\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                res = min(res, dfs(i, j, grid[i][j]))\n        return res", "unique-paths": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Base case\n        if m == 1 or n == 1:\n            return 1\n        \n        # Recursive case\n        return self.uniquePaths(m-1, n) + self.uniquePaths(m, n-1)", "multiply-strings": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # Convert input strings to integers\n        num1, num2 = int(num1), int(num2)\n        \n        # Multiply the integers\n        product = num1 * num2\n        \n        # Convert the product back to a string and return it\n        return str(product)", "best-time-to-buy-and-sell-stock-iii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(prices) < 2:\n            return 0\n        \n        max_profit = 0\n        min_price = prices[0]\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit", "combination-sum-ii": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(start, path, target):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                backtrack(i+1, path+[candidates[i]], target-candidates[i])\n        \n        candidates.sort()\n        res = []\n        backtrack(0, [], target)\n        return res", "detect-capital": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        else:\n            return False", "best-time-to-buy-and-sell-stock": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(prices) < 2:\n            return 0\n        \n        max_profit = 0\n        min_price = prices[0]\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit", "binary-tree-inorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = []\n        result = []\n        \n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                result.append(root.val)\n                root = root.right\n        \n        return result", "construct-binary-tree-from-preorder-and-inorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root", "remove-invalid-parentheses": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_valid(s):\n            stack = []\n            for c in s:\n                if c == '(':\n                    stack.append(c)\n                elif c == ')':\n                    if not stack:\n                        return False\n                    stack.pop()\n            return not stack\n        \n        def backtrack(s, path, res):\n            if is_valid(s):\n                res.append(path)\n            for i in range(len(s)):\n                if s[i] == '(':\n                    backtrack(s[:i] + s[i+1:], path + s[i], res)\n        \n        res = []\n        backtrack(s, '', res)\n        return res", "merge-k-sorted-lists": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Base case: if there are no linked-lists, return None\n        if not lists:\n            return None\n        \n        # Recursive case: merge the first two linked-lists and then merge the result with the next linked-list\n        head = self.mergeKLists(lists[:2])\n        curr = head\n        for lst in lists[2:]:\n            curr = self.merge(curr, lst)\n        return head\n    \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        # Compare the first elements of the two linked-lists and add the smaller one to the result list\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        # Add the remaining elements of the longer list to the result list\n        curr.next = l1 if l1 else l2\n        \n        return dummy.next", "palindrome-partitioning-ii": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n-1, -1, -1):\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    if j - i == 1 or dp[i+1][j-1]:\n                        dp[i][j] = True\n        return dp[0][n-1]", "preimage-size-of-factorial-zeroes-function": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize count to 0\n        count = 0\n        \n        # Keep incrementing count until we find a number with k zeroes at the end\n        while True:\n            count += 1\n            if str(count).endswith('0' * k):\n                return count\n            elif count > 10**9:  # If we've gone too far, return 0\n                return 0", "palindrome-pairs": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        pairs = []\n        word_dict = {}\n        for i, word in enumerate(words):\n            for j in range(i+1, len(words)):\n                if is_palindrome(word+words[j]):\n                    pairs.append([i,j])\n            if word in word_dict:\n                word_dict[word].append(i)\n            else:\n                word_dict[word] = [i]\n        return pairs", "convert-sorted-array-to-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root", "contain-virus": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, visited):\n            \"\"\"\n            :type i: int\n            :type j: int\n            :type visited: List[List[bool]]\n            :rtype: int\n            \"\"\"\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or visited[i][j] or isInfected[i][j] == 0:\n                return 0\n            visited[i][j] = True\n            count = 1\n            count += dfs(i+1, j, visited)\n            count += dfs(i-1, j, visited)\n            count += dfs(i, j+1, visited)\n            count += dfs(i, j-1, visited)\n            return count\n        \n        count = 0\n        visited = [[False for _ in range(len(isInfected[0]))] for _ in range(len(isInfected))]\n        for i in range(len(isInfected)):\n            for j in range(len(isInfected[0])):\n                if isInfected[i][j] == 1 and not visited[i][j]:\n                    count += dfs(i, j, visited)\n        return count", "longest-increasing-path-in-a-matrix": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[1] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                    if 0 <= x < m and 0 <= y < n and matrix[x][y] < matrix[i][j]:\n                        dp[i][j] = max(dp[i][j], dp[x][y] + 1)\n        \n        return max(max(row) for row in dp)", "number-of-digit-one": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(n+1):\n            count += str(i).count('1')\n        return count", "word-break-ii": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(start):\n            if start == len(s):\n                return ['']\n            res = []\n            for i in range(start, len(s)):\n                if s[start:i+1] in wordDict and dfs(i+1):\n                    res.append(s[start:i+1])\n            return res\n        \n        return dfs(0)", "binary-tree-zigzag-level-order-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_res = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n            level += 1\n        \n        return res", "binary-watch": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate_times(hours, minutes):\n            if hours == 0:\n                return [\"0:00\"]\n            else:\n                times = []\n                for time in generate_times(hours-1, minutes):\n                    times.append(str(hours%12).zfill(2) + \":\" + time)\n                return times\n        \n        times = generate_times(turnedOn, turnedOn*10)\n        return [time for time in times if time[0]!= \"0\"]", "pascals-triangle": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        elif numRows == 1:\n            return [[1]]\n        elif numRows == 2:\n            return [[1], [1,1]]\n        else:\n            result = [[1], [1,1]]\n            for i in range(2, numRows):\n                row = [1]\n                for j in range(1, i):\n                    row.append(result[i-1][j-1] + result[i-1][j])\n                row.append(1)\n                result.append(row)\n            return result", "power-of-three": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1", "binary-tree-maximum-path-sum": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            self.max_sum = max(self.max_sum, left + right + node.val)\n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum", "trapping-rain-water-ii": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        left, right, top, bottom = 0, n-1, 0, m-1\n        volume = 0\n        \n        while left < right and top < bottom:\n            width = right - left\n            height = bottom - top\n            \n            if heightMap[top][left] < heightMap[top][right]:\n                volume += width * heightMap[top][left]\n                left += 1\n            else:\n                volume += width * heightMap[top][right]\n                right -= 1\n            \n            if heightMap[top][left] < heightMap[bottom][left]:\n                volume += width * heightMap[top][left]\n                top += 1\n            else:\n                volume += width * heightMap[bottom][left]\n                bottom -= 1\n            \n            if heightMap[top][right] < heightMap[top][left]:\n                volume += width * heightMap[top][right]\n                left += 1\n            else:\n                volume += width * heightMap[top][right]\n                right -= 1\n            \n            if heightMap[bottom][right] < heightMap[bottom][left]:\n                volume += width * heightMap[bottom][right]\n                top += 1\n            else:\n                volume += width * heightMap[bottom][left]\n                bottom -= 1\n        \n        return volume", "valid-palindrome": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # Remove all non-alphanumeric characters and convert to lowercase\n        s = ''.join(filter(str.isalnum, s)).lower()\n        \n        # Check if the string is equal to its reverse\n        return s == s[::-1]", "sliding-window-median": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        def median(lst):\n            n = len(lst)\n            if n % 2 == 0:\n                return (lst[n//2-1] + lst[n//2]) / 2\n            else:\n                return lst[n//2]\n        \n        res = []\n        for i in range(len(nums) - k + 1):\n            res.append(median(nums[i:i+k]))\n        return res", "rotate-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 0:\n            return head\n        \n        n = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            n += 1\n        \n        curr.next = head\n        \n        k = k % n\n        \n        for i in range(n-k):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head", "ugly-number": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n //= 2\n        while n % 3 == 0:\n            n //= 3\n        while n % 5 == 0:\n            n //= 5\n        \n        return n == 1", "falling-squares": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Sort the positions by x-coordinate\n        positions.sort()\n        \n        # Initialize variables\n        stack = []\n        max_height = 0\n        \n        # Iterate through the positions\n        for x, side_length in positions:\n            # If the stack is empty or the current square is to the left of the top square in the stack, add it to the stack\n            if not stack or x < stack[-1][0]:\n                stack.append((x, side_length))\n            # If the current square is to the right of the top square in the stack, remove the top square from the stack and update the max height\n            elif x > stack[-1][0]:\n                top_x, top_side_length = stack.pop()\n                max_height = max(max_height, top_side_length)\n            # If the current square is in the top square of the stack, update the max height\n            else:\n                max_height = max(max_height, side_length)\n        \n        # Return the max height\n        return [max_height] * len(positions)", "sum-of-left-leaves": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return root.val\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)", "max-sum-of-rectangle-no-larger-than-k": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_sum = float('-inf')\n        \n        for left in range(cols):\n            temp = [0] * rows\n            for right in range(left, cols):\n                for i in range(rows):\n                    temp[i] += matrix[i][right]\n                curr_sum = 0\n                for i in range(rows):\n                    curr_sum += temp[i]\n                    if curr_sum > k:\n                        break\n                    max_sum = max(max_sum, curr_sum)\n        \n        return max_sum", "divide-two-integers": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if divisor == 0:\n            raise ZeroDivisionError(\"division by zero\")\n        \n        sign = 1\n        if (dividend < 0) ^ (divisor < 0):\n            sign = -1\n        \n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        \n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            i = 1\n            while temp <= dividend:\n                temp <<= 1\n                i += 1\n            dividend -= temp >> 1\n            quotient += 1 << (i - 1)\n        \n        return sign * quotient", "surrounded-regions": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j]!= 'O':\n                return\n            board[i][j] = 'X'\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n-1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m-1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'X':\n                    board[i][j] = 'O'", "two-sum": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        index_dict = {}\n        for i, num in enumerate(nums):\n            if num in index_dict:\n                return [index_dict[num], i]\n            else:\n                index_dict[target - num] = i\n        return []", "24-game": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j):\n            if i == j:\n                return cards[i] == 24\n            for k in range(i+1, j):\n                if cards[i] == cards[k]:\n                    continue\n                if cards[i] == 1 and cards[k] == 2:\n                    continue\n                if cards[i] == 2 and cards[k] == 1:\n                    continue\n                if cards[i] == 3 and cards[k] == 4:\n                    continue\n                if cards[i] == 4 and cards[k] == 3:\n                    continue\n                if cards[i] == 5 and cards[k] == 6:\n                    continue\n                if cards[i] == 6 and cards[k] == 5:\n                    continue\n                if cards[i] == 7 and cards[k] == 8:\n                    continue\n                if cards[i] == 8 and cards[k] == 7:\n                    continue\n                if cards[i] == 9 and cards[k] == 1:\n                    continue\n                if cards[i] == 1 and cards[j] == 2:\n                    return dfs(i, k) or dfs(k, j)\n                if cards[i] == 2 and cards[j] == 1:\n                    return dfs(i, k) or dfs(k, j)\n                if cards[i] == 3 and cards[j] == 4:\n                    return dfs(i, k) or dfs(k, j)\n                if cards[i] == 4 and cards[j] == 3:\n                    return dfs(i, k) or dfs(k, j)\n                if cards[i] == 5 and cards[j] == 6:\n                    return dfs(i, k) or dfs(k, j)\n                if cards[i] == 6 and cards[j] == 5:\n                    return dfs(i, k) or dfs(k, j)\n                if cards[i] == 7 and cards[j] == 8:\n                    return dfs(i, k) or dfs(k, j)\n                if cards[i] == 8 and cards[j] == 7:\n                    return dfs(i, k) or dfs(k, j", "wildcard-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if p[0] == '*':\n            return any(self.isMatch(s, p[i:]) for i in range(1, len(p))) or (s and (p[0] == s[0] or p[0] == '?'))\n        \n        return p[0] == s[0] or p[0] == '?' and self.isMatch(s[1:], p[1:])\n    \n    def wildcard_matching(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if not p:\n            return not s\n        \n        if p[0] == '*':\n            return any(self.wildcard_matching(s[i:], p[i+1:]) for i in range(len(s))) or (s and (p[0] == s[0] or p[0] == '?'))\n        \n        return p[0] == s[0] or p[0] == '?' and self.wildcard_matching(s[1:], p[1:])", "majority-element": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        candidate = None\n        count = 0\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        count = 0\n        for num in nums:\n            if num == candidate:\n                count += 1\n        \n        return candidate if count > n // 2 else None", "reconstruct-itinerary": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Create a dictionary to store the tickets\n        ticket_dict = {}\n        for ticket in tickets:\n            if ticket[0] not in ticket_dict:\n                ticket_dict[ticket[0]] = []\n            ticket_dict[ticket[0]].append(ticket[1])\n        \n        # Create a list to store the itinerary\n        itinerary = []\n        \n        # Start with JFK\n        itinerary.append(\"JFK\")\n        \n        # Keep track of the tickets used\n        used_tickets = set()\n        used_tickets.add(\"JFK\")\n        \n        # Loop until all tickets have been used\n        while len(used_tickets) < len(ticket_dict):\n            # Find the next ticket to use\n            next_ticket = None\n            for ticket in ticket_dict:\n                if ticket not in used_tickets:\n                    if next_ticket is None or ticket_dict[ticket][0] < ticket_dict[next_ticket][0]:\n                        next_ticket = ticket\n            \n            # If there is no next ticket, there is no valid itinerary\n            if next_ticket is None:\n                return []\n            \n            # Add the next ticket to the itinerary and mark it as used\n            itinerary.append(next_ticket)\n            used_tickets.add(next_ticket)\n        \n        return itinerary", "4sum": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, n-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                left, right = j+1, n-1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left+1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right-1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res", "the-skyline-problem": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not buildings:\n            return []\n        \n        # sort buildings by left coordinate\n        buildings.sort()\n        \n        # initialize variables\n        skyline = []\n        max_height = 0\n        i = 0\n        \n        # loop through buildings\n        while i < len(buildings):\n            # get the current building\n            left, right, height = buildings[i]\n            \n            # if the current building is taller than the previous building, update the skyline\n            if height > max_height:\n                skyline.append([left, 0])\n                max_height = height\n            \n            # if the current building is shorter than the previous building, add it to the skyline\n            elif height < max_height:\n                skyline.append([left, height])\n            \n            # move to the next building\n            i += 1\n        \n        return skyline", "reverse-string": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # iterate through the list in reverse order\n        for i in range(len(s)//2):\n            # swap the elements at indices i and len(s)-1-i\n            s[i], s[len(s)-1-i] = s[len(s)-1-i], s[i]", "reverse-linked-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        return prev", "triangle": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(triangle)\n        dp = [0] * n\n        dp[0] = triangle[0][0]\n        for i in range(1, n):\n            dp[i] = dp[i-1] + triangle[i][i]\n            for j in range(i-1, 0, -1):\n                dp[j] = min(dp[j], dp[j-1]) + triangle[i][j]\n        return min(dp[-1], dp[-2])", "integer-to-english-words": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        if num == 0:\n            return \"Zero\"\n        \n        words = \"\"\n        \n        # handle thousands\n        if num >= 1000:\n            words += ones[num // 1000] + \" Thousand \"\n            num %= 1000\n        \n        # handle hundreds\n        if num >= 100:\n            words += ones[num // 100] + \" Hundred \"\n            num %= 100\n        \n        # handle tens and ones\n        if num >= 20:\n            words += tens[num // 10] + \" \"\n            num %= 10\n        elif num >= 10:\n            words += teens[num - 10] + \" \"\n            num = 0\n        \n        if num > 0:\n            words += ones[num] + \" \"\n        \n        return words.strip()", "k-inverse-pairs-array": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        \n        # dp[i][j] is the number of inverse pairs of length i with j elements\n        dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n        \n        # base case\n        for i in range(1, n+1):\n            dp[i][i] = 1\n        \n        # fill the rest of the table\n        for l in range(2, n+1):\n            for i in range(1, n-l+2):\n                j = i + l - 1\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD\n        \n        return dp[1][n]", "swap-nodes-in-pairs": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        prev = None\n        curr = head\n        next = curr.next\n        \n        while next and next.next:\n            curr.val, next.val = next.val, curr.val\n            prev = curr\n            curr = next\n            next = next.next\n        \n        if next:\n            curr.val, next.val = next.val, curr.val\n        \n        curr.next = prev\n        \n        return curr", "path-sum": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return root.val == targetSum\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)", "partition-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes to point to the head of each partition\n        dummy_head = ListNode(0)\n        dummy_tail = ListNode(0)\n        \n        # initialize pointers for each partition\n        curr_head = dummy_head\n        curr_tail = dummy_tail\n        \n        # iterate through the linked list\n        while head:\n            if head.val < x:\n                curr_tail.next = head\n                curr_tail = curr_tail.next\n            else:\n                curr_head.next = head\n                curr_head = curr_head.next\n            head = head.next\n        \n        # connect the two partitions\n        curr_tail.next = None\n        curr_head.next = dummy_tail.next.next\n        \n        return dummy_head.next", "redundant-connection-ii": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the parent of each node\n        parent = {}\n        for u, v in edges:\n            parent[v] = u\n        \n        # find the root node\n        root = None\n        for v in parent:\n            if parent[v] is None:\n                root = v\n                break\n        \n        # if there is no root node, return None\n        if root is None:\n            return None\n        \n        # create a set to store the children of the root node\n        children = set()\n        for v in parent:\n            if parent[v] == root:\n                children.add(v)\n        \n        # create a set to store the edges that need to be removed\n        to_remove = set()\n        for v in parent:\n            if parent[v] is not None:\n                for u in parent:\n                    if parent[u] == v and u!= root:\n                        to_remove.add((u, v))\n        \n        # create a set to store the edges that can be removed\n        result = []\n        for u, v in to_remove:\n            result.append([u, v])\n        \n        return result", "permutations-ii": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, used):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if i not in used:\n                    if (i > 0 and nums[i] == nums[i-1]) or (i < len(nums)-1 and nums[i] == nums[i+1]):\n                        continue\n                    if not path or nums[i] > path[-1]:\n                        path.append(nums[i])\n                        used.add(i)\n                        backtrack(nums, path, used)\n                        path.pop()\n                        used.remove(i)\n        \n        res = []\n        nums.sort()\n        backtrack(nums, [], set())\n        return res", "add-digits": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(int(digit) for digit in str(num))\n        return num", "single-number": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements in the list\n        result = 0\n        for num in nums:\n            result ^= num\n        \n        # Return the result\n        return result", "length-of-last-word": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # If there are no words, return 0\n        if len(words) == 0:\n            return 0\n        \n        # Otherwise, return the length of the last word\n        return len(words[-1])", "cherry-pickup": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, n):\n            for j in range(i+1):\n                if j == 0:\n                    dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i-1][j+1])\n                elif j == i:\n                    dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i-1][j-1])\n                else:\n                    dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1])\n        \n        return max(dp[n-1])", "student-attendance-record-ii": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        \n        # Initialize dp table\n        dp = [[0 for _ in range(3)] for _ in range(n+1)]\n        \n        # Base cases\n        dp[0][0] = 1\n        dp[0][1] = 0\n        dp[0][2] = 0\n        \n        # Fill dp table\n        for i in range(1, n+1):\n            for j in range(3):\n                if j == 0:\n                    dp[i][j] = dp[i-1][1] * 2 + dp[i-1][2]\n                elif j == 1:\n                    dp[i][j] = dp[i-1][0] * 2 + dp[i-1][2]\n                else:\n                    dp[i][j] = dp[i-1][0] * 2 + dp[i-1][1]\n        \n        # Return answer\n        return dp[n][0] % MOD", "happy-number": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(num):\n            total_sum = 0\n            while num > 0:\n                num, digit = divmod(num, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = fast = n\n        while fast!= 1 and get_next(fast)!= 1:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1\n    \n\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        while n!= 1 and n not in seen:\n            seen.add(n)\n            n = sum(int(digit)**2 for digit in str(n))\n        return n == 1", "search-insert-position": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left", "jump-game": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 1:\n            return True\n        \n        max_reach = nums[0]\n        for i in range(1, len(nums)):\n            if i == len(nums) - 1:\n                return True\n            max_reach = max(max_reach, i + nums[i])\n            if i == max_reach:\n                return False", "minimum-path-sum": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the first row and first column\n        for i in range(1, len(grid)):\n            grid[i][0] += grid[i-1][0]\n        for j in range(1, len(grid[0])):\n            grid[0][j] += grid[0][j-1]\n        \n        # Calculate the minimum path sum for each cell\n        for i in range(1, len(grid)):\n            for j in range(1, len(grid[0])):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        \n        # Return the minimum path sum for the bottom right cell\n        return grid[-1][-1]", "count-and-say": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        def say(num):\n            count = 1\n            say_str = \"\"\n            for i in range(1, len(num)):\n                if num[i] == num[i-1]:\n                    count += 1\n                else:\n                    say_str += str(count) + num[i-1]\n                    count = 1\n            say_str += str(count) + num[-1]\n            return say_str\n        \n        if n == 1:\n            return \"1\"\n        else:\n            prev_say = say(self.countAndSay(n-1))\n            return say(prev_say)", "split-array-largest-sum": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        dp = [[0] * (1 << k) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1 << k):\n                dp[i][j] = float('inf')\n                for l in range(1, i + 1):\n                    s = sum(nums[l - 1:i])\n                    if j & (1 << l - 1):\n                        s += dp[l - 1][j ^ (1 << l - 1)]\n                    else:\n                        s += dp[l - 1][j]\n                    dp[i][j] = min(dp[i][j], s)\n        return dp[n][(1 << k) - 1]", "search-in-rotated-sorted-array": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1\n    \n    def search_rotated(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1\n    \n    def search_rotated_sorted(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target", "letter-combinations-of-a-phone-number": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6':'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if not next_digits:\n                output.append(combination)\n            else:\n                for letter in digit_to_letters[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output", "combination-sum": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(start, path, target):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                backtrack(i+1, path+[candidates[i]], target-candidates[i])\n        \n        candidates.sort()\n        res = []\n        backtrack(0, [], target)\n        return res", "find-the-closest-palindrome": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        if n == n[::-1]:\n            return n\n        \n        n = int(n)\n        left = str(n - 1)\n        right = str(n + 1)\n        \n        while True:\n            if is_palindrome(left):\n                return left\n            elif is_palindrome(right):\n                return right\n            else:\n                left = str(int(left) - 1)\n                right = str(int(right) + 1)", "spiral-matrix-ii": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        row_start, row_end = 0, n-1\n        col_start, col_end = 0, n-1\n        \n        while row_start <= row_end and col_start <= col_end:\n            \n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start-1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start-1, -1):\n                    matrix[i][col_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix", "reverse-integer": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        sign = -1 if x < 0 else 1\n        x = abs(x)\n        \n        result = 0\n        while x > 0:\n            digit = x % 10\n            result = result * 10 + digit\n            x //= 10\n        \n        result *= sign\n        \n        if result < -2**31 or result > 2**31 - 1:\n            return 0\n        \n        return result", "rotate-image": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = temp", "maximum-product-subarray": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            num = nums[i]\n            temp = max_product\n            max_product = max(num, min_product * num, result * num)\n            min_product = min(num, min_product * num, result * num)\n            result = temp\n        \n        return result", "frog-jump": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(stones)\n        if n == 1:\n            return True\n        \n        # Find the first stone\n        i = 0\n        while i < n-1 and stones[i+1] - stones[i] <= 2:\n            i += 1\n        \n        # If the last stone is too far, return False\n        if i == n-1:\n            return False\n        \n        # Check if it is possible to cross the river\n        for j in range(1, 2**(i+1)):\n            curr = stones[i]\n            for k in range(i+1):\n                if j & (1 << k):\n                    curr += 1\n                else:\n                    curr -= 1\n                if curr < stones[0] or curr > stones[-1]:\n                    return False\n            if curr == stones[-1]:\n                return True\n        \n        return False", "relative-ranks": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        n = len(score)\n        sorted_score = sorted(score, reverse=True)\n        d = {}\n        for i in range(n):\n            d[sorted_score[i]] = str(i+1)\n        return [d[score[i]] for i in range(n)]", "longest-substring-without-repeating-characters": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize variables\n        start = 0\n        max_len = 0\n        char_dict = {}\n        \n        # Iterate through the string\n        for i in range(len(s)):\n            # If the character is already in the dictionary and its index is greater than or equal to the start of the current substring\n            if s[i] in char_dict and char_dict[s[i]] >= start:\n                # Update the start of the current substring to the index of the repeated character + 1\n                start = char_dict[s[i]] + 1\n            # Update the index of the current character in the dictionary\n            char_dict[s[i]] = i\n            # Update the maximum length of the substring\n            max_len = max(max_len, i - start + 1)\n        \n        return max_len", "substring-with-concatenation-of-all-words": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Create a dictionary to store the frequency of each word in words\n        word_freq = {}\n        for word in words:\n            word_freq[word] = word_freq.get(word, 0) + 1\n        \n        # Create a list to store the starting indices of all substrings of s that are of length len(words)*len(words[0])\n        result = []\n        \n        # Iterate over all possible substrings of s of length len(words)*len(words[0])\n        for i in range(len(s)-len(words)*len(words[0])+1):\n            substring = s[i:i+len(words)*len(words[0])]\n            \n            # Check if the substring is of length len(words)*len(words[0])\n            if len(substring) == len(words)*len(words[0]):\n                \n                # Create a dictionary to store the frequency of each word in the substring\n                substring_freq = {}\n                for j in range(0, len(substring), len(words[0])):\n                    word = substring[j:j+len(words[0])]\n                    substring_freq[word] = substring_freq.get(word, 0) + 1\n                \n                # Check if the substring is of length len(words)*len(words[0])\n                if substring_freq == word_freq:\n                    result.append(i)\n        \n        return result", "max-chunks-to-make-sorted-ii": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not arr:\n            return 0\n        \n        n = len(arr)\n        dp = [1] * n\n        \n        for i in range(1, n):\n            if arr[i] >= arr[i-1]:\n                dp[i] = dp[i-1] + 1\n        \n        return max(dp)", "insertion-sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        prev = None\n        \n        while curr and curr.next:\n            if curr.val > curr.next.val:\n                if prev:\n                    prev.next = curr.next\n                else:\n                    dummy = curr.next\n                curr.next, prev = prev, curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        if curr:\n            prev.next = curr\n        \n        return dummy.next", "remove-duplicates-from-sorted-list-ii": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            if curr.val == prev.val:\n                curr = curr.next\n            else:\n                prev.next = curr\n                prev = curr\n                curr = curr.next\n        \n        prev.next = None\n        \n        return head", "3sum": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                total = nums[i] + nums[l] + nums[r]\n                if total < 0:\n                    l += 1\n                elif total > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res", "edit-distance": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n        \n        return dp[m][n]", "hamming-distance": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # XOR the two integers to get a new integer with 1s in the positions where the bits differ\n        xor = x ^ y\n        \n        # Count the number of 1s in the XOR result using bit manipulation\n        count = 0\n        while xor:\n            count += xor & 1\n            xor >>= 1\n        \n        return count", "binary-tree-paths": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(node, path, res):\n            if not node:\n                return\n            path += str(node.val)\n            if not node.left and not node.right:\n                res.append(path)\n            dfs(node.left, path, res)\n            dfs(node.right, path, res)\n            path.pop()\n        \n        if not root:\n            return []\n        res = []\n        dfs(root, \"\", res)\n        return res", "reverse-pairs": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge_sort(nums, left, right):\n            if left < right:\n                mid = (left + right) // 2\n                merge_sort(nums, left, mid)\n                merge_sort(nums, mid + 1, right)\n                merge(nums, left, mid, right)\n        \n        def merge(nums, left, mid, right):\n            temp = [0] * (right - left + 1)\n            i, j = left, mid + 1\n            for k in range(left, right + 1):\n                if i > mid:\n                    nums[k] = nums[right]\n                    right -= 1\n                elif j > right:\n                    nums[k] = nums[left]\n                    left += 1\n                elif nums[i] > 2 * nums[j]:\n                    temp[k - left] = nums[i]\n                    i += 1\n                else:\n                    temp[k - left] = nums[j]\n                    j += 1\n            for k in range(left, right + 1):\n                nums[k] = temp[k - left]\n        \n        merge_sort(nums, 0, len(nums) - 1)\n        return sum(1 for i in range(len(nums)) for j in range(i + 1, len(nums)) if nums[i] > 2 * nums[j])", "reaching-points": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx!= tx and sy!= ty:\n            if sx < tx:\n                sx += sy\n            else:\n                sy += sx\n        return sx == tx and sy == ty", "compare-version-numbers": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            v1_val = int(v1[i]) if i < len(v1) else 0\n            v2_val = int(v2[i]) if i < len(v2) else 0\n            \n            if v1_val < v2_val:\n                return -1\n            elif v1_val > v2_val:\n                return 1\n        \n        return 0", "best-time-to-buy-and-sell-stock-ii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(prices) < 2:\n            return 0\n        \n        max_profit = 0\n        min_price = prices[0]\n        \n        for price in prices[1:]:\n            if price < min_price:\n                min_price = price\n            else:\n                max_profit = max(max_profit, price - min_price)\n        \n        return max_profit", "course-schedule-iii": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        count = 0\n        end_day = 0\n        \n        for duration, last_day in courses:\n            if last_day >= end_day:\n                count += 1\n                end_day = duration + last_day\n        \n        return count", "reverse-nodes-in-k-group": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        prev = None\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            curr = curr.next\n        \n        if count < k:\n            return head\n        \n        curr = head\n        while curr and count >= k:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        if next_node:\n            head.next = self.reverseKGroup(next_node, k)\n        \n        return prev", "repeated-substring-pattern": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(1, len(s)):\n            if len(s) % i == 0:\n                sub = s[:i]\n                if sub * (len(s) // i) == s:\n                    return True\n        return False", "unique-binary-search-trees": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0 or n == 1:\n            return 1\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-j-1]\n        \n        return dp[n]", "single-number-ii": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements in the list\n        result = 0\n        for num in nums:\n            result ^= num\n        \n        # Return the result\n        return result", "stickers-to-spell-word": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to store the frequency of each letter in stickers\n        freq = {}\n        for sticker in stickers:\n            for letter in sticker:\n                freq[letter] = freq.get(letter, 0) + 1\n        \n        # Check if it is possible to form the target string using the stickers\n        if set(target) - set(freq.keys()):\n            return -1\n        \n        # Use dynamic programming to find the minimum number of stickers needed to form the target string\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        for i in range(1, len(target) + 1):\n            for sticker in stickers:\n                if len(sticker) <= i and target[i-len(sticker):i] in freq and freq[target[i-len(sticker):i]] > 0:\n                    dp[i] = min(dp[i], dp[i-len(sticker)] + 1)\n        \n        return dp[-1]", "strange-printer": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        count = 1\n        for i in range(1, len(s)):\n            if s[i]!= s[i-1]:\n                count += 1\n        \n        return count", "sqrtx": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 2:\n            return x\n        \n        left, right = 1, x // 2\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right if abs(right * right - x) < abs(left * left - x) else left", "roman-to-integer": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                result += roman_dict[s[i]] - 2 * roman_dict[s[i-1]]\n            else:\n                result += roman_dict[s[i]]\n        return result", "contains-duplicate": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # create a set to store unique values\n        unique_nums = set()\n        \n        # iterate through the list of numbers\n        for num in nums:\n            # if the number is already in the set, it is a duplicate\n            if num in unique_nums:\n                return True\n            # otherwise, add the number to the set\n            else:\n                unique_nums.add(num)\n        \n        # if we make it through the loop without finding a duplicate, return False\n        return False", "sliding-window-maximum": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        max_val = max(nums[:k])\n        res = [max_val]\n        \n        for i in range(k, len(nums)):\n            if nums[i-k] == max_val:\n                max_val = max(nums[i-k+1:i+1])\n            else:\n                max_val = max(nums[i-k+1:i])\n            res.append(max_val)\n        \n        return res", "median-of-two-sorted-arrays": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge two sorted arrays\n        merged = []\n        i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        merged += nums1[i:]\n        merged += nums2[j:]\n        \n        # find median\n        n = len(merged)\n        if n % 2 == 0:\n            return (merged[n//2-1] + merged[n//2]) / 2\n        else:\n            return merged[n//2]", "find-minimum-in-rotated-sorted-array": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]", "pascals-triangle-ii": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        elif rowIndex == 1:\n            return [1, 1]\n        else:\n            prev_row = self.getRow(rowIndex-1)\n            curr_row = [1]\n            for i in range(1, rowIndex):\n                curr_row.append(prev_row[i-1] + prev_row[i])\n            curr_row.append(1)\n            return curr_row", "path-sum-ii": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, path, res):\n            if not node:\n                return\n            path.append(node.val)\n            if not node.left and not node.right:\n                if sum(path) == targetSum:\n                    res.append(path[:])\n            dfs(node.left, path, res)\n            dfs(node.right, path, res)\n            path.pop()\n        \n        res = []\n        dfs(root, [], res)\n        return res", "construct-the-rectangle": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for L in range(int(area**0.5), 0, -1):\n            W = area // L\n            if L * W == area:\n                return [L, W]\n        return []", "word-ladder-ii": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Create a set of words for faster lookup\n        word_set = set(wordList)\n        \n        # Create a queue for BFS\n        queue = [(beginWord, [beginWord])]\n        visited = set()\n        \n        while queue:\n            curr_word, path = queue.pop(0)\n            \n            # Check if we have reached the end word\n            if curr_word == endWord:\n                return path\n            \n            # Check if we have already visited this word\n            if curr_word in visited:\n                continue\n            \n            # Add the current word to the visited set\n            visited.add(curr_word)\n            \n            # Generate all possible next words by changing one letter at a time\n            for i in range(len(curr_word)):\n                for j in range(26):\n                    next_word = curr_word[:i] + chr(ord('a') + j) + curr_word[i+1:]\n                    \n                    # Check if the next word is in the word set and has not been visited\n                    if next_word in word_set and next_word not in visited:\n                        queue.append((next_word, path + [next_word]))\n        \n        # If we have not found a path, return an empty list\n        return []", "balanced-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def is_balanced(node):\n            if not node:\n                return True, 0\n            left_balanced, left_height = is_balanced(node.left)\n            right_balanced, right_height = is_balanced(node.right)\n            balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1\n            height = max(left_height, right_height) + 1\n            return balanced, height\n        \n        return is_balanced(root)[0]", "power-of-two": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        return n & (n-1) == 0", "subsets-ii": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a set to store all the subsets\n        subsets = set()\n        \n        # add the empty subset to the set\n        subsets.add(tuple())\n        \n        # loop through each number in the input list\n        for num in nums:\n            # create a new subset by adding the current number to each subset in the set\n            new_subsets = set()\n            for subset in subsets:\n                new_subset = list(subset)\n                new_subset.append(num)\n                new_subsets.add(tuple(new_subset))\n            # add the new subsets to the original set\n            subsets.update(new_subsets)\n        \n        # convert the set of subsets to a list and return it\n        return [list(subset) for subset in subsets]", "largest-rectangle-in-histogram": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        i = 0\n        \n        while i < len(heights):\n            if not stack or heights[i] >= heights[stack[-1]]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                area = heights[top] * (i - stack[-1] - 1 if stack else i)\n                max_area = max(max_area, area)\n        \n        while stack:\n            top = stack.pop()\n            area = heights[top] * (i - stack[-1] - 1 if stack else i)\n            max_area = max(max_area, area)\n        \n        return max_area", "evaluate-reverse-polish-notation": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token.isdigit():\n                stack.append(int(token))\n            else:\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                elif token == \"/\":\n                    stack.append(int(a / b))\n        return stack.pop()", "perfect-rectangle": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # Create a set of all the x and y coordinates of the rectangles\n        x_coords = set()\n        y_coords = set()\n        for rectangle in rectangles:\n            x_coords.add(rectangle[0])\n            x_coords.add(rectangle[2])\n            y_coords.add(rectangle[1])\n            y_coords.add(rectangle[3])\n        \n        # Check if there is at least one point in each set\n        return len(x_coords) == len(rectangles) and len(y_coords) == len(rectangles)", "excel-sheet-column-title": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # create a dictionary to map column numbers to their corresponding letters\n        column_dict = {i: chr(65 + i - 1) for i in range(1, 27)}\n        \n        # convert the column number to base 26 and split it into digits\n        digits = []\n        while columnNumber > 0:\n            digits.append(columnNumber % 26)\n            columnNumber //= 26\n        \n        # convert the digits to letters and join them into a string\n        title = ''.join([column_dict[digit] for digit in digits[::-1]])\n        \n        return title", "maximum-subarray": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = float('-inf')\n        curr_sum = 0\n        \n        for num in nums:\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n            curr_sum = max(curr_sum, 0)\n        \n        return max_sum", "sliding-puzzle": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Check if board is valid\n        if not board or not all(len(row) == 3 for row in board) or any(len(row)!= 3 for row in board):\n            return -1\n        \n        # Define helper function to get neighbors of a cell\n        def get_neighbors(cell):\n            row, col = cell\n            neighbors = []\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                r, c = row + dr, col + dc\n                if 0 <= r < 3 and 0 <= c < 3:\n                    neighbors.append((r, c))\n            return neighbors\n        \n        # Define helper function to perform a move on the board\n        def move(board, start, end):\n            row, col = start\n            while board[row][col]!= 0:\n                row += 1\n                col += 1\n            board[row][col], board[end[0]][end[1]] = board[end[0]][end[1]], board[row][col]\n            return board\n        \n        # Define helper function to check if a board is solved\n        def is_solved(board):\n            for i in range(3):\n                if board[i][0]!= i or board[i][1]!= i or board[i][2]!= i:\n                    return False\n            return True\n        \n        # Define queue for BFS\n        queue = [(board, (0, 0))]\n        visited = set([(0, 0)])\n        \n        # Perform BFS\n        while queue:\n            board, curr = queue.pop(0)\n            if is_solved(board):\n                return sum(sum(row) for row in board)\n            for neighbor in get_neighbors(curr):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((move(board, curr, neighbor), neighbor))\n        \n        # If board is not solved, return -1\n        return -1", "isomorphic-strings": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s)!= len(t):\n            return False\n        \n        mapping = {}\n        used = set()\n        \n        for i in range(len(s)):\n            if s[i] not in mapping:\n                if t[i] in used:\n                    return False\n                mapping[s[i]] = t[i]\n                used.add(t[i])\n            elif mapping[s[i]]!= t[i]:\n                return False\n        \n        return True", "search-in-rotated-sorted-array-ii": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            \n            if nums[mid] >= nums[left]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return False", "unique-paths-ii": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1 - obstacleGrid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] * (1 - obstacleGrid[i][0])\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] * (1 - obstacleGrid[0][j])\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i-1][j] * (1 - obstacleGrid[i][j]) + dp[i][j-1] * (1 - obstacleGrid[i][j])\n        \n        return dp[-1][-1]", "decode-ways-ii": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize dp table\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1 if s[0]!= '0' else 0\n        \n        # Fill dp table\n        for i in range(2, len(s) + 1):\n            if s[i-1]!= '0':\n                dp[i] += dp[i-1]\n            if i > 1 and (s[i-2:i] >= '10' and s[i-2:i] <= '26'):\n                dp[i] += dp[i-2]\n        \n        return dp[-1] % (10**9 + 7)", "3sum-closest": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest_sum = float('inf')\n        \n        for i in range(n-2):\n            left = i+1\n            right = n-1\n            \n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(current_sum - target) < abs(closest_sum - target):\n                    closest_sum = current_sum\n                \n                if current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return closest_sum", "maximum-depth-of-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return max(left, right) + 1", "intersection-of-two-arrays-ii": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize a dictionary to store the frequency of each element in nums1\n        freq = {}\n        for num in nums1:\n            freq[num] = freq.get(num, 0) + 1\n        \n        # Initialize a list to store the intersection of nums1 and nums2\n        intersection = []\n        for num in nums2:\n            if num in freq and freq[num] > 0:\n                intersection.append(num)\n                freq[num] -= 1\n        \n        return intersection", "minimum-absolute-difference-in-bst": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(node):\n            if not node:\n                return []\n            return inorder(node.left) + [node.val] + inorder(node.right)\n        \n        inorder_vals = inorder(root)\n        min_diff = float('inf')\n        for i in range(len(inorder_vals)):\n            for j in range(i+1, len(inorder_vals)):\n                diff = abs(inorder_vals[i] - inorder_vals[j])\n                if diff < min_diff:\n                    min_diff = diff\n        return min_diff", "find-mode-in-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(node, freq):\n            if not node:\n                return\n            freq[node.val] = freq.get(node.val, 0) + 1\n            dfs(node.left, freq)\n            dfs(node.right, freq)\n        \n        freq = {}\n        dfs(root, freq)\n        max_freq = max(freq.values())\n        return [k for k, v in freq.items() if v == max_freq]", "find-the-index-of-the-first-occurrence-in-a-string": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if not needle:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1", "strong-password-checker": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # Check if password is already strong\n        if len(password) < 6 or len(password) > 20:\n            return 0\n        \n        # Check if password contains at least one lowercase letter, one uppercase letter, and one digit\n        has_lowercase = False\n        has_uppercase = False\n        has_digit = False\n        for char in password:\n            if char.islower():\n                has_lowercase = True\n            elif char.isupper():\n                has_uppercase = True\n            elif char.isdigit():\n                has_digit = True\n        if not (has_lowercase and has_uppercase and has_digit):\n            return 0\n        \n        # Check if password contains three repeating characters in a row\n        for i in range(len(password)-2):\n            if password[i] == password[i+1] == password[i+2]:\n                return 0\n        \n        # Count the minimum number of steps required to make password strong\n        steps = 0\n        if not has_lowercase:\n            steps += 1\n        if not has_uppercase:\n            steps += 1\n        if not has_digit:\n            steps += 1\n        if has_lowercase and has_uppercase and has_digit:\n            steps += 1\n        \n        return steps", "factorial-trailing-zeroes": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize count to 0\n        count = 0\n        \n        # Divide by 5 until n becomes 0\n        while n >= 5:\n            n //= 5\n            count += n\n        \n        return count", "zigzag-conversion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [''] * numRows\n        row, step = 0, 1\n        \n        for c in s:\n            rows[row] += c\n            if row == 0 or row == numRows - 1:\n                step = -step\n            row += step\n        \n        return ''.join(rows)", "trapping-rain-water": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                left += 1\n                left_max = max(left_max, height[left])\n                water += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                water += right_max - height[right]\n        \n        return water", "find-all-numbers-disappeared-in-an-array": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a set of all numbers from 1 to n\n        n = len(nums)\n        nums_set = set(nums)\n        \n        # create a list of all numbers that appear in the input list\n        disappeared_nums = []\n        for i in range(1, n+1):\n            if i not in nums_set:\n                disappeared_nums.append(i)\n        \n        return disappeared_nums", "count-of-smaller-numbers-after-self": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        counts = [0] * len(nums)\n        stack = []\n        \n        for i in range(len(nums)):\n            while stack and nums[stack[-1]] > nums[i]:\n                counts[stack.pop()] = i\n            stack.append(i)\n        \n        return counts", "set-intersection-size-at-least-two": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort intervals by start time\n        intervals.sort(key=lambda x: x[0])\n        \n        # Initialize variables\n        stack = []\n        max_size = 0\n        \n        # Iterate through intervals\n        for interval in intervals:\n            # If stack is empty or current interval does not overlap with top interval in stack\n            if not stack or interval[0] > stack[-1][1]:\n                stack.append(interval)\n                max_size = max(max_size, len(stack))\n            # If current interval overlaps with top interval in stack\n            else:\n                stack[-1][1] = max(stack[-1][1], interval[1])\n        \n        return max_size", "symmetric-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def is_mirror(node1, node2):\n            if not node1 and not node2:\n                return True\n            if not node1 or not node2:\n                return False\n            return node1.val == node2.val and is_mirror(node1.left, node2.right) and is_mirror(node1.right, node2.left)\n        \n        if not root:\n            return True\n        return is_mirror(root.left, root.right)", "number-of-atoms": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # Create a dictionary to store the count of each element\n        count = {}\n        i = 0\n        while i < len(formula):\n            # If the current character is uppercase, it represents the start of an element name\n            if formula[i].isupper():\n                # Find the end of the element name\n                j = i + 1\n                while j < len(formula) and formula[j].islower():\n                    j += 1\n                # If the element name is not a digit, it is a single uppercase letter element\n                if j == i + 1:\n                    element = formula[i:j]\n                    count[element] = 1\n                # If the element name is a digit, it is a digit element\n                else:\n                    element = formula[i:j]\n                    count[element] = int(formula[j:j+1])\n                i = j\n            # If the current character is lowercase, it represents the continuation of the previous element name\n            else:\n                i += 1\n        \n        # Create a list of tuples sorted by element name\n        elements = sorted(count.items())\n        \n        # Create the output string by iterating through the list of tuples\n        output = \"\"\n        for element, count in elements:\n            output += element\n            if count > 1:\n                output += str(count)\n        \n        return output", "binary-tree-preorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                stack.append(node.left)\n            else:\n                continue\n        return res", "power-of-four": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n > 1:\n            if n % 4!= 0:\n                return False\n            n //= 4\n        return True", "invert-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not root:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root", "generate-parentheses": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(s='', left=0, right=0):\n            if len(s) == 2 * n:\n                res.append(s)\n                return\n            if left < n:\n                backtrack(s + '(', left + 1, right)\n            if right < left:\n                backtrack(s + ')', left, right + 1)\n        \n        res = []\n        backtrack()\n        return res", "patching-array": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 0\n        while i < len(nums):\n            if nums[i] > n:\n                break\n            if nums[i] == n:\n                count += 1\n                break\n            j = i + 1\n            while j < len(nums) and nums[j] + nums[i] <= n:\n                j += 1\n            if j - i > 1:\n                count += 1\n            i = j\n        return count", "longest-valid-parentheses": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = [-1]\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        return max_len", "fraction-to-recurring-decimal": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        sign = \"-\" if numerator * denominator < 0 else \"\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        integer_part = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return sign + str(integer_part)\n        \n        decimal_part = \"\"\n        remainders = {}\n        \n        while remainder!= 0 and remainder not in remainders:\n            remainders[remainder] = len(decimal_part)\n            remainder *= 10\n            \n        start = remainders[remainder]\n        decimal_part += str(integer_part)\n        \n        for i in range(start, len(decimal_part)):\n            decimal_part = decimal_part[:i] + \"(\" + decimal_part[i:] + \")\"\n        \n        return sign + decimal_part\n    \n    def decimalToFraction(self, decimal):\n        \"\"\"\n        :type decimal: str\n        :rtype: str\n        \"\"\"\n        if \".\" not in decimal:\n            return str(int(decimal))\n        \n        integer_part, decimal_part = decimal.split(\".\")\n        decimal_part = decimal_part.lstrip(\"0\")\n        \n        if not decimal_part:\n            return integer_part\n        \n        numerator, denominator = 0, 1\n        \n        for digit in decimal_part:\n            numerator = numerator * 10 + int(digit)\n            denominator *= 10\n        \n        gcd = self.gcd(numerator, denominator)\n        numerator //= gcd\n        denominator //= gcd\n        \n        return f\"{numerator}/{denominator}\"\n    \n    def gcd(self, a, b):\n        \"\"\"\n        :type a: int\n        :type b: int\n        :rtype: int\n        \"\"\"\n        while b:\n            a, b = b, a % b\n        return a\n\nif __name__ == \"", "sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n    \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        curr.next = l1 or l2\n        \n        return dummy.next\n    \n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n# Solution object\n# @param head: The head of the linked list.\n# @return: The head of the sorted linked list.\nobject = Solution()\nhead = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))\n# @param head: The head of the linked list.\n# @return: The head of the sorted linked list.\nhead = object.sortList(head)\n# @param head: The head of the linked list.\n# @return: The head of the sorted linked list.\nhead = object.sortList(head)\n# @param head: The head of the linked list.\n# @return: The head of the sorted linked list.\nhead = object.sortList(head)\n# @param head: The head of the linked list.\n# @return: The head of the sorted linked list.\nhead = object.sortList(head)\n# @param head: The head of the linked list.\n# @return: The head of", "russian-doll-envelopes": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width in ascending order\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Initialize a list to keep track of the maximum number of envelopes that can fit inside each envelope\n        max_envelopes = [1] * len(envelopes)\n        \n        # Iterate through each envelope and check if it can fit inside any of the previous envelopes\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    max_envelopes[i] = max(max_envelopes[i], max_envelopes[j] + 1)\n        \n        # Return the maximum number of envelopes that can fit inside any envelope\n        return max(max_envelopes)", "set-matrix-zeroes": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # M1. Floyd's algorithm\n        if not matrix:\n            return\n        \n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    for k in range(m):\n                        if matrix[k][j]!= 0:\n                            matrix[k][j] = 0\n                    for k in range(n):\n                        if matrix[i][k]!= 0:\n                            matrix[i][k] = 0\n        \n        # M2. Two pass approach\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    for k in range(m):\n                        if matrix[k][j]!= 0:\n                            matrix[k][j] = 0\n                    for k in range(n):\n                        if matrix[i][k]!= 0:\n                            matrix[i][k] = 0\n        \n        # M3. Constant space\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    for k in range(m):\n                        matrix[k][j] = 0\n                    for k in range(n):\n                        if matrix[i][k]!= 0:\n                            matrix[i][k] = 0", "remove-nth-node-from-end-of-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        first = second = dummy\n        \n        for i in range(n):\n            first = first.next\n        \n        while first:\n            first = first.next\n            second = second.next\n        \n        second.next = second.next.next\n        \n        return dummy.next", "intersection-of-two-arrays": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a set of unique elements in nums1\n        set1 = set(nums1)\n        \n        # create a set of unique elements in nums2\n        set2 = set(nums2)\n        \n        # find the intersection of set1 and set2\n        intersection = set1.intersection(set2)\n        \n        # convert the intersection set back to a list and return it\n        return list(intersection)", "super-washing-machines": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        \n        total_moves = 0\n        for i in range(1, n):\n            diff = machines[i] - machines[i-1]\n            if diff < 0:\n                total_moves += abs(diff)\n        \n        if machines[0] == machines[-1]:\n            return total_moves\n        else:\n            return -1", "kth-smallest-number-in-multiplication-table": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the matrix with zeros\n        matrix = [[0 for j in range(n)] for i in range(m)]\n        \n        # Fill the matrix with the multiplication table\n        for i in range(m):\n            for j in range(n):\n                matrix[i][j] = i * j\n        \n        # Flatten the matrix into a list and sort it\n        flat_matrix = [num for row in matrix for num in row]\n        flat_matrix.sort()\n        \n        # Return the kth smallest element\n        return flat_matrix[k - 1]", "convert-sorted-list-to-binary-search-tree": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root", "merge-two-sorted-lists": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1, list2 = list2, list1\n        \n        merged_list = list1\n        while merged_list.next and merged_list.next.val < list2.val:\n            merged_list = merged_list.next\n        \n        merged_list.next = list2\n        list1 = list1.next\n        \n        while list1 and list1.val < merged_list.val:\n            merged_list = merged_list.next\n            list1 = list1.next\n        \n        merged_list.next = list1\n        \n        return merged_list", "maximal-rectangle": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        heights = [0] * len(matrix[0])\n        max_area = 0\n        \n        for row in matrix:\n            for i, height in enumerate(row):\n                if height == \"1\":\n                    heights[i] += 1\n            \n            stack = [-1]\n            for i in range(len(heights)):\n                while stack[-1]!= -1 and heights[stack[-1]] >= heights[i]:\n                    h = heights[stack.pop()]\n                    w = i - stack[-1] - 1\n                    max_area = max(max_area, h * w)\n                stack.append(i)\n            \n            while stack[-1]!= -1:\n                h = heights[stack.pop()]\n                w = len(matrix[0]) - stack[-1] - 1\n                max_area = max(max_area, h * w)\n        \n        return max_area", "subsets": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Base case: if nums is empty, return an empty list\n        if not nums:\n            return [[]]\n        \n        # Recursive case: get all subsets of nums without the first element\n        subsets_without_first = self.subsets(nums[1:])\n        \n        # Add the first element to each subset and add the subset to the result\n        result = [[nums[0]] + subset for subset in subsets_without_first]\n        result.extend(subsets_without_first)\n        \n        return result", "find-minimum-in-rotated-sorted-array-ii": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return nums[left]", "valid-number": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if not s:\n            return False\n        \n        if s[0] in '+-.':\n            s = s[1:]\n        \n        if not s:\n            return False\n        \n        if 'eE' in s or 'e+' in s or 'e-' in s:\n            return True\n        \n        if '.' in s:\n            if 'e' in s:\n                return s.replace('.', '').isdigit()\n            else:\n                return s.replace('.', '') == '0'\n        \n        return s.isdigit()\n    \n    def isNumber_recursive(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if not s:\n            return False\n        \n        if s[0] in '+-.':\n            s = s[1:]\n        \n        if not s:\n            return False\n        \n        if 'eE' in s or 'e+' in s or 'e-' in s:\n            return True\n        \n        if '.' in s:\n            if 'e' in s:\n                return self.isNumber_recursive(s.replace('.', ''))\n            else:\n                return self.isNumber_recursive(s.replace('.', '')) and s[0] in '0123456789'\n        \n        return s.isdigit()", "integer-to-roman": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_numerals = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        result = ''\n        for value, numeral in roman_numerals.items():\n            while num >= value:\n                result += numeral\n                num -= value\n        \n        return result", "find-the-difference": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        for letter in t:\n            if letter not in s:\n                return letter\n            else:\n                s = s.replace(letter, '', 1)\n        return ''", "sudoku-solver": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def is_valid(row, col, num):\n            # check row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n            # check column\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            # check 3x3 box\n            box_row = (row // 3) * 3\n            box_col = (col // 3) * 3\n            for i in range(box_row, box_row + 3):\n                for j in range(box_col, box_col + 3):\n                    if board[i][j] == num:\n                        return False\n            return True\n        \n        def solve():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if is_valid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve():\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        solve()", "recover-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the first node with a swapped value\n        first_node = None\n        stack = [(root, None)]\n        while stack:\n            node, prev_node = stack.pop()\n            if node.val!= prev_node.val:\n                if first_node is None:\n                    first_node = node\n                else:\n                    # Swap the values of the two nodes\n                    node.val, prev_node.val = prev_node.val, node.val\n                    # Move the pointers up the tree to check for swapped values\n                    if node.right:\n                        stack.append((node.right, node))\n                    if node.left:\n                        stack.append((node.left, node))\n        \n        # Recover the tree by swapping the values of the two nodes\n        if first_node:\n            first_node.val, root.val = root.val, first_node.val", "palindrome-linked-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # If the list is empty or has only one node, it is a palindrome\n        if not head or not head.next:\n            return True\n        \n        # Find the middle node of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the list\n        prev = None\n        curr = slow\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # Compare the first half of the list with the reversed second half\n        while prev:\n            if head.val!= prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True\n    \n# if __name__ == '__main__':\n#     s = Solution()\n#     head = ListNode(1, ListNode(2, ListNode(2, ListNode(1))))\n#     print(s.isPalindrome(head))\n#     head = ListNode(1, ListNode(2))\n#     print(s.isPalindrome(head))\n#     head = ListNode(1)\n#     print(s.isPalindrome(head))\n#     head = None\n#     print(s.isPalindrome(head))\n\n#     head = ListNode(1)\n#     print(s.isPalindrome(head))\n#     head = ListNode(2)\n#     print(s.isPalindrome(head))\n#     head = ListNode(1, ListNode(2))\n#     print(s.isPalindrome(head))\n#     head = None\n#     print(s.isPalindrome(head))", "valid-perfect-square": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num < 0:\n            return False\n        elif num == 0 or num == 1:\n            return True\n        else:\n            i = 1\n            while i * i <= num:\n                i += 1\n            return i * i == num", "counting-bits": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # iterative solution\n        ans = [0] * (n+1)\n        for i in range(1, n+1):\n            ans[i] = ans[i & (i-1)] + 1\n        return ans\n        \n        # recursive solution\n        def countBitsHelper(n):\n            if n == 0:\n                return [0]\n            else:\n                return countBitsHelper(n & (n-1)) + [1]\n        return countBitsHelper(n)", "remove-linked-list-elements": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(-1)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return dummy.next", "scramble-string": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1)!= len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        for i in range(1, len(s1)):\n            if sorted(s1[:i]) == sorted(s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n        \n        return False", "simplify-path": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # Split the path into a list of directories\n        dirs = path.split('/')\n        \n        # Initialize the simplified path with the root directory\n        simplified_path = '/'\n        \n        # Iterate over the directories and simplify any consecutive slashes\n        for i in range(len(dirs)):\n            if i == 0:\n                simplified_path += dirs[i]\n            elif dirs[i] == '..':\n                simplified_path = simplified_path[:-1]\n            elif dirs[i] == '.':\n                continue\n            else:\n                simplified_path += '/' + dirs[i]\n        \n        # Add the target file or directory name\n        if len(dirs) == 1:\n            simplified_path += '/' + dirs[0]\n        else:\n            simplified_path += '/' + dirs[-1]\n        \n        return simplified_path", "word-search-ii": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, word):\n            if len(word) > len(longest_word):\n                longest_word.clear()\n                longest_word.extend(word)\n            elif len(word) == len(longest_word):\n                longest_word.extend(word)\n            \n            for x, y in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_i, new_j = i + x, j + y\n                if 0 <= new_i < len(board) and 0 <= new_j < len(board[0]) and (new_i, new_j) not in visited and board[new_i][new_j] == word[len(visited)]:\n                    visited.add((new_i, new_j))\n                    dfs(new_i, new_j, word + board[new_i][new_j])\n                    visited.remove((new_i, new_j))\n        \n        longest_word = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        visited = {(i, j)}\n                        dfs(i, j, word)\n        return list(set(longest_word))", "valid-anagram": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s)!= len(t):\n            return False\n        \n        s_dict = {}\n        for char in s:\n            if char in s_dict:\n                s_dict[char] += 1\n            else:\n                s_dict[char] = 1\n        \n        for char in t:\n            if char in s_dict:\n                s_dict[char] -= 1\n                if s_dict[char] < 0:\n                    return False\n            else:\n                return False\n        \n        return True", "valid-sudoku": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # Check rows\n        for row in board:\n            if len(set(row))!= 9 or '.' in row:\n                return False\n        \n        # Check columns\n        for col in range(9):\n            if len(set([board[row][col] for row in range(9)]))!= 9 or '.' in [board[row][col] for row in range(9)]:\n                return False\n        \n        # Check sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                if len(set([board[row][col] for row in range(i, i+3) for col in range(j, j+3)]))!= 9 or '.' in [board[row][col] for row in range(i, i+3) for col in range(j, j+3)]:\n                    return False\n        \n        return True", "fizz-buzz": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer", "reverse-words-in-a-string": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Convert string to list of words\n        words = s.split()\n        \n        # Reverse the order of the words\n        words.reverse()\n        \n        # Join the words back into a string\n        return''.join(words)", "excel-sheet-column-number": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to map each letter to its corresponding column number\n        letter_to_num = {chr(i+65): i for i in range(26)}\n        \n        # initialize the result to 0\n        result = 0\n        \n        # iterate through each letter in the column title\n        for letter in columnTitle:\n            # add the corresponding column number to the result\n            result = result * 26 + letter_to_num[letter]\n        \n        return result", "candy": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)", "same-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val!= q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)", "reorder-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # Find the middle node\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the list\n        curr = slow\n        prev = None\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # Merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            first.val, first.next.val = first.next.val, first.val\n            first = first.next\n            second = second.next\n        first.val, first.next = first.next, None\n        \n        return head", "word-pattern": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Create a dictionary to store the mapping between pattern and words\n        mapping = {}\n        \n        # Iterate over the pattern and words\n        for i in range(len(pattern)):\n            char = pattern[i]\n            word = words[i]\n            \n            # If the character is not in the mapping, add it with an empty list as its value\n            if char not in mapping:\n                mapping[char] = [word]\n            # If the character is in the mapping, append the word to its list of values\n            else:\n                mapping[char].append(word)\n        \n        # Iterate over the words and check if they match the pattern\n        for word in words:\n            char = pattern[len(word)]\n            if word!= mapping[char][0]:\n                return False\n        \n        return True", "permutations": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [[]]\n        if len(nums) == 1:\n            return [nums]\n        result = []\n        for i in range(len(nums)):\n            remaining = nums[:i] + nums[i+1:]\n            for permutation in self.permute(remaining):\n                result.append([nums[i]] + permutation)\n        return result", "search-a-2d-matrix": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            num = matrix[mid // n][mid % n]\n            \n            if num == target:\n                return True\n            elif num < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False", "add-two-numbers": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        dummy = ListNode(0)\n        curr = dummy\n        \n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n            \n            val = v1 + v2 + carry\n            carry = val // 10\n            val %= 10\n            \n            curr.next = ListNode(val)\n            curr = curr.next\n            \n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        return dummy.next", "number-complement": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert num to binary string\n        binary_str = bin(num)[2:]\n        \n        # count the number of 1's and 0's in binary_str\n        num_ones = binary_str.count('1')\n        num_zeros = binary_str.count('0')\n        \n        # calculate the complement of num\n        complement = '1' * num_ones + '0' * num_zeros\n        \n        # convert the complement back to an integer and return it\n        return int(complement, 2)", "arithmetic-slices-ii-subsequence": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            diff = nums[i+1] - nums[i]\n            for j in range(i+2, len(nums)):\n                if nums[j] - nums[j-1] == diff:\n                    count += 1\n                else:\n                    break\n        return count", "text-justification": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        lines = []\n        current_line = []\n        current_width = 0\n        \n        for word in words:\n            if current_width + len(word) + len(current_line) <= maxWidth:\n                current_line.append(word)\n                current_width += len(word)\n            else:\n                lines.append(current_line)\n                current_line = [word]\n                current_width = len(word)\n        \n        if current_line:\n            lines.append(current_line)\n        \n        justified_lines = []\n        for line in lines:\n            num_spaces = maxWidth - sum(len(word) for word in line)\n            num_gaps = len(line) - 1\n            if num_gaps == 0:\n                justified_lines.append(' '.join(line))\n            else:\n                spaces_per_gap = num_spaces // num_gaps\n                extra_spaces = num_spaces % num_gaps\n                justified_line = ''\n                for i, word in enumerate(line):\n                    justified_line += word\n                    if i < num_gaps:\n                        justified_line +='' * spaces_per_gap\n                        if extra_spaces > 0:\n                            justified_line +=''\n                            extra_spaces -= 1\n                justified_lines.append(justified_line)\n        \n        return justified_lines", "binary-tree-postorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            \n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            res.append(node.val)\n        \n        return res[::-1]", "container-with-most-water": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            width = right - left\n            area = min(height[left], height[right]) * width\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area", "concatenated-words": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set of words for faster lookup\n        word_set = set(words)\n        \n        # create a dictionary to store the concatenated words\n        concat_dict = {}\n        \n        # iterate through each word in the list\n        for word in words:\n            # iterate through each possible split point in the word\n            for i in range(1, len(word)):\n                # check if the split point is within the bounds of the word\n                if i <= len(word):\n                    # get the left and right substrings\n                    left = word[:i]\n                    right = word[i:]\n                    # check if the left and right substrings are in the word set\n                    if left in word_set and right in word_set:\n                        # if they are, add the concatenated word to the dictionary\n                        concat_dict[word] = left + right\n        \n        # return the values of the dictionary as a list\n        return list(concat_dict.values())", "base-7": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        sign = \"-\" if num < 0 else \"\"\n        num = abs(num)\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return sign + res\n    \n    def convertToBase10(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i, digit in enumerate(num[::-1]):\n            res += int(digit) * (7 ** i)\n        \n        return res\n    \n    def convertToBase9(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 9) + res\n            num //= 9\n        \n        return res if res else \"0\"\n    \n    def convertToBase8(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 8) + res\n            num //= 8\n        \n        return res if res else \"0\"\n    \n    def convertToBase16(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 16) + res\n            num //= 16\n        \n        return res if res else \"0\"\n    \n    def convertToBase3(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 3) + res\n            num //= 3\n        \n        return res if res else \"0\"\n    \n    def convertToBase2(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while num > 0:", "nim-game": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # If n is 1 or 2, you can always win\n        if n <= 2:\n            return True\n        \n        # If n is odd, you can always win if you remove the last stone\n        # If you remove the last stone, you will be left with a heap of n-1 stones\n        # If you remove the last stone, you will be left with a heap of n stones\n        # Therefore, you can always win if you remove the last stone and the next player can always win\n        return (n % 4 == 1 or n % 4 == 2)", "n-queens-ii": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 1\n                    count += backtrack(board, row+1)\n                    board[row][col] = 0\n            return count\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):\n                if board[i][j] == 1:\n                    return False\n            for i, j in zip(range(row-1, -1, -1), range(col+1, n)):\n                if board[i][j] == 1:\n                    return False\n            return True\n        \n        board = [[0 for _ in range(n)] for _ in range(n)]\n        return backtrack(board, 0)", "n-queens": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            \n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row+1)\n                    board[row][col] = '.'\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            \n            for i, j in zip(range(row-1, -1, -1), range(col-1, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            \n            for i, j in zip(range(row-1, -1, -1), range(col+1, n)):\n                if board[i][j] == 'Q':\n                    return False\n            \n            return True\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res", "word-search": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j]!= word[k]:\n                return False\n            temp, board[i][j] = board[i][j], '#'\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False", "merge-sorted-array": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # YOUR CODE HERE", "third-maximum-number": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums), reverse=True)\n        if len(nums) < 3:\n            return nums[0] if len(nums) > 0 else None\n        return nums[2]"}