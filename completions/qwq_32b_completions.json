{"spiral-matrix": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return []\n        \n        result = []\n        top = 0\n        bottom = len(matrix) - 1\n        left = 0\n        right = len(matrix[0]) - 1\n        \n        while top <= bottom and left <= right:\n            # Traverse from left to right on the top row\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n            if top > bottom:\n                break\n            \n            # Traverse from top to bottom on the right column\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            if left > right:\n                break\n            \n            # Traverse from right to left on the bottom row\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n            if top > bottom:\n                break\n            \n            # Traverse from bottom to top on the left column\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n        \n        return result\n", "summary-ranges": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        if not nums:\n            return []\n        result = []\n        start = end = nums[0]\n        for num in nums[1:]:\n            if num == end + 1:\n                end = num\n            else:\n                if start == end:\n                    result.append(\"{}\".format(start))\n                else:\n                    result.append(\"{}->{}\".format(start, end))\n                start = end = num\n        # Add the last range\n        if start == end:\n            result.append(\"{}\".format(start))\n        else:\n            result.append(\"{}->{}\".format(start, end))\n        return result\n", "distinct-subsequences": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        m, n = len(t), len(s)\n        dp = [0] * (m + 1)\n        dp[0] = 1  # Base case: empty t can be formed by empty s in 1 way\n        \n        for j in range(n):\n            current_char = s[j]\n            # Iterate backwards to prevent overwriting dp[i-1] before use\n            for i in range(m, 0, -1):\n                if current_char == t[i - 1]:\n                    dp[i] += dp[i - 1]\n        \n        return dp[m]\n", "first-missing-positive": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                # Swap nums[i] to its correct position\n                correct = nums[i] - 1\n                nums[i], nums[correct] = nums[correct], nums[i]\n        \n        # Find the first position where the number is incorrect\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1\n", "permutation-sequence": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        numbers = list(range(1, n + 1))\n        k -= 1  # Convert to zero-based index\n        fact = 1\n        # Compute (n-1)!\n        for i in range(1, n):\n            fact *= i\n        \n        result = []\n        while numbers:\n            m = len(numbers)\n            index = k // fact\n            result.append(str(numbers[index]))\n            # Remove the selected number\n            numbers.pop(index)\n            k %= fact\n            # Update factorial for next step if possible\n            if m > 1:\n                fact = fact // (m - 1)\n        \n        return ''.join(result)\n", "two-sum-ii-input-array-is-sorted": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left = 0\n        right = len(numbers) - 1\n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return []  # This line is theoretically unreachable as per problem constraints\n", "expression-add-operators": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        \n        def backtrack(start, path, current_val, prev_num):\n            if start == len(num):\n                if current_val == target:\n                    result.append(path)\n                return\n            \n            for end in range(start + 1, len(num) + 1):\n                if end > start + 1 and num[start] == '0':\n                    break  # Skip leading zeros unless it's a single '0'\n                \n                s = num[start:end]\n                current_num = int(s)\n                \n                if start == 0:\n                    # First number, no operator before it\n                    backtrack(end, s, current_num, current_num)\n                else:\n                    # Try all three operators\n                    # Addition\n                    backtrack(end, path + '+' + s, current_val + current_num, current_num)\n                    # Subtraction\n                    backtrack(end, path + '-' + s, current_val - current_num, -current_num)\n                    # Multiplication\n                    new_val = current_val - prev_num + (prev_num * current_num)\n                    new_prev = prev_num * current_num\n                    backtrack(end, path + '*' + s, new_val, new_prev)\n        \n        backtrack(0, \"\", 0, 0)\n        return result\n", "sum-root-to-leaf-numbers": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        return self.dfs(root, 0)\n    \n    def dfs(self, node, current_sum):\n        current_sum = current_sum * 10 + node.val\n        if not node.left and not node.right:  # leaf node\n            return current_sum\n        total = 0\n        if node.left:\n            total += self.dfs(node.left, current_sum)\n        if node.right:\n            total += self.dfs(node.right, current_sum)\n        return total\n", "license-key-formatting": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        cleaned = s.replace('-', '').upper()\n        if not cleaned:\n            return ''\n        groups = []\n        while cleaned:\n            group = cleaned[-k:]\n            groups.append(group)\n            cleaned = cleaned[:-k]\n        groups.reverse()\n        return '-'.join(groups)\n", "gas-station": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(gas)\n        total_surplus = 0\n        current_tank = 0\n        start = 0\n        \n        for i in range(n):\n            diff = gas[i] - cost[i]\n            total_surplus += diff\n            current_tank += diff\n            if current_tank < 0:\n                start = i + 1\n                current_tank = 0\n        \n        return start if total_surplus >= 0 else -1\n", "burst-balloons": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        new_nums = [1] + nums + [1]\n        size = n + 2\n        dp = [[0] * size for _ in range(size)]\n        \n        for length in range(1, n + 1):\n            for i in range(1, n - length + 2):\n                j = i + length - 1\n                for k in range(i, j + 1):\n                    current = dp[i][k-1] + dp[k+1][j] + new_nums[i-1] * new_nums[k] * new_nums[j+1]\n                    if current > dp[i][j]:\n                        dp[i][j] = current\n        return dp[1][n]\n", "plus-one": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        carry = 1\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            current_sum = digits[i] + carry\n            digits[i] = current_sum % 10\n            carry = current_sum // 10\n            if carry == 0:\n                break\n        if carry == 1:\n            digits.insert(0, 1)\n        return digits\n", "regular-expression-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s, len_p = len(s), len(p)\n        dp = [[False] * (len_p + 1) for _ in range(len_s + 1)]\n        dp[0][0] = True  # Empty string matches empty pattern\n        \n        # Handle the first row (s is empty)\n        for j in range(1, len_p + 1):\n            if p[j-1] == '*':\n                # Check if we can ignore the previous character and '*'\n                dp[0][j] = dp[0][j-2]\n            else:\n                dp[0][j] = False  # No way to match non-* without s\n        \n        for i in range(1, len_s + 1):\n            for j in range(1, len_p + 1):\n                if p[j-1] != '*':\n                    # Current characters must match, and previous state must be True\n                    if p[j-1] == s[i-1] or p[j-1] == '.':\n                        dp[i][j] = dp[i-1][j-1]\n                    else:\n                        dp[i][j] = False\n                else:\n                    # Handle the '*' case\n                    prev_char = p[j-2]\n                    # Option 1: Zero occurrences of the preceding character\n                    option1 = dp[i][j-2]\n                    # Option 2: One or more occurrences (must match current s character)\n                    match = (s[i-1] == prev_char) or (prev_char == '.')\n                    option2 = match and dp[i-1][j]\n                    dp[i][j] = option1 or option2\n        \n        return dp[len_s][len_p]\n", "create-maximum-number": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def max_subseq(nums, l):\n            if l == 0:\n                return []\n            res = []\n            n = len(nums)\n            to_remove = n - l\n            for num in nums:\n                while res and num > res[-1] and to_remove > 0:\n                    res.pop()\n                    to_remove -= 1\n                res.append(num)\n            # Truncate to the required length in case there are remaining to_remove (though it should be handled)\n            return res[:l]\n        \n        def merge(A, B):\n            merged = []\n            a = b = 0\n            while a < len(A) or b < len(B):\n                if a < len(A) and (b >= len(B) or A[a] > B[b]):\n                    merged.append(A[a])\n                    a += 1\n                elif b < len(B) and (a >= len(A) or B[b] > A[a]):\n                    merged.append(B[b])\n                    b += 1\n                else:\n                    # A[a] == B[b], need to decide which path is better\n                    if A[a:] >= B[b:]:\n                        merged.append(A[a])\n                        a += 1\n                    else:\n                        merged.append(B[b])\n                        b += 1\n            return merged\n        \n        m, n = len(nums1), len(nums2)\n        max_num = None\n        for i in range(0, k + 1):\n            if i > m or (k - i) > n:\n                continue\n            sub1 = max_subseq(nums1, i)\n            sub2 = max_subseq(nums2, k - i)\n            candidate = merge(sub1, sub2)\n            if (max_num is None) or (candidate > max_num):\n                max_num = candidate\n        return max_num\n", "perfect-number": "import math\n\nclass Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 1:\n            return False\n        \n        sum_div = 1  # 1 is a proper divisor\n        \n        sqrt_n = int(math.sqrt(num))\n        for i in range(2, sqrt_n + 1):\n            if num % i == 0:\n                sum_div += i\n                other = num // i\n                if other != i:\n                    sum_div += other\n        \n        return sum_div == num\n", "fibonacci-number": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        a, b = 0, 1\n        for i in range(2, n + 1):\n            current = a + b\n            a = b\n            b = current\n        return b\n", "dungeon-game": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        # Initialize the bottom-right corner\n        dp[m-1][n-1] = max(1 - dungeon[m-1][n-1], 1)\n        \n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if i == m-1 and j == n-1:\n                    continue  # already initialized\n                elif i == m-1:  # last row\n                    dp[i][j] = max(dp[i][j+1] - dungeon[i][j], 1)\n                elif j == n-1:  # last column\n                    dp[i][j] = max(dp[i+1][j] - dungeon[i][j], 1)\n                else:\n                    min_next = min(dp[i+1][j], dp[i][j+1])\n                    dp[i][j] = max(min_next - dungeon[i][j], 1)\n        \n        return dp[0][0]\n", "find-k-th-smallest-pair-distance": "import bisect\n\nclass Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        left = 0\n        right = nums[-1] - nums[0]\n        \n        def count_pairs(d):\n            count = 0\n            for i in range(n):\n                target = nums[i] + d\n                j = bisect.bisect_right(nums, target)\n                # The number of valid j's for this i is (j - 1 - i), but must be >= 0\n                count += max(0, j - 1 - i)\n            return count\n        \n        while left < right:\n            mid = (left + right) // 2\n            cnt = count_pairs(mid)\n            if cnt < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "number-of-segments-in-a-string": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n", "reverse-vowels-of-a-string": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels_set = set('aeiouAEIOU')\n        vowels = [c for c in s if c in vowels_set]\n        reversed_vowels = vowels[::-1]\n        \n        s_list = list(s)\n        index = 0\n        \n        for i in range(len(s_list)):\n            if s_list[i] in vowels_set:\n                s_list[i] = reversed_vowels[index]\n                index += 1\n        \n        return ''.join(s_list)\n", "longest-consecutive-sequence": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        num_set = set(nums)\n        max_length = 0\n\n        for num in num_set:\n            # Check if it's the start of a sequence\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n\n                max_length = max(max_length, current_streak)\n\n        return max_length\n", "missing-number": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        expected = n * (n + 1) // 2\n        return expected - sum(nums)\n", "word-ladder": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        if endWord not in wordList:\n            return 0\n        \n        L = len(beginWord)\n        from collections import defaultdict, deque\n        \n        # Build the pattern map\n        pattern_map = defaultdict(list)\n        for word in wordList:\n            for i in range(L):\n                pattern = word[:i] + '*' + word[i+1:]\n                pattern_map[pattern].append(word)\n        \n        # BFS setup\n        visited = set()\n        queue = deque()\n        queue.append((beginWord, 1))\n        visited.add(beginWord)\n        \n        while queue:\n            current_word, level = queue.popleft()\n            \n            if current_word == endWord:\n                return level\n            \n            for i in range(L):\n                # Generate current pattern\n                pattern = current_word[:i] + '*' + current_word[i+1:]\n                # Explore all words with this pattern\n                for neighbor in pattern_map.get(pattern, []):\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, level + 1))\n        \n        # If no path found\n        return 0\n", "add-binary": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        i = len(a) - 1\n        j = len(b) - 1\n        carry = 0\n        result = []\n        \n        while i >= 0 or j >= 0 or carry > 0:\n            current_a = int(a[i]) if i >= 0 else 0\n            current_b = int(b[j]) if j >= 0 else 0\n            \n            total = current_a + current_b + carry\n            sum_bit = total % 2\n            carry = total // 2\n            \n            result.append(sum_bit)\n            \n            i -= 1\n            j -= 1\n        \n        # Reverse the result and convert to string\n        return ''.join(str(d) for d in reversed(result))\n", "find-first-and-last-position-of-element-in-sorted-array": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left = self.find_left(nums, target)\n        if left == -1:\n            return [-1, -1]\n        right = self.find_right(nums, target)\n        return [left, right]\n    \n    def find_left(self, nums, target):\n        low = 0\n        high = len(nums) - 1\n        res = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                res = mid\n                high = mid - 1  # Continue searching left\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return res\n    \n    def find_right(self, nums, target):\n        low = 0\n        high = len(nums) - 1\n        res = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                res = mid\n                low = mid + 1   # Continue searching right\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return res\n", "remove-duplicates-from-sorted-array": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0  # As per constraints, this case might not be necessary\n        \n        write_index = 0\n        for read_index in range(1, len(nums)):\n            if nums[read_index] != nums[write_index]:\n                write_index += 1\n                nums[write_index] = nums[read_index]\n        \n        return write_index + 1\n", "jump-game-ii": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n == 1:\n            return 0\n        jumps = 0\n        current_end = 0\n        farthest = 0\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])\n            if i == current_end:\n                jumps += 1\n                current_end = farthest\n        return jumps\n", "best-time-to-buy-and-sell-stock-iv": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(prices)\n        if n < 2 or k == 0:\n            return 0\n        if k >= n // 2:\n            # Handle as unlimited transactions\n            total = 0\n            for i in range(1, n):\n                if prices[i] > prices[i-1]:\n                    total += prices[i] - prices[i-1]\n            return total\n        else:\n            buy = [-float('inf')] * (k + 1)\n            sell = [0] * (k + 1)\n            for price in prices:\n                for i in range(k, 0, -1):\n                    buy[i] = max(buy[i], sell[i-1] - price)\n                    sell[i] = max(sell[i], buy[i] + price)\n            return sell[k]\n", "convert-a-number-to-hexadecimal": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num += 2 ** 32  # Convert to 32-bit two's complement positive equivalent\n        \n        hex_map = '0123456789abcdef'\n        hex_digits = []\n        \n        while num > 0:\n            remainder = num % 16\n            hex_digits.append(remainder)\n            num = num // 16\n        \n        # Reverse the digits to get the correct order and build the string\n        hex_str = []\n        for d in reversed(hex_digits):\n            hex_str.append(hex_map[d])\n        \n        return ''.join(hex_str)\n", "first-unique-character-in-a-string": "from collections import Counter\n\nclass Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        count = Counter(s)\n        for index, char in enumerate(s):\n            if count[char] == 1:\n                return index\n        return -1\n", "contains-duplicate-iii": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        if indexDiff < 0 or valueDiff < 0:\n            return False\n        \n        buckets = {}\n        bucket_size = valueDiff + 1  # Size of each bucket\n        \n        for i in range(len(nums)):\n            num = nums[i]\n            bucket_id = num // bucket_size\n            \n            # Check current bucket\n            if bucket_id in buckets:\n                return True\n            \n            # Check adjacent buckets\n            if (bucket_id - 1) in buckets:\n                if abs(num - buckets[bucket_id - 1]) <= valueDiff:\n                    return True\n            if (bucket_id + 1) in buckets:\n                if abs(num - buckets[bucket_id + 1]) <= valueDiff:\n                    return True\n            \n            # Add current number to the bucket\n            buckets[bucket_id] = num\n            \n            # Remove the element that is out of the window\n            if i >= indexDiff:\n                old_num = nums[i - indexDiff]\n                old_bucket_id = old_num // bucket_size\n                del buckets[old_bucket_id]\n        \n        return False\n", "sort-colors": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low = 0\n        high = len(nums) - 1\n        mid = 0\n        \n        while mid <= high:\n            if nums[mid] == 1:\n                mid += 1\n            elif nums[mid] == 2:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n            else:  # nums[mid] == 0\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n", "max-consecutive-ones": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_count = 0\n        current_count = 0\n        for num in nums:\n            if num == 1:\n                current_count += 1\n            else:\n                max_count = max(max_count, current_count)\n                current_count = 0\n        max_count = max(max_count, current_count)\n        return max_count\n", "count-complete-tree-nodes": "class Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        h = self.get_height(root)\n        if h == 0:\n            return 1  # Only the root node exists\n        \n        low, high = 0, (2 ** h) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if self.exists(root, mid, h):\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return (2 ** h - 1) + low\n    \n    def get_height(self, node):\n        h = 0\n        while node:\n            h += 1\n            node = node.left\n        return h - 1  # Returns the number of edges (height)\n    \n    def exists(self, node, mid, h):\n        # Check if the node at position 'mid' in the last level exists\n        for i in range(h):\n            bit = (mid >> (h - 1 - i)) & 1\n            if bit:\n                node = node.right\n            else:\n                node = node.left\n            if not node:\n                return False\n        return True\n", "add-strings": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        result = []\n        \n        while i >= 0 or j >= 0 or carry > 0:\n            digit1 = int(num1[i]) if i >= 0 else 0\n            digit2 = int(num2[j]) if j >= 0 else 0\n            \n            total = digit1 + digit2 + carry\n            carry = total // 10\n            digit = total % 10\n            result.append(str(digit))\n            \n            i -= 1\n            j -= 1\n        \n        # Reverse to get the correct order and form the string\n        s = ''.join(reversed(result))\n        return s.lstrip('0') or '0'\n", "basic-calculator": "class Solution(object):\n    def calculate(self, s):\n        stack = []\n        result = 0\n        number = 0\n        sign = 1  # 1 for positive, -1 for negative\n        \n        for c in s:\n            if c == ' ':\n                continue\n            elif c.isdigit():\n                number = number * 10 + int(c)\n            elif c == '+':\n                result += sign * number\n                number = 0\n                sign = 1\n            elif c == '-':\n                result += sign * number\n                number = 0\n                sign = -1\n            elif c == '(':\n                stack.append((result, sign))\n                result = 0\n                sign = 1\n            elif c == ')':\n                # Add the current number to the result inside the parentheses\n                result += sign * number\n                number = 0\n                # Pop the previous result and sign\n                prev_result, prev_sign = stack.pop()\n                # Combine the current result with the previous result using the stored sign\n                result = prev_result + prev_sign * result\n                sign = 1  # Reset sign to 1 after closing the parenthesis\n        \n        # Add the last number\n        result += sign * number\n        \n        return result\n", "ipo": "import heapq\n\nclass Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        # Pair each project's capital requirement with its profit and sort by capital\n        projects = sorted(zip(capital, profits), key=lambda x: x[0])\n        max_heap = []\n        i = 0\n        n = len(projects)\n        \n        for _ in range(k):\n            # Add all projects that can be started with current capital\n            while i < n and projects[i][0] <= w:\n                heapq.heappush(max_heap, -projects[i][1])  # Use negative to simulate max-heap\n                i += 1\n            # If no projects can be started, break early\n            if not max_heap:\n                break\n            # Select the project with the highest profit\n            w += -heapq.heappop(max_heap)\n        \n        return w\n", "valid-parentheses": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        closing_to_opening = {')': '(', '}': '{', ']': '['}\n        stack = []\n        for char in s:\n            if char in closing_to_opening:\n                if not stack:\n                    return False\n                if stack.pop() != closing_to_opening[char]:\n                    return False\n            else:\n                stack.append(char)\n        return not stack\n", "next-permutation": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        # Step 1: Find the largest index k such that nums[k] < nums[k+1]\n        k = n - 2\n        while k >= 0 and nums[k] >= nums[k + 1]:\n            k -= 1\n        \n        # Step 2: Find the largest index l > k such that nums[l] > nums[k]\n        if k >= 0:\n            l = n - 1\n            while nums[l] <= nums[k]:\n                l -= 1\n            # Swap nums[k] and nums[l]\n            nums[k], nums[l] = nums[l], nums[k]\n        \n        # Step 3: Reverse the suffix starting at k+1\n        start = k + 1\n        end = n - 1\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n", "contains-duplicate-ii": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        num_dict = {}\n        for i, num in enumerate(nums):\n            if num in num_dict and i - num_dict[num] <= k:\n                return True\n            num_dict[num] = i\n        return False\n", "maximum-gap": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 2:\n            return 0\n        min_val = min(nums)\n        max_val = max(nums)\n        if min_val == max_val:\n            return 0\n        interval = (max_val - min_val) / float(n)\n        buckets = [None] * n\n        for num in nums:\n            idx = int((num - min_val) // interval)\n            if idx >= n:\n                idx = n - 1\n            if buckets[idx] is None:\n                buckets[idx] = {'min': num, 'max': num}\n            else:\n                if num < buckets[idx]['min']:\n                    buckets[idx]['min'] = num\n                if num > buckets[idx]['max']:\n                    buckets[idx]['max'] = num\n        max_gap = 0\n        prev_max = min_val\n        for bucket in buckets:\n            if bucket is not None:\n                current_min = bucket['min']\n                gap = current_min - prev_max\n                if gap > max_gap:\n                    max_gap = gap\n                prev_max = bucket['max']\n        return max_gap\n", "binary-tree-level-order-traversal": "from collections import deque\n\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(current_level)\n        \n        return result\n", "couples-holding-hands": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(row)\n        pos = {v: i for i, v in enumerate(row)}\n        swaps = 0\n        \n        for i in range(0, n, 2):\n            current = row[i]\n            partner = current ^ 1  # Find the partner using XOR\n            \n            if row[i + 1] == partner:\n                continue  # Already paired correctly\n            \n            # Find the current position of the partner\n            j = pos[partner]\n            \n            # Update positions in the dictionary before swapping\n            pos[row[i + 1]] = j  # The element at row[i+1] moves to j's original position\n            pos[partner] = i + 1  # The partner moves to i+1\n            \n            # Perform the swap in the row array\n            row[i + 1], row[j] = row[j], row[i + 1]\n            swaps += 1\n        \n        return swaps\n", "interleaving-string": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def helper(i: int, j: int, turn: str) -> bool:\n            if i == len(s1) and j == len(s2):\n                return True\n            if i > len(s1) or j > len(s2):\n                return False\n\n            if turn == 's1':\n                max_take = len(s1) - i\n                for L in range(1, max_take + 1):\n                    if s1[i:i+L] == s3[i + j : i + j + L]:\n                        if helper(i + L, j, 's2'):\n                            return True\n                return False\n            else:  # turn == 's2'\n                max_take = len(s2) - j\n                for L in range(1, max_take + 1):\n                    if s2[j:j+L] == s3[i + j : i + j + L]:\n                        if helper(i, j + L, 's1'):\n                            return True\n                return False\n\n        return helper(0, 0, 's1') or helper(0, 0, 's2')\n", "assign-cookies": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i\n", "keyboard-row": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        result = []\n        \n        for word in words:\n            lower_word = word.lower()\n            if all(c in row1 for c in lower_word):\n                result.append(word)\n            elif all(c in row2 for c in lower_word):\n                result.append(word)\n            elif all(c in row3 for c in lower_word):\n                result.append(word)\n        \n        return result\n", "reverse-linked-list-ii": "class Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev_node = dummy\n        \n        # Move to the node before the left position\n        for _ in range(left - 1):\n            prev_node = prev_node.next\n        \n        current_node = prev_node.next\n        \n        # Reverse the sublist from left to right\n        for _ in range(right - left):\n            next_node = current_node.next\n            current_node.next = next_node.next\n            next_node.next = prev_node.next\n            prev_node.next = next_node\n        \n        return dummy.next\n", "shortest-palindrome": "class Solution(object):\n    def shortestPalindrome(self, s):\n        reversed_s = s[::-1]\n        combined = s + '#' + reversed_s\n        lps = self.compute_lps(combined)\n        l = lps[-1]\n        return reversed_s[:len(s) - l] + s\n\n    def compute_lps(self, s):\n        n = len(s)\n        lps = [0] * n\n        len_lps = 0  # current length of the previous longest prefix suffix\n\n        for i in range(1, n):\n            while len_lps > 0 and s[i] != s[len_lps]:\n                len_lps = lps[len_lps - 1]\n            \n            if s[i] == s[len_lps]:\n                len_lps += 1\n                lps[i] = len_lps\n            else:\n                lps[i] = 0\n        \n        return lps\n", "minimum-window-substring": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        from collections import defaultdict\n\n        # Create the required character frequency map\n        required = {}\n        for char in t:\n            required[char] = required.get(char, 0) + 1\n\n        required_count = len(required)  # Number of unique characters needed\n        current_counts = {}\n\n        left = 0\n        formed = 0  # Number of unique required characters met\n\n        min_length = float('inf')\n        result_left = 0\n        result_right = 0\n\n        for right in range(len(s)):\n            char = s[right]\n\n            if char in required:\n                current_counts[char] = current_counts.get(char, 0) + 1\n\n                # Check if this character's count matches the required count\n                if current_counts[char] == required[char]:\n                    formed += 1\n\n            # Try to contract the window as much as possible while it is still valid\n            while formed == required_count and left <= right:\n                # Update the minimum window if the current is smaller\n                current_window_length = right - left + 1\n                if current_window_length < min_length:\n                    min_length = current_window_length\n                    result_left = left\n                    result_right = right\n\n                # Move the left pointer to the right\n                left_char = s[left]\n                if left_char in required:\n                    current_counts[left_char] -= 1\n                    # If this causes the count to drop below required, decrement formed\n                    if current_counts[left_char] < required[left_char]:\n                        formed -= 1\n                left += 1\n\n        if min_length == float('inf'):\n            return \"\"\n        else:\n            return s[result_left:result_right + 1]\n", "self-crossing": "class Solution:\n    def isSelfCrossing(self, distance):\n        n = len(distance)\n        for i in range(3, n):\n            # Check condition1: crossing with i-3 line\n            if distance[i] >= distance[i-3] and distance[i-1] <= distance[i-2]:\n                return True\n            # Check condition2: crossing with i-4 line\n            if i >= 4 and distance[i-1] == distance[i-3] and distance[i] >= distance[i-4] and distance[i-2] > distance[i-4]:\n                return True\n            # Check condition3: crossing with i-5 line\n            if i >= 5 and distance[i-2] > distance[i-4] and distance[i-3] > distance[i-1] and (distance[i] + distance[i-4] >= distance[i-2]) and (distance[i-1] + distance[i-5] >= distance[i-3]):\n                return True\n        return False\n", "remove-duplicates-from-sorted-list": "class Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        current = head\n        while current and current.next:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        return head\n", "longest-palindrome": "from collections import Counter\n\nclass Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        counts = Counter(s)\n        result = 0\n        has_odd = False\n        for c in counts.values():\n            if c % 2 == 0:\n                result += c\n            else:\n                result += c - 1\n                has_odd = True\n        if has_odd:\n            result += 1\n        return result\n", "construct-binary-tree-from-inorder-and-postorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not inorder:\n            return None\n        \n        inorder_map = {val: idx for idx, val in enumerate(inorder)}\n        \n        def build(in_start, in_end, post_start, post_end):\n            if in_start > in_end:\n                return None\n            root_val = postorder[post_end]\n            root = TreeNode(root_val)\n            root_idx = inorder_map[root_val]\n            \n            left_size = root_idx - in_start\n            right_size = in_end - root_idx\n            \n            root.left = build(in_start, root_idx - 1, post_start, post_start + left_size - 1)\n            root.right = build(root_idx + 1, in_end, post_start + left_size, post_end - 1)\n            \n            return root\n        \n        return build(0, len(inorder)-1, 0, len(postorder)-1)\n", "cut-off-trees-for-golf-event": "from collections import deque\n\nclass Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        \n        trees.sort()\n        positions = [(x[1], x[2]) for x in trees]\n        \n        total = 0\n        current = (0, 0)\n        \n        for pos in positions:\n            steps = self.bfs(forest, current, pos)\n            if steps == -1:\n                return -1\n            total += steps\n            current = pos\n        \n        return total\n    \n    def bfs(self, forest, start, end):\n        m = len(forest)\n        if m == 0:\n            return -1\n        n = len(forest[0])\n        sr, sc = start\n        er, ec = end\n        \n        # Check if start or end cells are blocked (0)\n        if forest[sr][sc] == 0 or forest[er][ec] == 0:\n            return -1\n        \n        if sr == er and sc == ec:\n            return 0\n        \n        visited = [[False for _ in range(n)] for _ in range(m)]\n        q = deque()\n        q.append((sr, sc, 0))\n        visited[sr][sc] = True\n        \n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        while q:\n            r, c, steps = q.popleft()\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and forest[nr][nc] != 0:\n                    if nr == er and nc == ec:\n                        return steps + 1\n                    visited[nr][nc] = True\n                    q.append((nr, nc, steps + 1))\n        \n        return -1\n", "minimum-depth-of-binary-tree": "from collections import deque\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        queue = deque([root])\n        depth = 0\n        \n        while queue:\n            depth += 1\n            level_size = len(queue)\n            for _ in range(level_size):\n                node = queue.popleft()\n                # Check if this node is a leaf\n                if not node.left and not node.right:\n                    return depth\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        \n        return depth  # This return is theoretically unreachable\n", "count-of-range-sum": "import bisect\n\nclass Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        # Compute prefix sums\n        pre_sum = [0]\n        for num in nums:\n            pre_sum.append(pre_sum[-1] + num)\n        \n        return self.merge_sort_count(pre_sum, 0, len(pre_sum) - 1, lower, upper)\n    \n    def merge_sort_count(self, pre_sum, start, end, lower, upper):\n        if start >= end:\n            return 0\n        \n        mid = (start + end) // 2\n        count = self.merge_sort_count(pre_sum, start, mid, lower, upper) + \\\n                self.merge_sort_count(pre_sum, mid + 1, end, lower, upper)\n        \n        # Compute cross count\n        cross = 0\n        for j in range(mid + 1, end + 1):\n            r = pre_sum[j]\n            target_min = r - upper\n            target_max = r - lower\n            # Find left and right indices in the left half (start to mid)\n            l_ptr = bisect.bisect_left(pre_sum, target_min, start, mid + 1)\n            r_ptr = bisect.bisect_right(pre_sum, target_max, start, mid + 1)\n            cross += (r_ptr - l_ptr)\n        \n        count += cross\n        \n        # Merge the two halves into a sorted array\n        i = start\n        j = mid + 1\n        merged = []\n        while i <= mid and j <= end:\n            if pre_sum[i] <= pre_sum[j]:\n                merged.append(pre_sum[i])\n                i += 1\n            else:\n                merged.append(pre_sum[j])\n                j += 1\n        while i <= mid:\n            merged.append(pre_sum[i])\n            i += 1\n        while j <= end:\n            merged.append(pre_sum[j])\n            j += 1\n        \n        # Copy back the merged array to pre_sum\n        for idx in range(len(merged)):\n            pre_sum[start + idx] = merged[idx]\n        \n        return count\n", "arranging-coins": "import math\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        sqrt_val = (1 + 8 * n) ** 0.5\n        k = (sqrt_val - 1) // 2\n        return int(k)\n", "longest-uncommon-subsequence-i": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))\n", "binary-tree-level-order-traversal-ii": "from collections import deque\n\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        queue = deque([root])\n        result = []\n        while queue:\n            level_size = len(queue)\n            current_level = []\n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(current_level)\n        return result[::-1]\n", "palindrome-number": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        if x < 0:\n            return False\n        if x == 0:\n            return True\n        if x % 10 == 0:\n            return False\n        \n        reversed_num = 0\n        while x > reversed_num:\n            reversed_num = reversed_num * 10 + x % 10\n            x = x // 10\n        \n        return x == reversed_num or x == reversed_num // 10\n", "decode-ways": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1  # empty string\n        \n        # Initialize for first character\n        if s[0] == '0':\n            dp[1] = 0\n        else:\n            dp[1] = 1\n        \n        for i in range(2, n + 1):\n            # Check single digit\n            current_char = s[i-1]\n            if current_char != '0':\n                dp[i] += dp[i-1]\n            \n            # Check two digits\n            two_digit = s[i-2:i]\n            two_digit_num = int(two_digit)\n            if 10 <= two_digit_num <= 26:\n                dp[i] += dp[i-2]\n        \n        return dp[n]\n", "is-subsequence": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        i = 0  # pointer for s\n        j = 0  # pointer for t\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)\n", "gray-code": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        return [i ^ (i >> 1) for i in range(2 ** n)]\n", "climbing-stairs": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        prev, current = 1, 1\n        for i in range(2, n + 1):\n            next_step = prev + current\n            prev = current\n            current = next_step\n        return current\n", "word-break": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        word_set = set(wordDict)\n        max_len = max(len(word) for word in wordDict) if wordDict else 0\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True  # Empty string is reachable\n        \n        for i in range(1, n + 1):\n            # Check all possible word lengths up to max_len\n            for l in range(1, max_len + 1):\n                if i - l >= 0:\n                    if dp[i - l] and s[i - l:i] in word_set:\n                        dp[i] = True\n                        break  # No need to check further lengths for this i\n        return dp[n]\n", "validate-binary-search-tree": "class Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True  # According to constraints, this case won't occur\n        \n        stack = [(root, float('-inf'), float('inf'))]\n        \n        while stack:\n            node, low, high = stack.pop()\n            if node.val <= low or node.val >= high:\n                return False\n            if node.right:\n                stack.append((node.right, node.val, high))\n            if node.left:\n                stack.append((node.left, low, node.val))\n        return True\n", "insert-interval": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        added = False\n        for interval in intervals:\n            if interval[1] < newInterval[0]:\n                # Current interval ends before new starts; add to result\n                result.append(interval)\n            elif interval[0] > newInterval[1]:\n                # Current interval starts after new ends; add new and current\n                if not added:\n                    result.append(newInterval)\n                    added = True\n                result.append(interval)\n            else:\n                # Overlap exists; merge intervals\n                newInterval[0] = min(newInterval[0], interval[0])\n                newInterval[1] = max(newInterval[1], interval[1])\n        # Add the newInterval if not added yet\n        if not added:\n            result.append(newInterval)\n        return result\n", "palindrome-partitioning": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        res = []\n        self.backtrack(s, 0, [], res)\n        return res\n\n    def backtrack(self, s, start, path, res):\n        if start == len(s):\n            res.append(list(path))\n            return\n        for end in range(start, len(s)):\n            substr = s[start:end+1]\n            if substr == substr[::-1]:\n                path.append(substr)\n                self.backtrack(s, end + 1, path, res)\n                path.pop()\n", "smallest-range-covering-elements-from-k-lists": "import heapq\n\nclass Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        heap = []\n        current_max = -float('inf')\n        for i in range(len(nums)):\n            val = nums[i][0]\n            heapq.heappush(heap, (val, i, 0))\n            if val > current_max:\n                current_max = val\n        \n        best_start = heap[0][0]\n        best_end = current_max\n        best_length = current_max - best_start\n        \n        while True:\n            current_min = heap[0][0]\n            current_range_length = current_max - current_min\n            \n            # Update the best range if current is better\n            if (current_range_length < best_length) or \\\n               (current_range_length == best_length and current_min < best_start):\n                best_start = current_min\n                best_end = current_max\n                best_length = current_range_length\n            \n            # Extract the current minimum element\n            current_min_element = heapq.heappop(heap)\n            list_idx = current_min_element[1]\n            element_idx = current_min_element[2]\n            \n            # Check if there is a next element in the same list\n            if element_idx + 1 < len(nums[list_idx]):\n                new_val = nums[list_idx][element_idx + 1]\n                heapq.heappush(heap, (new_val, list_idx, element_idx + 1))\n                if new_val > current_max:\n                    current_max = new_val\n            else:\n                # Cannot proceed further as this list is exhausted\n                break\n        \n        return [best_start, best_end]\n", "poor-pigs": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        if buckets == 1:\n            return 0\n        t = minutesToTest // minutesToDie\n        base = t + 1\n        n = 0\n        current = 1\n        while current < buckets:\n            current *= base\n            n += 1\n        return n\n", "swim-in-rising-water": "import heapq\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        if n == 0:\n            return 0\n        \n        # Initialize distance matrix with infinity\n        dist = [[float('inf')] * n for _ in range(n)]\n        dist[0][0] = grid[0][0]\n        \n        # Priority queue: (current_max, x, y)\n        heap = []\n        heapq.heappush(heap, (grid[0][0], 0, 0))\n        \n        # Directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        while heap:\n            current_max, x, y = heapq.heappop(heap)\n            \n            # Check if we reached the destination\n            if x == n - 1 and y == n - 1:\n                return current_max\n            \n            # Skip if a better path has already been found\n            if current_max > dist[x][y]:\n                continue\n            \n            for dx, dy in directions:\n                nx = x + dx\n                ny = y + dy\n                if 0 <= nx < n and 0 <= ny < n:\n                    new_max = max(current_max, grid[nx][ny])\n                    if new_max < dist[nx][ny]:\n                        dist[nx][ny] = new_max\n                        heapq.heappush(heap, (new_max, nx, ny))\n        \n        return dist[n-1][n-1]\n", "unique-paths": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        k = min(m - 1, n - 1)\n        a = m + n - 2\n\n        numerator = 1\n        for i in range(a, a - k - 1, -1):\n            numerator *= i\n\n        denominator = 1\n        for i in range(1, k + 1):\n            denominator *= i\n\n        return numerator // denominator\n", "multiply-strings": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        m, n = len(num1), len(num2)\n        num1_reversed = num1[::-1]\n        num2_reversed = num2[::-1]\n        \n        result = [0] * (m + n)\n        \n        # Perform multiplication digit by digit\n        for i in range(m):\n            digit1 = int(num1_reversed[i])\n            for j in range(n):\n                digit2 = int(num2_reversed[j])\n                result[i + j] += digit1 * digit2\n        \n        # Process carry\n        for k in range(m + n):\n            carry = result[k] // 10\n            digit = result[k] % 10\n            result[k] = digit\n            if carry:\n                if k + 1 < m + n:\n                    result[k + 1] += carry\n        \n        # Convert result to string\n        reversed_result = result[::-1]\n        # Find the first non-zero to skip leading zeros\n        first_non_zero = 0\n        while first_non_zero < len(reversed_result) and reversed_result[first_non_zero] == 0:\n            first_non_zero += 1\n        \n        if first_non_zero == len(reversed_result):\n            return \"0\"\n        \n        return ''.join(map(str, reversed_result[first_non_zero:]))\n", "best-time-to-buy-and-sell-stock-iii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        buy1 = -prices[0]\n        sell1 = 0\n        buy2 = float('-inf')\n        sell2 = 0\n        for price in prices[1:]:\n            new_buy1 = max(buy1, -price)\n            new_sell1 = max(sell1, buy1 + price)\n            new_buy2 = max(buy2, sell1 - price)\n            new_sell2 = max(sell2, buy2 + price)\n            buy1, sell1, buy2, sell2 = new_buy1, new_sell1, new_buy2, new_sell2\n        return max(sell1, sell2)\n", "combination-sum-ii": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        candidates.sort()\n        result = []\n        \n        def backtrack(start, path, remaining):\n            if remaining == 0:\n                result.append(list(path))\n                return\n            for i in range(start, len(candidates)):\n                # Skip duplicates\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                # Prune the search if current candidate exceeds remaining\n                if candidates[i] > remaining:\n                    break\n                # Proceed with the current candidate\n                path.append(candidates[i])\n                backtrack(i + 1, path, remaining - candidates[i])\n                path.pop()\n        \n        backtrack(0, [], target)\n        return result\n", "detect-capital": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        return (word == word.upper()) or (word == word.lower()) or (word[0].isupper() and word[1:] == word[1:].lower())\n", "best-time-to-buy-and-sell-stock": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            possible_profit = price - min_price\n            if possible_profit > max_profit:\n                max_profit = possible_profit\n            if price < min_price:\n                min_price = price\n        return max_profit\n", "binary-tree-inorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        stack = []\n        current = root\n        \n        while current or stack:\n            # Traverse to the leftmost node\n            while current:\n                stack.append(current)\n                current = current.left\n            # Backtrack to the parent\n            current = stack.pop()\n            res.append(current.val)\n            # Move to the right child\n            current = current.right\n        \n        return res\n", "construct-binary-tree-from-preorder-and-inorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not preorder:\n            return None\n        \n        # Create a hash map to store value to index mappings for inorder\n        in_map = {val: idx for idx, val in enumerate(inorder)}\n        pre_idx = 0  # This will track the current root in preorder\n        \n        def helper(in_left, in_right):\n            nonlocal pre_idx\n            if in_left > in_right:\n                return None\n            \n            # Choose preorder[pre_idx] as the current root\n            root_val = preorder[pre_idx]\n            root = TreeNode(root_val)\n            pre_idx += 1  # Move to the next element for subsequent roots\n            \n            # Find the root's index in inorder to split left and right\n            idx = in_map[root_val]\n            \n            # Recursively build left and right subtrees\n            root.left = helper(in_left, idx - 1)\n            root.right = helper(idx + 1, in_right)\n            \n            return root\n        \n        return helper(0, len(inorder) - 1)\n", "remove-invalid-parentheses": "from collections import deque\n\nclass Solution(object):\n    def removeInvalidParentheses(self, s):\n        def is_valid(string):\n            bal = 0\n            for c in string:\n                if c == '(':\n                    bal += 1\n                elif c == ')':\n                    bal -= 1\n                    if bal < 0:\n                        return False\n            return bal == 0\n        \n        queue = deque([s])\n        visited = set([s])\n        result = []\n        \n        while queue:\n            current_level_size = len(queue)\n            current_level_results = []\n            found = False  # Flag to check if any valid string is found in this level\n            \n            for _ in range(current_level_size):\n                current = queue.popleft()\n                \n                if is_valid(current):\n                    current_level_results.append(current)\n                    found = True\n                \n                # Only generate children if no valid string has been found yet in this level\n                if not found:\n                    for i in range(len(current)):\n                        if current[i] not in '()':\n                            continue\n                        # Generate next string by removing the i-th character\n                        next_str = current[:i] + current[i+1:]\n                        if next_str not in visited:\n                            visited.add(next_str)\n                            queue.append(next_str)\n            \n            if found:\n                return current_level_results\n        \n        # If no valid strings found, return [\"\"] as per constraints\n        return [\"\"]\n", "merge-k-sorted-lists": "import heapq\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        heap = []\n        for i in range(len(lists)):\n            if lists[i]:\n                heapq.heappush(heap, (lists[i].val, i, id(lists[i]), lists[i]))\n        \n        dummy = ListNode()\n        current = dummy\n        \n        while heap:\n            val, i, node_id, node = heapq.heappop(heap)\n            current.next = node\n            current = current.next\n            if node.next:\n                next_node = node.next\n                heapq.heappush(heap, (next_node.val, i, id(next_node), next_node))\n        \n        return dummy.next\n", "palindrome-partitioning-ii": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n <= 1:\n            return 0\n        \n        # Precompute palindrome table\n        pal = [[False] * n for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(i, n):\n                if s[i] == s[j]:\n                    if j - i <= 1:\n                        pal[i][j] = True\n                    else:\n                        pal[i][j] = pal[i+1][j-1]\n                else:\n                    pal[i][j] = False\n        \n        # Initialize DP array\n        dp = [0] * (n + 1)\n        dp[0] = -1  # base case: 0 characters need -1 cuts (0 in terms of formula)\n        for i in range(1, n + 1):\n            dp[i] = i - 1  # maximum possible cuts for first i characters\n            for j in range(i):\n                if pal[j][i-1]:\n                    if dp[j] + 1 < dp[i]:\n                        dp[i] = dp[j] + 1\n        \n        return dp[n]\n", "preimage-size-of-factorial-zeroes-function": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def trailing_zeros(x):\n            count = 0\n            while x > 0:\n                x = x // 5\n                count += x\n            return count\n        \n        low = 0\n        high = 5 * k  # Upper bound as 5*k suffices\n        \n        while low <= high:\n            mid = (low + high) // 2\n            fz = trailing_zeros(mid)\n            if fz < k:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        # After loop, low is the first x with trailing_zeros(x) >=k\n        if trailing_zeros(low) == k:\n            return 5\n        else:\n            return 0\n", "palindrome-pairs": "class Solution:\n    def palindromePairs(self, words):\n        word_dict = {word: i for i, word in enumerate(words)}\n        result = set()\n        \n        for i, word in enumerate(words):\n            n = len(word)\n            # Precompute prefix_pal and suffix_pal for this word\n            prefix_pal = [False] * (n + 1)\n            prefix_pal[0] = True\n            for k in range(1, n + 1):\n                is_p = True\n                for a in range(k // 2):\n                    if word[a] != word[k - 1 - a]:\n                        is_p = False\n                        break\n                prefix_pal[k] = is_p\n            \n            suffix_pal = [False] * (n + 1)\n            suffix_pal[n] = True\n            for k in range(n - 1, -1, -1):\n                length = n - k\n                is_p = True\n                for a in range(length // 2):\n                    if word[k + a] != word[n - 1 - a]:\n                        is_p = False\n                        break\n                suffix_pal[k] = is_p\n            \n            for k in range(n + 1):\n                prefix = word[:k]\n                suffix = word[k:]\n                # Case 1: suffix is a palindrome\n                if suffix_pal[k]:\n                    reversed_prefix = prefix[::-1]\n                    if reversed_prefix in word_dict:\n                        j = word_dict[reversed_prefix]\n                        if j != i:\n                            result.add((i, j))\n                # Case 2: prefix is a palindrome\n                if prefix_pal[k]:\n                    reversed_suffix = suffix[::-1]\n                    if reversed_suffix in word_dict:\n                        j = word_dict[reversed_suffix]\n                        if j != i:\n                            result.add((j, i))\n        \n        return [list(pair) for pair in result]\n", "convert-sorted-array-to-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            node = TreeNode(nums[mid])\n            node.left = helper(left, mid - 1)\n            node.right = helper(mid + 1, right)\n            return node\n        \n        return helper(0, len(nums) - 1)\n", "contain-virus": "from typing import List\nfrom collections import deque\n\nclass Solution:\n    def containVirus(self, isInfected: List[List[int]]) -> int:\n        total_walls = 0\n        m = len(isInfected)\n        if m == 0:\n            return 0\n        n = len(isInfected[0])\n        \n        while True:\n            regions = []\n            visited = [[False for _ in range(n)] for _ in range(m)]\n            \n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1 and not visited[i][j]:\n                        # BFS to find the region\n                        q = deque()\n                        q.append((i, j))\n                        visited[i][j] = True\n                        cells = []\n                        neighboring_zeros = set()\n                        walls_needed = 0\n                        \n                        while q:\n                            x, y = q.popleft()\n                            cells.append((x, y))\n                            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                                nx = x + dx\n                                ny = y + dy\n                                if 0 <= nx < m and 0 <= ny < n:\n                                    if isInfected[nx][ny] == 1 and not visited[nx][ny]:\n                                        visited[nx][ny] = True\n                                        q.append((nx, ny))\n                                    elif isInfected[nx][ny] == 0:\n                                        neighboring_zeros.add((nx, ny))\n                                        walls_needed += 1\n                        regions.append((cells, neighboring_zeros, walls_needed))\n            \n            if not regions:\n                break  # No more regions to process\n            \n            # Find the region with maximum spread\n            max_spread = -1\n            target_idx = 0\n            for idx in range(len(regions)):\n                current_spread = len(regions[idx][1])\n                if current_spread > max_spread:\n                    max_spread = current_spread\n                    target_idx = idx\n            \n            target = regions[target_idx]\n            total_walls += target[2]\n            \n            # Quarantine the target region by setting cells to -1 (non-infectious)\n            for (x, y) in target[0]:\n                isInfected[x][y] = -1  # Mark as quarantined\n            \n            # Collect all new infections from other regions\n            new_infections = set()\n            for idx in range(len(regions)):\n                if idx != target_idx:\n                    new_infections.update(regions[idx][1])\n            \n            # Update the grid to spread other regions\n            for (x, y) in new_infections:\n                isInfected[x][y] = 1  # Newly infected cells\n            \n        return total_walls\n", "longest-increasing-path-in-a-matrix": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not matrix:\n            return 0\n        rows = len(matrix)\n        cols = len(matrix[0])\n        memo = [[0] * cols for _ in range(rows)]\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        max_path = 0\n\n        def dfs(i, j):\n            if memo[i][j] != 0:\n                return memo[i][j]\n            max_len = 1\n            for dx, dy in directions:\n                ni, nj = i + dx, j + dy\n                if 0 <= ni < rows and 0 <= nj < cols and matrix[ni][nj] > matrix[i][j]:\n                    current = 1 + dfs(ni, nj)\n                    if current > max_len:\n                        max_len = current\n            memo[i][j] = max_len\n            return max_len\n\n        for i in range(rows):\n            for j in range(cols):\n                if memo[i][j] == 0:\n                    dfs(i, j)\n                if memo[i][j] > max_path:\n                    max_path = memo[i][j]\n        return max_path\n", "number-of-digit-one": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        \n        total = 0\n        i = 1  # Starting with the units place (10^0)\n        \n        while i <= n:\n            divider = i\n            higher = n // (divider * 10)\n            current = (n // divider) % 10\n            lower = n % divider\n            \n            if current > 1:\n                total += (higher + 1) * divider\n            elif current == 1:\n                total += higher * divider + (lower + 1)\n            else:\n                total += higher * divider\n            \n            i *= 10\n        \n        return total\n", "word-break-ii": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        word_set = set(wordDict)\n        if not word_set:\n            return []\n        max_len = max(len(word) for word in word_set)\n        n = len(s)\n        dp = [[] for _ in range(n + 1)]\n        dp[0] = [\"\"]\n        \n        for i in range(1, n + 1):\n            dp[i] = []\n            start = max(0, i - max_len)\n            for j in range(start, i):\n                word = s[j:i]\n                if word in word_set:\n                    for prev_sent in dp[j]:\n                        if prev_sent:\n                            new_sent = prev_sent + ' ' + word\n                        else:\n                            new_sent = word\n                        dp[i].append(new_sent)\n        return dp[n]\n", "binary-tree-zigzag-level-order-traversal": "from collections import deque\n\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                current_level.reverse()\n            result.append(current_level)\n            level += 1\n        return result\n", "binary-watch": "class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        result = []\n        for hour in range(12):\n            hour_bits = bin(hour).count('1')\n            for minute in range(60):\n                minute_bits = bin(minute).count('1')\n                if hour_bits + minute_bits == turnedOn:\n                    result.append(f\"{hour}:{minute:02d}\")\n        return result\n", "pascals-triangle": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [[1]]  # Start with the first row\n        \n        for i in range(1, numRows):\n            prev_row = result[-1]\n            new_row = [1]  # The first element is always 1\n            \n            # Compute the middle elements\n            for j in range(1, len(prev_row)):\n                new_element = prev_row[j - 1] + prev_row[j]\n                new_row.append(new_element)\n            \n            new_row.append(1)  # The last element is always 1\n            result.append(new_row)\n        \n        return result\n", "power-of-three": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        return (1162261467 % n) == 0\n", "binary-tree-maximum-path-sum": "class Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        max_sum = -float('inf')\n        \n        def helper(node):\n            nonlocal max_sum\n            if not node:\n                return 0\n            # Recursively calculate the maximum path sum for left and right subtrees\n            left_gain = max(helper(node.left), 0)\n            right_gain = max(helper(node.right), 0)\n            \n            # Calculate the maximum path sum that includes the current node as the root of the path\n            current_sum = node.val + left_gain + right_gain\n            if current_sum > max_sum:\n                max_sum = current_sum\n            \n            # Return the maximum contribution of the current subtree to its parent\n            return node.val + max(left_gain, right_gain)\n        \n        helper(root)\n        return max_sum\n", "trapping-rain-water-ii": "import heapq\n\nclass Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not heightMap or len(heightMap) < 3 or len(heightMap[0]) < 3:\n            return 0\n        \n        m = len(heightMap)\n        n = len(heightMap[0])\n        heap = []\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        \n        # Push all boundary cells into the heap\n        # First and last rows\n        for r in [0, m - 1]:\n            for c in range(n):\n                if not visited[r][c]:\n                    heapq.heappush(heap, (heightMap[r][c], r, c))\n                    visited[r][c] = True\n        \n        # First and last columns (excluding the first and last rows)\n        for c in [0, n - 1]:\n            for r in range(1, m - 1):\n                if not visited[r][c]:\n                    heapq.heappush(heap, (heightMap[r][c], r, c))\n                    visited[r][c] = True\n        \n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        total = 0\n        \n        while heap:\n            h, r, c = heapq.heappop(heap)\n            for d in dirs:\n                nr = r + d[0]\n                nc = c + d[1]\n                if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc]:\n                    visited[nr][nc] = True\n                    current_h = heightMap[nr][nc]\n                    if current_h < h:\n                        total += h - current_h\n                        new_h = h\n                    else:\n                        new_h = current_h\n                    heapq.heappush(heap, (new_h, nr, nc))\n        \n        return total\n", "valid-palindrome": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        processed = [c.lower() for c in s if c.isalnum()]\n        processed_str = ''.join(processed)\n        return processed_str == processed_str[::-1]\n", "sliding-window-median": "import heapq\nfrom collections import defaultdict\n\nclass Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        lower = []  # max-heap (stored as negatives)\n        upper = []  # min-heap\n        expired = defaultdict(int)\n        result = []\n        \n        # Initialize the first window\n        for num in nums[:k]:\n            if not lower or num <= -lower[0]:\n                heapq.heappush(lower, -num)\n            else:\n                heapq.heappush(upper, num)\n            # Balance the heaps\n            while len(lower) > len(upper) + 1:\n                val = -heapq.heappop(lower)\n                heapq.heappush(upper, val)\n            while len(upper) > len(lower):\n                val = heapq.heappop(upper)\n                heapq.heappush(lower, -val)\n        \n        # Compute the first median\n        if k % 2 == 1:\n            median = -lower[0]\n        else:\n            median = (-lower[0] + upper[0]) / 2.0\n        result.append(median)\n        \n        for i in range(k, len(nums)):\n            old_num = nums[i - k]\n            new_num = nums[i]\n            \n            # Add old_num to expired\n            expired[old_num] += 1\n            \n            # Add new_num to the appropriate heap\n            if not lower or new_num <= -lower[0]:\n                heapq.heappush(lower, -new_num)\n            else:\n                heapq.heappush(upper, new_num)\n            \n            # Balance the heaps after adding new_num\n            while len(lower) > len(upper) + 1:\n                val = -heapq.heappop(lower)\n                heapq.heappush(upper, val)\n            while len(upper) > len(lower):\n                val = heapq.heappop(upper)\n                heapq.heappush(lower, -val)\n            \n            # Clean the heaps by removing expired elements from the tops\n            # Clean lower heap\n            while lower and expired.get(-lower[0], 0) > 0:\n                val = -lower[0]\n                if expired[val] > 0:\n                    heapq.heappop(lower)\n                    expired[val] -= 1\n                    if expired[val] == 0:\n                        del expired[val]\n            # Clean upper heap\n            while upper and expired.get(upper[0], 0) > 0:\n                val = upper[0]\n                if expired[val] > 0:\n                    heapq.heappop(upper)\n                    expired[val] -= 1\n                    if expired[val] == 0:\n                        del expired[val]\n            \n            # Rebalance the heaps after cleaning\n            while len(lower) > len(upper) + 1:\n                val = -heapq.heappop(lower)\n                heapq.heappush(upper, val)\n            while len(upper) > len(lower):\n                val = heapq.heappop(upper)\n                heapq.heappush(lower, -val)\n            \n            # Compute the median\n            if len(lower) > len(upper):\n                median = -lower[0]\n            elif len(upper) > len(lower):\n                median = upper[0]\n            else:\n                median = (-lower[0] + upper[0]) / 2.0\n            result.append(median)\n        \n        return result\n", "rotate-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        # Compute the length of the list and find the tail\n        n = 1\n        current = head\n        while current.next:\n            n += 1\n            current = current.next\n        tail = current  # points to the last node\n        \n        effective_k = k % n\n        if effective_k == 0:\n            return head\n        \n        # Find the new_tail which is (n - effective_k - 1) steps from head\n        steps = n - effective_k - 1\n        current = head\n        for _ in range(steps):\n            current = current.next\n        \n        # Set new_head and adjust pointers\n        new_head = current.next\n        current.next = None  # break the list here\n        \n        # Connect the original tail to the head\n        tail.next = head\n        \n        return new_head\n", "ugly-number": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n = n // p\n        return n == 1\n", "falling-squares": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        intervals = []\n        ans = []\n        current_max = 0\n        \n        for left, side in positions:\n            current_left = left\n            current_right = left + side\n            current_height = side\n            max_below = 0\n            \n            for (l, r, h) in intervals:\n                if current_right <= l or r <= current_left:\n                    continue\n                if h > max_below:\n                    max_below = h\n            \n            new_h = max_below + current_height\n            intervals.append((current_left, current_right, new_h))\n            if new_h > current_max:\n                current_max = new_h\n            ans.append(current_max)\n        \n        return ans\n", "sum-of-left-leaves": "class Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        sum_total = 0\n        \n        # Check if the left child is a leaf\n        if root.left and root.left.left is None and root.left.right is None:\n            sum_total += root.left.val\n        \n        # Recursively check left and right subtrees\n        sum_total += self.sumOfLeftLeaves(root.left)\n        sum_total += self.sumOfLeftLeaves(root.right)\n        \n        return sum_total\n", "max-sum-of-rectangle-no-larger-than-k": "import bisect\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # Transpose the matrix if rows > columns to optimize for the follow-up case\n        if m > n:\n            matrix = list(map(list, zip(*matrix)))\n            m, n = n, m\n        \n        max_sum = -float('inf')\n        \n        for left in range(n):\n            row_sums = [0] * m\n            for right in range(left, n):\n                # Update row_sums with the current column's values\n                for i in range(m):\n                    row_sums[i] += matrix[i][right]\n                \n                # Now compute the 1D max subarray sum <=k for row_sums\n                current_max = self.max_subarray(row_sums, k)\n                if current_max > max_sum:\n                    max_sum = current_max\n        \n        return max_sum\n    \n    def max_subarray(self, arr, k):\n        from bisect import bisect_left, insort\n        prefix = [0]\n        current_sum = 0\n        max_val = -float('inf')\n        \n        for num in arr:\n            current_sum += num\n            target = current_sum - k\n            # Find the first index in prefix where prefix[idx] >= target\n            idx = bisect.bisect_left(prefix, target)\n            if idx < len(prefix):\n                candidate = current_sum - prefix[idx]\n                if candidate <= k and candidate > max_val:\n                    max_val = candidate\n            # Insert the current_sum into the prefix list while maintaining order\n            insort(prefix, current_sum)\n        \n        return max_val\n", "divide-two-integers": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        if dividend == 0:\n            return 0\n\n        # Determine the sign of the result\n        sign = -1 if (dividend < 0) ^ (divisor < 0) else 1\n\n        abs_dividend = abs(dividend)\n        abs_divisor = abs(divisor)\n\n        quotient = 0\n\n        while abs_dividend >= abs_divisor:\n            # Find the maximum shift\n            shift = 0\n            while (abs_divisor << (shift + 1)) <= abs_dividend:\n                shift += 1\n            # Add to quotient and subtract from dividend\n            quotient += (1 << shift)\n            abs_dividend -= (abs_divisor << shift)\n\n        result = sign * quotient\n\n        # Clamp the result to 32-bit signed integer range\n        if result > INT_MAX:\n            return INT_MAX\n        elif result < INT_MIN:\n            return INT_MIN\n        else:\n            return result\n", "surrounded-regions": "from collections import deque\n\nclass Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board or len(board) == 0 or len(board[0]) == 0:\n            return\n        \n        m = len(board)\n        n = len(board[0])\n        \n        q = deque()\n        \n        # Mark all border 'O's and add to queue\n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or i == m - 1 or j == 0 or j == n - 1) and board[i][j] == 'O':\n                    q.append((i, j))\n                    board[i][j] = 'E'  # Mark as visited/safe\n        \n        # Directions for BFS: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        # Process the queue to mark all connected 'O's as 'E'\n        while q:\n            i, j = q.popleft()\n            for dx, dy in directions:\n                x, y = i + dx, j + dy\n                if 0 <= x < m and 0 <= y < n and board[x][y] == 'O':\n                    board[x][y] = 'E'\n                    q.append((x, y))\n        \n        # Flip remaining 'O's to 'X's and revert 'E's to 'O's\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'E':\n                    board[i][j] = 'O'\n", "two-sum": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        num_map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], i]\n            num_map[num] = i\n", "24-game": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        def backtrack(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            n = len(nums)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    a = nums[i]\n                    b = nums[j]\n                    new_nums = []\n                    for k in range(n):\n                        if k != i and k != j:\n                            new_nums.append(nums[k])\n                    # Generate all possible candidates\n                    candidates = []\n                    candidates.append(a + b)\n                    candidates.append(a * b)\n                    candidates.append(a - b)\n                    candidates.append(b - a)\n                    if b != 0:\n                        candidates.append(a / b)\n                    if a != 0:\n                        candidates.append(b / a)\n                    # Recurse with each candidate\n                    for c in candidates:\n                        if backtrack(new_nums + [c]):\n                            return True\n            return False\n        \n        # Convert to floats to handle division properly\n        nums = [float(x) for x in cards]\n        return backtrack(nums)\n", "wildcard-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        len_s, len_p = len(s), len(p)\n        dp = [False] * (len_p + 1)\n        dp[0] = True  # empty matches empty\n        \n        # Handle first row (i=0, s is empty)\n        for j in range(1, len_p + 1):\n            if p[j-1] == '*':\n                dp[j] = dp[j-1]\n            else:\n                dp[j] = False  # non-* can't match empty s\n        \n        for i in range(1, len_s + 1):\n            current = [False] * (len_p + 1)\n            for j in range(1, len_p + 1):\n                if p[j-1] == '?':\n                    current[j] = dp[j-1]\n                elif p[j-1] == '*':\n                    current[j] = current[j-1] or dp[j]\n                else:\n                    current[j] = (s[i-1] == p[j-1]) and dp[j-1]\n            dp = current  # update dp to current for next iteration\n        \n        return dp[len_p]\n", "majority-element": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        candidate = None\n        count = 0\n        for num in nums:\n            if count == 0:\n                candidate = num\n                count = 1\n            else:\n                if num == candidate:\n                    count += 1\n                else:\n                    count -= 1\n        return candidate\n", "reconstruct-itinerary": "from collections import defaultdict\n\nclass Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        adj = defaultdict(list)\n        for frm, to in tickets:\n            adj[frm].append(to)\n        # Sort the destinations in reverse order so that popping from the end gives the smallest lex first\n        for key in adj:\n            adj[key].sort(reverse=True)\n        route = []\n        \n        def dfs(node):\n            while adj[node]:\n                next_node = adj[node].pop()\n                dfs(next_node)\n            route.append(node)\n        \n        dfs(\"JFK\")\n        return route[::-1]\n", "4sum": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left = j + 1\n                right = n - 1\n                while left < right:\n                    current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                    if current_sum == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        # Skip duplicates for left and right\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif current_sum < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n", "the-skyline-problem": "import heapq\nfrom collections import defaultdict\n\nclass Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        events = []\n        for L, R, H in buildings:\n            events.append((L, 1, H))   # Start event (left edge)\n            events.append((R, 0, H))   # End event (right edge)\n        \n        # Sort events by x, then by type (end before start at same x)\n        events.sort(key=lambda x: (x[0], x[1]))\n        \n        heap = []\n        counter = defaultdict(int)\n        result = []\n        prev_max = 0\n        \n        i = 0\n        n = len(events)\n        \n        while i < n:\n            current_x = events[i][0]\n            # Process all events at current_x\n            while i < n and events[i][0] == current_x:\n                x, typ, h = events[i]\n                if typ == 1:  # Start event\n                    heapq.heappush(heap, -h)\n                    counter[h] += 1\n                else:         # End event\n                    counter[h] -= 1\n                i += 1\n            \n            # Clean up the heap to remove invalid heights (count 0)\n            while heap and counter[-heap[0]] == 0:\n                heapq.heappop(heap)\n            \n            # Determine current maximum height\n            current_max = -heap[0] if heap else 0\n            \n            if current_max != prev_max:\n                result.append([current_x, current_max])\n                prev_max = current_max\n        \n        return result\n", "reverse-string": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        left = 0\n        right = len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n", "reverse-linked-list": "class Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        prev = None\n        current = head\n        while current is not None:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        return prev\n", "triangle": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(triangle)\n        if n == 0:\n            return 0\n        dp = list(triangle[-1])  # Initialize DP with the last row\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i + 1):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j+1])\n        \n        return dp[0]\n", "integer-to-english-words": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"Zero\"\n        \n        less_than_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n                        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\",\n                        \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        def helper(n):\n            if n == 0:\n                return \"\"\n            parts = []\n            h = n // 100\n            rem = n % 100\n            if h != 0:\n                parts.append(less_than_20[h] + \" Hundred\")\n            if rem < 20:\n                if rem != 0:\n                    parts.append(less_than_20[rem])\n            else:\n                t = rem // 10\n                o = rem % 10\n                parts.append(tens[t])\n                if o != 0:\n                    parts.append(less_than_20[o])\n            return ' '.join(parts).strip()\n        \n        groups = []\n        n = num\n        while n > 0:\n            groups.append(n % 1000)\n            n = n // 1000\n        \n        result = []\n        for i in range(len(groups)-1, -1, -1):\n            group = groups[i]\n            if group == 0:\n                continue\n            part = helper(group)\n            scale = thousands[i]\n            if scale:\n                result.append(part + ' ' + scale)\n            else:\n                result.append(part)\n        \n        return ' '.join(result)\n", "k-inverse-pairs-array": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        prev_dp = [0] * 1001\n        prev_dp[0] = 1  # Base case: i=1, j=0\n        \n        for i in range(2, n + 1):\n            curr_dp = [0] * 1001\n            # Compute prefix sums of the previous row\n            pre = [0] * 1001\n            pre[0] = prev_dp[0]\n            for m in range(1, 1001):\n                pre[m] = (pre[m - 1] + prev_dp[m]) % MOD\n            \n            for j in range(0, 1001):\n                m_start = max(0, j - (i - 1))\n                if m_start == 0:\n                    sum_val = pre[j]\n                else:\n                    sum_val = (pre[j] - pre[m_start - 1]) % MOD\n                curr_dp[j] = sum_val % MOD\n            \n            prev_dp = curr_dp[:]  # Make a copy to avoid reference issues\n        \n        return prev_dp[k] % MOD\n", "swap-nodes-in-pairs": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            first = prev.next\n            second = first.next\n            # Swap the nodes\n            prev.next = second\n            first.next = second.next\n            second.next = first\n            # Move prev to the end of the swapped pair\n            prev = first\n        \n        return dummy.next\n", "path-sum": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n        if not root.left and not root.right:\n            return root.val == targetSum\n        return self.hasPathSum(root.left, targetSum - root.val) or \\\n               self.hasPathSum(root.right, targetSum - root.val)\n", "partition-list": "class Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        before_head = ListNode(0)\n        after_head = ListNode(0)\n        before_curr = before_head\n        after_curr = after_head\n        \n        current = head\n        while current:\n            next_node = current.next  # Save the next node in the original list\n            if current.val < x:\n                # Add to before list\n                before_curr.next = current\n                current.next = None  # Break link to original next\n                before_curr = current\n            else:\n                # Add to after list\n                after_curr.next = current\n                current.next = None  # Break link to original next\n                after_curr = current\n            current = next_node  # Move to next node in original list\n        \n        # Connect the two lists\n        before_curr.next = after_head.next\n        \n        return before_head.next\n", "redundant-connection-ii": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        # Check for conflict node (two parents)\n        parents = {}\n        conflict_edges = []\n        conflict_node = None\n        for edge in edges:\n            u, v = edge\n            if v in parents:\n                # Found the conflict node\n                conflict_node = v\n                conflict_edges = [[parents[v], v], edge]\n                break\n            else:\n                parents[v] = u\n        if conflict_node is not None:\n            # Case 1: choose between the two edges\n            edge1, edge2 = conflict_edges\n            # Check if removing edge2 gives a valid tree\n            if self.is_valid_tree(edges, edge2):\n                return edge2\n            else:\n                return edge1\n        else:\n            # Case 2: find the last edge that forms a cycle\n            return self.find_cycle_edge(edges)\n    \n    def is_valid_tree(self, edges, excluded_edge):\n        n = len(edges)\n        parent = {}\n        for edge in edges:\n            if edge == excluded_edge:\n                continue\n            u, v = edge\n            if v in parent:\n                return False\n            parent[v] = u\n        # Check condition 1: exactly one root\n        all_nodes = set(range(1, n + 1))\n        nodes_with_parent = set(parent.keys())\n        roots = all_nodes - nodes_with_parent\n        if len(roots) != 1:\n            return False\n        # Check condition 3: no cycles\n        if self.has_cycle(parent, n):\n            return False\n        return True\n    \n    def has_cycle(self, parent, n):\n        visited = [False] * (n + 1)\n        in_stack = [False] * (n + 1)\n        has_cycle_flag = False\n        \n        def dfs(node):\n            nonlocal has_cycle_flag\n            if has_cycle_flag:\n                return\n            if in_stack[node]:\n                has_cycle_flag = True\n                return\n            if visited[node]:\n                return\n            visited[node] = True\n            in_stack[node] = True\n            p = parent.get(node, None)\n            if p is not None:\n                dfs(p)\n            in_stack[node] = False\n        \n        for node in range(1, n + 1):\n            if not visited[node]:\n                dfs(node)\n                if has_cycle_flag:\n                    return True\n        return False\n    \n    def find_cycle_edge(self, edges):\n        parent = {}\n        candidates = []\n        for edge in edges:\n            u, v = edge\n            if v in parent:\n                continue  # shouldn't happen in case2\n            # Check if v is an ancestor of u\n            current = u\n            is_ancestor = False\n            while current is not None:\n                if current == v:\n                    is_ancestor = True\n                    break\n                current = parent.get(current, None)\n            if is_ancestor:\n                candidates.append(edge)\n            else:\n                parent[v] = u\n        return candidates[-1]\n", "permutations-ii": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        nums.sort()  # Sort to handle duplicates\n        used = [False] * len(nums)\n        \n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(list(path))\n                return\n            for i in range(len(nums)):\n                # Skip if already used or duplicate condition met\n                if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                    continue\n                # Mark as used and proceed\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                # Backtrack: unmark and remove from path\n                path.pop()\n                used[i] = False\n        \n        backtrack([])\n        return res\n", "add-digits": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 0\n        else:\n            return 1 + (num - 1) % 9\n", "single-number": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n", "length-of-last-word": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        words = s.split()\n        return len(words[-1])\n", "cherry-pickup": "class Solution(object):\n    def cherryPickup(self, grid):\n        n = len(grid)\n        if n == 0:\n            return 0\n        \n        prev_dp = [[-float('inf') for _ in range(n)] for _ in range(n)]\n        prev_dp[0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            curr_dp = [[-float('inf') for _ in range(n)] for _ in range(n)]\n            for r1 in range(n):\n                c1 = k - r1\n                if c1 < 0 or c1 >= n or grid[r1][c1] == -1:\n                    continue\n                for r2 in range(n):\n                    c2 = k - r2\n                    if c2 < 0 or c2 >= n or grid[r2][c2] == -1:\n                        continue\n                    # Calculate cherries collected at current positions\n                    if r1 == r2 and c1 == c2:\n                        cherry = grid[r1][c1]\n                    else:\n                        cherry = grid[r1][c1] + grid[r2][c2]\n                    \n                    max_prev = -float('inf')\n                    # Check all possible previous positions\n                    for r1_prev in [r1, r1 - 1]:\n                        if r1_prev < 0:\n                            continue\n                        prev_c1 = (k - 1) - r1_prev\n                        if prev_c1 < 0 or prev_c1 >= n:\n                            continue\n                        for r2_prev in [r2, r2 - 1]:\n                            if r2_prev < 0:\n                                continue\n                            prev_c2 = (k - 1) - r2_prev\n                            if prev_c2 < 0 or prev_c2 >= n:\n                                continue\n                            val = prev_dp[r1_prev][r2_prev]\n                            if val > max_prev:\n                                max_prev = val\n                    if max_prev != -float('inf'):\n                        curr_dp[r1][r2] = max_prev + cherry\n                    else:\n                        curr_dp[r1][r2] = -float('inf')\n            prev_dp = curr_dp\n        \n        result = prev_dp[n-1][n-1]\n        return max(0, result) if result != -float('inf') else 0\n", "student-attendance-record-ii": "class Solution(object):\n    def checkRecord(self, n):\n        MOD = 10**9 + 7\n        current_dp = [[0] * 3 for _ in range(2)]\n        current_dp[0][0] = 1  # Starting with 0 A's and 0 L's\n\n        for _ in range(n):\n            next_dp = [[0] * 3 for _ in range(2)]\n            for a in range(2):\n                for l in range(3):\n                    count = current_dp[a][l]\n                    if count == 0:\n                        continue\n                    # Adding 'P'\n                    next_dp[a][0] = (next_dp[a][0] + count) % MOD\n                    # Adding 'A' if possible\n                    if a < 1:\n                        next_dp[a + 1][0] = (next_dp[a + 1][0] + count) % MOD\n                    # Adding 'L' if possible\n                    if l < 2:\n                        next_dp[a][l + 1] = (next_dp[a][l + 1] + count) % MOD\n            current_dp = next_dp\n\n        total = 0\n        for a in range(2):\n            for l in range(3):\n                total = (total + current_dp[a][l]) % MOD\n        return total\n", "happy-number": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        while n not in seen:\n            seen.add(n)\n            if n == 1:\n                return True\n            n = self.get_next(n)\n        return False\n\n    def get_next(self, n):\n        total = 0\n        while n > 0:\n            n, digit = divmod(n, 10)\n            total += digit ** 2\n        return total\n", "search-insert-position": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        low = 0\n        high = len(nums) - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low\n", "jump-game": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        max_reach = 0\n        target = len(nums) - 1\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n            if max_reach >= target:\n                return True\n        return max_reach >= target\n", "minimum-path-sum": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        m = len(grid)\n        n = len(grid[0]) if m > 0 else 0\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue  # starting point, no addition\n                elif i == 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        \n        return grid[-1][-1]\n", "count-and-say": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return \"1\"\n        current = \"1\"\n        for _ in range(n - 1):\n            next_str = []\n            curr_char = current[0]\n            count = 1\n            for c in current[1:]:\n                if c == curr_char:\n                    count += 1\n                else:\n                    next_str.append(str(count) + curr_char)\n                    curr_char = c\n                    count = 1\n            # Add the last collected character and count\n            next_str.append(str(count) + curr_char)\n            current = ''.join(next_str)\n        return current\n", "split-array-largest-sum": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def is_possible(target):\n            current_sum = 0\n            count = 1\n            for num in nums:\n                if current_sum + num > target:\n                    count += 1\n                    current_sum = num\n                    if count > k:\n                        return False\n                else:\n                    current_sum += num\n            return count <= k\n        \n        low = max(nums)\n        high = sum(nums)\n        \n        while low < high:\n            mid = (low + high) // 2\n            if is_possible(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n", "search-in-rotated-sorted-array": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            \n            # Check if the left half is sorted\n            if nums[left] <= nums[mid]:\n                # Target is in the left sorted half?\n                if nums[left] <= target <= nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                # Right half is sorted\n                # Target is in the right sorted half?\n                if nums[mid] <= target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1\n", "letter-combinations-of-a-phone-number": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        result = [letter for letter in digit_to_letters[digits[0]]]\n        \n        for digit in digits[1:]:\n            current_letters = digit_to_letters[digit]\n            new_combinations = []\n            for combo in result:\n                for letter in current_letters:\n                    new_combinations.append(combo + letter)\n            result = new_combinations\n        \n        return result\n", "combination-sum": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        candidates.sort()\n        self.backtrack(candidates, target, 0, [], res)\n        return res\n    \n    def backtrack(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(list(path))\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            path.append(candidates[i])\n            self.backtrack(candidates, target - candidates[i], i, path, res)\n            path.pop()\n", "find-the-closest-palindrome": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        original = int(n)\n        l = len(n)\n        candidates = []\n        \n        # Edge candidates\n        edge1 = 10**(l-1) - 1\n        edge2 = 10**l + 1\n        candidates.append(edge1)\n        candidates.append(edge2)\n        \n        # Prefix-based candidates\n        half = (l + 1) // 2\n        prefix_str = n[:half]\n        prefix = int(prefix_str)\n        \n        for delta in (-1, 0, 1):\n            new_prefix = prefix + delta\n            s = str(new_prefix)\n            if l % 2 == 0:\n                pal_str = s + s[::-1]\n            else:\n                pal_str = s + s[:-1][::-1]\n            candidates.append(int(pal_str))\n        \n        # Remove duplicates and the original number\n        candidates = list(set(candidates))\n        if original in candidates:\n            candidates.remove(original)\n        \n        # Find the closest candidate\n        min_diff = float('inf')\n        result = None\n        for candidate in candidates:\n            diff = abs(candidate - original)\n            if (diff < min_diff) or (diff == min_diff and (result is None or candidate < result)):\n                min_diff = diff\n                result = candidate\n        \n        return str(result)\n", "spiral-matrix-ii": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\n        top, bottom, left, right = 0, n - 1, 0, n - 1\n        number = 1\n        \n        while top <= bottom and left <= right:\n            # Fill top row from left to right\n            for i in range(left, right + 1):\n                matrix[top][i] = number\n                number += 1\n            top += 1\n            \n            # Fill right column from top to bottom\n            for i in range(top, bottom + 1):\n                matrix[i][right] = number\n                number += 1\n            right -= 1\n            \n            # Fill bottom row from right to left if applicable\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = number\n                    number += 1\n                bottom -= 1\n            \n            # Fill left column from bottom to top if applicable\n            if left <= right and top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = number\n                    number += 1\n                left += 1\n        \n        return matrix\n", "reverse-integer": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        sign = 1 if x >= 0 else -1\n        num = abs(x)\n        reversed_num = 0\n        max_for_positive = 2**31 - 1  # 2147483647\n        max_for_negative = 2**31      # 2147483648\n        \n        if sign == 1:\n            max_allowed = max_for_positive\n        else:\n            max_allowed = max_for_negative\n        \n        while num > 0:\n            digit = num % 10\n            # Check for overflow before updating reversed_num\n            if reversed_num > max_allowed // 10:\n                return 0\n            elif reversed_num == max_allowed // 10:\n                if digit > max_allowed % 10:\n                    return 0\n            # Proceed to update reversed_num\n            reversed_num = reversed_num * 10 + digit\n            num = num // 10\n        \n        reversed_num *= sign\n        return reversed_num\n", "rotate-image": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        # Transpose the matrix\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        # Reverse each row\n        for row in matrix:\n            row.reverse()\n", "maximum-product-subarray": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_prod = current_max = current_min = nums[0]\n        \n        for num in nums[1:]:\n            temp_max = max(num, current_max * num, current_min * num)\n            temp_min = min(num, current_max * num, current_min * num)\n            current_max, current_min = temp_max, temp_min\n            if current_max > max_prod:\n                max_prod = current_max\n        \n        return max_prod\n", "frog-jump": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if stones[1] != 1:\n            return False  # The first jump must be 1, so the second stone must be at 1\n        \n        last_stone = stones[-1]\n        stones_set = set(stones)\n        dp = {}\n        dp[0] = {0}  # Starting at position 0 with a 'jump' of 0 (initial state)\n        \n        for s in stones:\n            if s not in dp:\n                continue\n            for k in dp[s]:\n                for delta in (-1, 0, 1):\n                    next_jump = k + delta\n                    if next_jump <= 0:\n                        continue  # Can't jump backward or zero units\n                    next_pos = s + next_jump\n                    if next_pos == last_stone:\n                        return True\n                    if next_pos in stones_set:\n                        if next_pos not in dp:\n                            dp[next_pos] = set()\n                        dp[next_pos].add(next_jump)\n        \n        return False\n", "relative-ranks": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        sorted_scores = sorted(score, reverse=True)\n        score_to_rank = {}\n        for i, s in enumerate(sorted_scores):\n            rank = i + 1\n            score_to_rank[s] = rank\n        result = []\n        for s in score:\n            rank = score_to_rank[s]\n            if rank == 1:\n                result.append(\"Gold Medal\")\n            elif rank == 2:\n                result.append(\"Silver Medal\")\n            elif rank == 3:\n                result.append(\"Bronze Medal\")\n            else:\n                result.append(str(rank))\n        return result\n", "longest-substring-without-repeating-characters": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        char_index = {}\n        max_length = 0\n        left = 0\n        \n        for right in range(len(s)):\n            current_char = s[right]\n            if current_char in char_index and char_index[current_char] >= left:\n                left = char_index[current_char] + 1\n            char_index[current_char] = right\n            current_length = right - left + 1\n            if current_length > max_length:\n                max_length = current_length\n        \n        return max_length\n", "substring-with-concatenation-of-all-words": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        from collections import defaultdict, Counter\n\n        m = len(words)\n        if m == 0:\n            return []\n        w = len(words[0])\n        total_length = m * w\n        n = len(s)\n        if n < total_length:\n            return []\n        original_counts = Counter(words)\n        unique_count = len(original_counts)\n        result = []\n\n        for offset in range(w):\n            # Build the word list for this offset\n            word_list = []\n            max_i = (n - offset) // w\n            for i in range(max_i):\n                start = offset + i * w\n                end = start + w\n                word = s[start:end]\n                word_list.append(word)\n            # Now process this word_list with sliding window\n            current_counts = defaultdict(int)\n            matches = 0\n            left = 0\n            current_result = []\n            for i in range(len(word_list)):\n                current_word = word_list[i]\n                if current_word not in original_counts:\n                    # Reset\n                    current_counts.clear()\n                    matches = 0\n                    left = i + 1\n                    continue\n                # Add current_word to current_counts\n                prev_count = current_counts[current_word]\n                current_counts[current_word] += 1\n                new_count = current_counts[current_word]\n                # Update matches\n                if prev_count == original_counts[current_word]:\n                    matches -= 1\n                if new_count == original_counts[current_word]:\n                    matches += 1\n                # Check if window is too big\n                while (i - left + 1) > m:\n                    # Move left forward\n                    left_word = word_list[left]\n                    prev_left_count = current_counts[left_word]\n                    current_counts[left_word] -= 1\n                    new_left_count = current_counts[left_word]\n                    # Update matches\n                    if prev_left_count == original_counts[left_word]:\n                        matches -= 1\n                    if new_left_count == original_counts[left_word]:\n                        matches += 1\n                    # Remove from current_counts if count is 0\n                    if current_counts[left_word] == 0:\n                        del current_counts[left_word]\n                    left += 1\n                # Check if window is exactly m and matches\n                if (i - left + 1) == m and matches == unique_count:\n                    start_index = offset + left * w\n                    current_result.append(start_index)\n            # Add current_result to the main result\n            result.extend(current_result)\n        return result\n", "max-chunks-to-make-sorted-ii": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        sorted_arr = sorted(arr)\n        current_max = float('-inf')\n        count = 0\n        for i in range(len(arr)):\n            current_max = max(current_max, arr[i])\n            if current_max == sorted_arr[i]:\n                count += 1\n        return count\n", "insertion-sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        current = dummy.next  # Start with the first node\n        \n        while current:\n            # Find the correct position in the sorted part\n            prev_node = dummy\n            while prev_node.next and prev_node.next.val < current.val:\n                prev_node = prev_node.next\n            \n            # Remove the current node from its current position\n            temp = current.next\n            # Insert current after prev_node\n            current.next = prev_node.next\n            prev_node.next = current\n            # Move to the next node\n            current = temp\n        \n        return dummy.next\n", "remove-duplicates-from-sorted-list-ii": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next:\n            current = prev.next\n            # Check if current has a next node and value matches\n            if current.next and current.val == current.next.val:\n                # Find the end of duplicates\n                val = current.val\n                while current and current.val == val:\n                    current = current.next\n                # Skip all duplicates\n                prev.next = current\n            else:\n                # Move prev forward if no duplicates\n                prev = prev.next\n        \n        return dummy.next\n", "3sum": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        res = []\n        n = len(nums)\n        \n        for i in range(n - 2):\n            # Skip duplicate for the first element\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            \n            left, right = i + 1, n - 1\n            \n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                if current_sum < 0:\n                    left += 1\n                elif current_sum > 0:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    # Skip duplicates for left\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    # Skip duplicates for right\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n        \n        return res\n", "edit-distance": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        m = len(word1)\n        n = len(word2)\n        # Create a DP table with (m+1) rows and (n+1) columns\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Base cases: fill the first row and column\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        \n        # Fill the DP table\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(\n                        dp[i-1][j],    # Delete operation\n                        dp[i][j-1],    # Insert operation\n                        dp[i-1][j-1]   # Replace operation\n                    )\n        \n        return dp[m][n]\n", "hamming-distance": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        xor = x ^ y\n        count = 0\n        while xor != 0:\n            xor = xor & (xor - 1)\n            count += 1\n        return count\n", "binary-tree-paths": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n         self.left = left\n         self.right = right\n\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        self.dfs(root, \"\", result)\n        return result\n    \n    def dfs(self, node, path, result):\n        if not node:\n            return\n        if not node.left and not node.right:\n            result.append(path + str(node.val))\n            return\n        if node.left:\n            self.dfs(node.left, path + str(node.val) + \"->\", result)\n        if node.right:\n            self.dfs(node.right, path + str(node.val) + \"->\", result)\n", "reverse-pairs": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def merge_sort(l, r):\n            if l >= r:\n                return 0\n            mid = (l + r) // 2\n            count = merge_sort(l, mid) + merge_sort(mid + 1, r)\n            \n            # Count cross pairs\n            j = mid + 1\n            for i in range(l, mid + 1):\n                while j <= r and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += (j - (mid + 1))\n            \n            # Merge the sorted halves\n            temp = []\n            i, j = l, mid + 1\n            while i <= mid and j <= r:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            temp.extend(nums[i:mid + 1])\n            temp.extend(nums[j:r + 1])\n            \n            # Copy back to nums\n            for idx in range(len(temp)):\n                nums[l + idx] = temp[idx]\n            \n            return count\n        \n        return merge_sort(0, len(nums) - 1)\n", "reaching-points": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy and tx != tx and ty != ty:\n            if tx > ty:\n                # Reduce tx using modulo to avoid multiple subtractions\n                quotient = (tx - sx) // ty\n                tx -= quotient * ty\n            else:\n                quotient = (ty - sy) // tx\n                ty -= quotient * tx\n            # Alternatively, simpler way with modulo (but handle possible zeros)\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if tx == sx and ty == sy:\n            return True\n        elif tx == sx:\n            # Check if (ty - sy) is divisible by sx and ty >= sy\n            return ty >= sy and (ty - sy) % sx == 0\n        elif ty == sy:\n            # Check if (tx - sx) is divisible by sy and tx >= sx\n            return tx >= sx and (tx - sx) % sy == 0\n        else:\n            return False\n", "compare-version-numbers": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        # Split the version strings into lists of integers\n        v1 = list(map(int, version1.split('.')))\n        v2 = list(map(int, version2.split('.')))\n        \n        # Determine the maximum length to iterate through\n        max_len = max(len(v1), len(v2))\n        \n        for i in range(max_len):\n            # Get the current revision for each version, default to 0 if beyond their length\n            a = v1[i] if i < len(v1) else 0\n            b = v2[i] if i < len(v2) else 0\n            \n            if a < b:\n                return -1\n            elif a > b:\n                return 1\n        \n        # All revisions are equal\n        return 0\n", "best-time-to-buy-and-sell-stock-ii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i-1]:\n                profit += prices[i] - prices[i-1]\n        return profit\n", "course-schedule-iii": "import heapq\n\nclass Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort courses by their lastDay\n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        time = 0\n        \n        for duration, last_day in courses:\n            if time + duration <= last_day:\n                # Take the course directly\n                heapq.heappush(max_heap, -duration)\n                time += duration\n            else:\n                # Check if replacing the longest duration course helps\n                if max_heap and duration < -max_heap[0]:\n                    # Remove the longest duration course\n                    longest = -heapq.heappop(max_heap)\n                    time -= longest\n                    # Add the current course\n                    time += duration\n                    heapq.heappush(max_heap, -duration)\n        \n        return len(max_heap)\n", "reverse-nodes-in-k-group": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            # Check if there are k nodes starting from prev.next\n            start = prev.next\n            if not start:\n                break\n            \n            # Check if there are k nodes from 'start'\n            temp = start\n            for _ in range(k - 1):\n                temp = temp.next\n                if not temp:\n                    break\n            \n            if not temp:\n                break  # Not enough nodes, exit loop\n            \n            # Reverse the k nodes starting at 'start'\n            current = start\n            prev_node = None\n            for _ in range(k):\n                next_node = current.next\n                current.next = prev_node\n                prev_node = current\n                current = next_node\n            \n            # Connect the reversed group\n            prev.next.next = current  # The original start's next points to the next group\n            prev.next = prev_node     # Prev points to the new head of reversed group\n            \n            # Move prev to the end of the reversed group (original start)\n            prev = start\n        \n        return dummy.next\n", "repeated-substring-pattern": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        return s in (s + s)[1:-1]\n", "unique-binary-search-trees": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case: C0 = 1\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - 1 - j]\n        \n        return dp[n]\n", "single-number-ii": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        once = 0\n        twice = 0\n        for num in nums:\n            new_once = (once ^ num) & ~twice\n            new_twice = (twice & ~num) | (once & num)\n            once, twice = new_once, new_twice\n        return once\n", "stickers-to-spell-word": "from collections import deque, Counter\n\nclass Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        target_counter = Counter(target)\n        chars = list(target_counter.keys())\n        m = len(chars)\n        if m == 0:\n            return 0  # Though target length constraints say it's at least 1\n        \n        # Create a mapping from character to its index in the chars list\n        char_to_idx = {c: i for i, c in enumerate(chars)}\n        \n        # Check if any character in target is not present in any sticker\n        for c in chars:\n            found = False\n            for sticker in stickers:\n                if c in sticker:\n                    found = True\n                    break\n            if not found:\n                return -1\n        \n        # Precompute sticker contributions for each character in target\n        sticker_contributions = []\n        for sticker in stickers:\n            counts = [0] * m\n            for char in sticker:\n                if char in char_to_idx:\n                    counts[char_to_idx[char]] += 1\n            sticker_contributions.append(counts)\n        \n        # Initial state is the target counts as a tuple\n        target_counts = tuple([target_counter[c] for c in chars])\n        start_state = target_counts\n        \n        # BFS initialization\n        visited = set()\n        queue = deque()\n        queue.append((start_state, 0))\n        visited.add(start_state)\n        \n        while queue:\n            current_state, steps = queue.popleft()\n            \n            # If all counts are zero, we've formed the target\n            if sum(current_state) == 0:\n                return steps\n            \n            # Try each sticker to transition to the next state\n            for contrib in sticker_contributions:\n                next_counts = list(current_state)\n                for i in range(m):\n                    next_counts[i] = max(0, next_counts[i] - contrib[i])\n                next_state = tuple(next_counts)\n                \n                if next_state != current_state and next_state not in visited:\n                    visited.add(next_state)\n                    queue.append((next_state, steps + 1))\n        \n        # If we exit the loop, it means it's impossible (though the initial check should have caught it)\n        return -1\n", "strange-printer": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        # Initialize DP table\n        dp = [[0] * n for _ in range(n)]\n        \n        # Base case: single character\n        for i in range(n):\n            dp[i][i] = 1\n        \n        for L in range(2, n + 1):  # L is the length of substring\n            for i in range(n - L + 1):\n                j = i + L - 1\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    min_val = float('inf')\n                    for k in range(i, j):\n                        current = dp[i][k] + dp[k+1][j]\n                        if current < min_val:\n                            min_val = current\n                    dp[i][j] = min_val\n        return dp[0][n-1]\n", "sqrtx": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        low = 0\n        high = x\n        ans = 0\n        while low <= high:\n            mid = (low + high) // 2\n            mid_sq = mid * mid\n            if mid_sq == x:\n                return mid\n            elif mid_sq < x:\n                ans = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        return ans\n", "roman-to-integer": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        roman_values = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        total = 0\n        for i in range(len(s) - 1):\n            current_val = roman_values[s[i]]\n            next_val = roman_values[s[i + 1]]\n            if current_val < next_val:\n                total -= current_val\n            else:\n                total += current_val\n        \n        # Add the value of the last character\n        total += roman_values[s[-1]]\n        \n        return total\n", "contains-duplicate": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        return len(nums) != len(set(nums))\n", "sliding-window-maximum": "from collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        q = deque()\n        result = []\n        for i, num in enumerate(nums):\n            # Remove elements out of the current window's left bound\n            while q and q[0] < i - k + 1:\n                q.popleft()\n            \n            # Maintain the deque in decreasing order\n            while q and num >= nums[q[-1]]:\n                q.pop()\n            \n            q.append(i)\n            \n            # Add the maximum (front of deque) once the window is formed\n            if i >= k - 1:\n                result.append(nums[q[0]])\n        \n        return result\n", "median-of-two-sorted-arrays": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        # Ensure nums1 is the shorter array to optimize binary search\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        low, high = 0, m\n        \n        while low <= high:\n            i = (low + high) // 2\n            j = (m + n + 1) // 2 - i\n            \n            # Handle edge cases for maxLeftA and minRightA\n            maxLeftA = nums1[i-1] if i != 0 else -float('inf')\n            minRightA = nums1[i] if i != m else float('inf')\n            \n            # Handle edge cases for maxLeftB and minRightB\n            maxLeftB = nums2[j-1] if j != 0 else -float('inf')\n            minRightB = nums2[j] if j != n else float('inf')\n            \n            if maxLeftA <= minRightB and maxLeftB <= minRightA:\n                # Valid partition found\n                if (m + n) % 2 == 0:\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0\n                else:\n                    return float(max(maxLeftA, maxLeftB))\n            elif maxLeftA > minRightB:\n                # Move partition to the left in nums1\n                high = i - 1\n            else:\n                # Move partition to the right in nums1\n                low = i + 1\n        \n        # The following line is theoretically unreachable if inputs are valid\n        return 0.0\n", "find-minimum-in-rotated-sorted-array": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n", "pascals-triangle-ii": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        row = [1]\n        for i in range(1, rowIndex + 1):\n            next_num = row[i - 1] * (rowIndex - i + 1) // i\n            row.append(next_num)\n        return row\n", "path-sum-ii": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        \n        def helper(node, remaining_sum, path):\n            if not node:\n                return\n            remaining_sum -= node.val\n            path.append(node.val)\n            \n            # Check if current node is a leaf\n            if not node.left and not node.right:\n                if remaining_sum == 0:\n                    result.append(list(path))  # Append a copy of the current path\n            else:\n                helper(node.left, remaining_sum, path)\n                helper(node.right, remaining_sum, path)\n            \n            # Backtrack: remove the current node from the path\n            path.pop()\n        \n        helper(root, targetSum, [])\n        return result\n", "construct-the-rectangle": "import math\n\nclass Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        sqrt_area = int(math.sqrt(area))\n        for w in range(sqrt_area, 0, -1):\n            if area % w == 0:\n                return [area // w, w]\n        return [area, 1]  # This line is theoretically unreachable since 1 is always a divisor\n", "word-ladder-ii": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        # Build the pattern map\n        from collections import defaultdict\n        pattern_map = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                pattern_map[pattern].append(word)\n        \n        # BFS initialization\n        from collections import deque\n        prev = defaultdict(list)\n        distance = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n        \n        while queue and not found:\n            level_size = len(queue)\n            for _ in range(level_size):\n                current_word = queue.popleft()\n                if current_word == endWord:\n                    found = True\n                \n                # Generate all neighbors\n                for i in range(len(current_word)):\n                    pattern = current_word[:i] + '*' + current_word[i+1:]\n                    for neighbor in pattern_map.get(pattern, []):\n                        if neighbor == current_word:\n                            continue  # Skip the same word\n                        \n                        if neighbor not in distance:\n                            distance[neighbor] = distance[current_word] + 1\n                            prev[neighbor].append(current_word)\n                            queue.append(neighbor)\n                        elif distance[neighbor] == distance[current_word] + 1:\n                            prev[neighbor].append(current_word)\n            if found:\n                break\n        \n        if endWord not in distance:\n            return []\n        \n        # Backtrack to find all paths\n        paths = [[endWord]]\n        while paths[0][0] != beginWord:\n            temp = []\n            for path in paths:\n                current_node = path[0]\n                for parent in prev[current_node]:\n                    temp.append([parent] + path)\n            paths = temp\n        \n        return paths\n", "balanced-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def check(node):\n            if node is None:\n                return 0\n            left_h = check(node.left)\n            if left_h == -1:\n                return -1\n            right_h = check(node.right)\n            if right_h == -1:\n                return -1\n            if abs(left_h - right_h) > 1:\n                return -1\n            return 1 + max(left_h, right_h)\n        \n        return check(root) != -1\n", "power-of-two": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0\n", "subsets-ii": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        res = []\n        self.backtrack(nums, 0, [], res)\n        return res\n    \n    def backtrack(self, nums, start, path, res):\n        res.append(path.copy())\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            self.backtrack(nums, i + 1, path, res)\n            path.pop()\n", "largest-rectangle-in-histogram": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = [-1]\n        max_area = 0\n        n = len(heights)\n        for i in range(n + 1):\n            current_h = heights[i] if i < n else 0\n            while stack[-1] != -1 and current_h < heights[stack[-1]]:\n                h_index = stack.pop()\n                h = heights[h_index]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            if i < n:\n                stack.append(i)\n        return max_area\n", "evaluate-reverse-polish-notation": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for t in tokens:\n            if t in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if t == '+':\n                    res = a + b\n                elif t == '-':\n                    res = a - b\n                elif t == '*':\n                    res = a * b\n                else:  # division case '/'\n                    res = int(a / b)  # truncates towards zero\n                stack.append(res)\n            else:\n                stack.append(int(t))\n        return stack.pop()\n", "perfect-rectangle": "from collections import defaultdict\n\nclass Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not rectangles:\n            return False  # According to constraints, this case won't occur\n        \n        min_x = float('inf')\n        min_y = float('inf')\n        max_a = -float('inf')\n        max_b = -float('inf')\n        \n        total_area = 0\n        corners = defaultdict(int)\n        \n        for rect in rectangles:\n            x, y, a, b = rect\n            # Update the min and max coordinates\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_a = max(max_a, a)\n            max_b = max(max_b, b)\n            \n            # Calculate the area contribution of this rectangle\n            total_area += (a - x) * (b - y)\n            \n            # Record the four corners of the current rectangle\n            for point in [(x, y), (x, b), (a, y), (a, b)]:\n                corners[point] += 1\n        \n        # Calculate the area of the bounding rectangle\n        big_area = (max_a - min_x) * (max_b - min_y)\n        if total_area != big_area:\n            return False\n        \n        # Collect all points with odd counts\n        odd_points = [p for p, cnt in corners.items() if cnt % 2 != 0]\n        if len(odd_points) != 4:\n            return False\n        \n        # Check if these points are exactly the four corners of the bounding rectangle\n        expected = {\n            (min_x, min_y),\n            (min_x, max_b),\n            (max_a, min_y),\n            (max_a, max_b)\n        }\n        actual = set(odd_points)\n        \n        return actual == expected\n", "excel-sheet-column-title": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        res = []\n        while columnNumber > 0:\n            columnNumber -= 1\n            remainder = columnNumber % 26\n            res.append(chr(65 + remainder))\n            columnNumber = columnNumber // 26\n        return ''.join(reversed(res))\n", "maximum-subarray": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0  # According to constraints, this case won't actually happen\n        \n        current_max = global_max = nums[0]\n        \n        for num in nums[1:]:\n            current_max = max(num, current_max + num)\n            if current_max > global_max:\n                global_max = current_max\n        \n        return global_max\n", "sliding-puzzle": "from collections import deque\n\nclass Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        target = \"123450\"\n        # Convert the initial board to a string\n        initial = ''.join(str(num) for row in board for num in row)\n        if initial == target:\n            return 0\n        \n        # Define neighbors for each position (0-5) based on their indices\n        neighbors = [\n            [1, 3],          # neighbors of 0\n            [0, 2, 4],       # neighbors of 1\n            [1, 5],          # neighbors of 2\n            [0, 4],          # neighbors of 3\n            [1, 3, 5],       # neighbors of 4\n            [2, 4]           # neighbors of 5\n        ]\n        \n        visited = set()\n        queue = deque()\n        queue.append((initial, 0))\n        visited.add(initial)\n        \n        while queue:\n            current_state, moves = queue.popleft()\n            if current_state == target:\n                return moves\n            zero_index = current_state.index('0')\n            for neighbor in neighbors[zero_index]:\n                # Create a new state by swapping zero with the neighbor\n                list_state = list(current_state)\n                list_state[zero_index], list_state[neighbor] = list_state[neighbor], list_state[zero_index]\n                new_state = ''.join(list_state)\n                if new_state not in visited:\n                    visited.add(new_state)\n                    queue.append((new_state, moves + 1))\n        \n        return -1\n", "isomorphic-strings": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        s_to_t = {}\n        t_to_s = {}\n        \n        for sc, tc in zip(s, t):\n            if sc in s_to_t:\n                if s_to_t[sc] != tc:\n                    return False\n            else:\n                if tc in t_to_s:\n                    if t_to_s[tc] != sc:\n                        return False\n                else:\n                    s_to_t[sc] = tc\n                    t_to_s[tc] = sc\n        return True\n", "search-in-rotated-sorted-array-ii": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid]:\n                left += 1\n                continue\n            if nums[left] < nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n", "unique-paths-ii": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(obstacleGrid)\n        if m == 0:\n            return 0\n        n = len(obstacleGrid[0])\n        if n == 0:\n            return 0\n        \n        # Check if start or end is blocked\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        # Initialize DP table\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = 1  # Starting point\n        \n        # Fill first row\n        for j in range(1, n):\n            if obstacleGrid[0][j] == 0:\n                dp[0][j] = dp[0][j-1]\n            else:\n                dp[0][j] = 0  # redundant but explicit\n        \n        # Fill first column\n        for i in range(1, m):\n            if obstacleGrid[i][0] == 0:\n                dp[i][0] = dp[i-1][0]\n            else:\n                dp[i][0] = 0  # redundant\n        \n        # Fill the rest of the table\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                else:\n                    dp[i][j] = 0\n        \n        return dp[m-1][n-1]\n", "decode-ways-ii": "class Solution(object):\n    def numDecodings(self, s):\n        MOD = 10**9 + 7\n        n = len(s)\n        if n == 0:\n            return 0\n        \n        prev_prev = 1  # dp[0]\n        # Initialize dp[1]\n        if s[0] == '0':\n            prev = 0\n        else:\n            prev = 9 if s[0] == '*' else 1\n        \n        if n == 1:\n            return prev % MOD\n        \n        for i in range(2, n + 1):\n            current_char = s[i-1]\n            prev_char = s[i-2]\n            \n            # Calculate single contribution\n            single = 0\n            if current_char == '*':\n                single = 9\n            elif current_char == '0':\n                single = 0\n            else:\n                single = 1\n            \n            # Calculate two contribution\n            two = 0\n            first, second = prev_char, current_char\n            if first == '*' and second == '*':\n                two = 15\n            elif first == '*':\n                # first is *, second is a digit (not *)\n                d2 = int(second)\n                if 0 <= d2 <= 6:\n                    two = 2\n                else:\n                    two = 1\n            elif second == '*':\n                # first is a digit, second is *\n                first_d = int(first)\n                if first_d == 1:\n                    two = 9\n                elif first_d == 2:\n                    two = 6\n                else:\n                    two = 0\n            else:\n                # both are digits\n                num = int(first) * 10 + int(second)\n                if 10 <= num <= 26:\n                    two = 1\n                else:\n                    two = 0\n            \n            # Update current value\n            current = (prev * single + prev_prev * two) % MOD\n            prev_prev, prev = prev, current\n        \n        return prev % MOD\n", "3sum-closest": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        closest_sum = float('inf')\n        n = len(nums)\n        for i in range(n - 2):\n            a = nums[i]\n            left = i + 1\n            right = n - 1\n            while left < right:\n                current_sum = a + nums[left] + nums[right]\n                # Check if exact match is found\n                if current_sum == target:\n                    return current_sum\n                # Update closest_sum if current is closer\n                if abs(current_sum - target) < abs(closest_sum - target):\n                    closest_sum = current_sum\n                # Move pointers based on comparison with target\n                if current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest_sum\n", "maximum-depth-of-binary-tree": "class Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if root is None:\n            return 0\n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        return 1 + max(left_depth, right_depth)\n", "intersection-of-two-arrays-ii": "from collections import Counter\n\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        count = Counter(nums1)\n        result = []\n        \n        for num in nums2:\n            if count[num] > 0:\n                result.append(num)\n                count[num] -= 1\n        \n        return result\n", "minimum-absolute-difference-in-bst": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        min_diff = float('inf')\n        prev_val = None\n        stack = []\n        current = root\n\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n\n            if prev_val is not None:\n                diff = current.val - prev_val\n                if diff < min_diff:\n                    min_diff = diff\n            prev_val = current.val\n\n            current = current.right\n\n        return min_diff\n", "find-mode-in-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        self.prev_val = None\n        self.current_count = 0\n        self.max_count = 0\n        self.modes = []\n        \n        self.inorder(root)\n        return self.modes\n    \n    def inorder(self, node):\n        if not node:\n            return\n        \n        self.inorder(node.left)\n        \n        current_val = node.val\n        \n        if current_val == self.prev_val:\n            self.current_count += 1\n        else:\n            self.current_count = 1\n        \n        if self.current_count > self.max_count:\n            self.max_count = self.current_count\n            self.modes = [current_val]\n        elif self.current_count == self.max_count:\n            self.modes.append(current_val)\n        \n        self.prev_val = current_val\n        \n        self.inorder(node.right)\n", "find-the-index-of-the-first-occurrence-in-a-string": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        needle_len = len(needle)\n        haystack_len = len(haystack)\n        \n        if needle_len == 0:\n            return 0\n        if needle_len > haystack_len:\n            return -1\n        \n        for i in range(haystack_len - needle_len + 1):\n            if haystack[i:i+needle_len] == needle:\n                return i\n        \n        return -1\n", "strong-password-checker": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        n = len(password)\n        has_lower = has_upper = has_digit = False\n        for c in password:\n            if c.islower():\n                has_lower = True\n            elif c.isupper():\n                has_upper = True\n            elif c.isdigit():\n                has_digit = True\n        missing = 3 - (has_lower + has_upper + has_digit)\n        \n        # Compute runs\n        runs = []\n        if n > 0:\n            current = password[0]\n            count = 1\n            for c in password[1:]:\n                if c == current:\n                    count += 1\n                else:\n                    runs.append(count)\n                    current = c\n                    count = 1\n            runs.append(count)\n        \n        repeats_needed = sum(k // 3 for k in runs)\n        \n        if n < 6:\n            return max(6 - n, missing, repeats_needed)\n        elif n <= 20:\n            return max(missing, repeats_needed)\n        else:\n            del_needed = n - 20\n            changes = repeats_needed\n            runs = runs.copy()\n            del_available = del_needed\n            \n            while del_available > 0 and changes > 0:\n                best_reduction = 0\n                best_idx = -1\n                # Find the best run to apply deletion\n                for i in range(len(runs)):\n                    k = runs[i]\n                    if k < 3:\n                        continue\n                    current_reduction = (k // 3) - ((k - 1) // 3)\n                    if current_reduction > best_reduction:\n                        best_reduction = current_reduction\n                        best_idx = i\n                if best_reduction == 0:\n                    # No more reduction possible, apply deletions anywhere\n                    found = False\n                    for i in range(len(runs)):\n                        if runs[i] > 0:\n                            best_idx = i\n                            found = True\n                            break\n                    if not found:\n                        break\n                    runs[best_idx] -= 1\n                    del_available -= 1\n                    if runs[best_idx] == 0:\n                        del runs[best_idx]\n                else:\n                    runs[best_idx] -= 1\n                    changes -= best_reduction\n                    del_available -= 1\n                    if runs[best_idx] == 0:\n                        del runs[best_idx]\n            \n            return del_needed + max(missing, changes)\n", "factorial-trailing-zeroes": "class Solution:\n    def trailingZeroes(self, n: int) -> int:\n        count = 0\n        while n > 0:\n            n //= 5\n            count += n\n        return count\n", "zigzag-conversion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n            return s\n        \n        cycle_length = 2 * numRows - 2\n        rows = [''] * numRows\n        \n        for i, c in enumerate(s):\n            rem = i % cycle_length\n            if rem < numRows:\n                row = rem\n            else:\n                row = cycle_length - rem\n            rows[row] += c\n        \n        return ''.join(rows)\n", "trapping-rain-water": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(height) - 1\n        left_max = 0\n        right_max = 0\n        result = 0\n        \n        while left <= right:\n            if left_max <= right_max:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    result += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    result += right_max - height[right]\n                right -= 1\n        \n        return result\n", "find-all-numbers-disappeared-in-an-array": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            num = abs(nums[i])\n            idx = num - 1\n            if nums[idx] > 0:\n                nums[idx] *= -1\n        result = []\n        for i in range(n):\n            if nums[i] > 0:\n                result.append(i + 1)\n        return result\n", "count-of-smaller-numbers-after-self": "class Solution(object):\n    def countSmaller(self, nums):\n        import bisect\n\n        class FenwickTree:\n            def __init__(self, size):\n                self.size = size\n                self.tree = [0] * (self.size + 1)  # 1-based indexing\n\n            def update(self, index, delta):\n                while index <= self.size:\n                    self.tree[index] += delta\n                    index += index & -index\n\n            def query(self, index):\n                res = 0\n                while index > 0:\n                    res += self.tree[index]\n                    index -= index & -index\n                return res\n\n        if not nums:\n            return []\n\n        # Step 1: Generate sorted list of unique elements for coordinate compression\n        sorted_unique = sorted(set(nums))\n        m = len(sorted_unique)\n\n        # Initialize Fenwick Tree\n        ft = FenwickTree(m)\n        counts = []\n\n        # Process elements from the end to the beginning\n        for x in reversed(nums):\n            # Find the rank of x (1-based)\n            rank = bisect.bisect_left(sorted_unique, x) + 1\n            # The count is the sum of elements with rank < current rank\n            count = ft.query(rank - 1)\n            counts.append(count)\n            # Update the Fenwick Tree with the current rank\n            ft.update(rank, 1)\n\n        # Reverse to get the correct order\n        counts.reverse()\n        return counts\n", "set-intersection-size-at-least-two": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort intervals by end, then by start in reverse order\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = 0\n        prev_prev = -float('inf')\n        prev = -float('inf')\n        \n        for s, e in intervals:\n            if prev_prev >= s:\n                # Already have two elements in this interval\n                continue\n            elif prev >= s:\n                # Need to add one more element (e)\n                res += 1\n                prev_prev = prev\n                prev = e\n            else:\n                # Need to add two elements (e-1 and e)\n                res += 2\n                prev_prev = e - 1\n                prev = e\n        \n        return res\n", "symmetric-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import deque\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        queue = deque()\n        queue.append((root.left, root.right))\n        \n        while queue:\n            left, right = queue.popleft()\n            \n            if not left and not right:\n                continue\n            if not left or not right:\n                return False\n            if left.val != right.val:\n                return False\n            \n            queue.append((left.left, right.right))\n            queue.append((left.right, right.left))\n        \n        return True\n", "number-of-atoms": "from collections import defaultdict\n\nclass Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        current = defaultdict(int)\n        i = 0\n        n = len(formula)\n        \n        while i < n:\n            c = formula[i]\n            if c == '(':\n                stack.append(current)\n                current = defaultdict(int)\n                i += 1\n            elif c == ')':\n                i += 1\n                num_str = []\n                while i < n and formula[i].isdigit():\n                    num_str.append(formula[i])\n                    i += 1\n                multiplier = int(''.join(num_str)) if num_str else 1\n                \n                prev = stack.pop()\n                new_current = defaultdict(int)\n                # Add previous counts\n                for k, v in prev.items():\n                    new_current[k] = v\n                # Add current multiplied by multiplier\n                for k, v in current.items():\n                    new_current[k] += v * multiplier\n                current = new_current\n            else:\n                if c.isupper():\n                    name = [c]\n                    i += 1\n                    while i < n and formula[i].islower():\n                        name.append(formula[i])\n                        i += 1\n                    element = ''.join(name)\n                    \n                    num_str = []\n                    while i < n and formula[i].isdigit():\n                        num_str.append(formula[i])\n                        i += 1\n                    count = int(''.join(num_str)) if num_str else 1\n                    current[element] += count\n                else:\n                    # According to problem constraints, this case won't occur\n                    i += 1\n        \n        # Sort the elements lexicographically and build the result string\n        sorted_elements = sorted(current.keys())\n        result = []\n        for elem in sorted_elements:\n            result.append(elem)\n            count = current[elem]\n            if count > 1:\n                result.append(str(count))\n        \n        return ''.join(result)\n", "binary-tree-preorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        stack = []\n        if root:\n            stack.append(root)\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result\n", "power-of-four": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0 and (n & 0x55555555) != 0\n", "invert-binary-tree": "class Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        # Swap the left and right children\n        root.left, root.right = root.right, root.left\n        # Recursively invert the left and right subtrees\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root\n", "generate-parentheses": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        \n        def backtrack(s, left, right):\n            if len(s) == 2 * n:\n                res.append(s)\n                return\n            if left < n:\n                backtrack(s + '(', left + 1, right)\n            if right < left:\n                backtrack(s + ')', left, right + 1)\n        \n        backtrack(\"\", 0, 0)\n        return res\n", "patching-array": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        covered = 0\n        patches = 0\n        index = 0\n        length = len(nums)\n        \n        while covered < n:\n            if index < length and nums[index] <= covered + 1:\n                covered += nums[index]\n                index += 1\n            else:\n                # Need to patch with covered + 1\n                add = covered + 1\n                covered += add\n                patches += 1\n        \n        return patches\n", "longest-valid-parentheses": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        stack = [-1]  # Initialize stack with base index\n        max_len = 0\n        \n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    current_len = i - stack[-1]\n                    max_len = max(max_len, current_len)\n        \n        return max_len\n", "fraction-to-recurring-decimal": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        if numerator == 0:\n            return \"0\"\n        \n        # Determine the sign\n        sign = '-' if (numerator < 0) ^ (denominator < 0) else ''\n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        integer_part = numerator // denominator\n        remainder = numerator % denominator\n        \n        result = [sign + str(integer_part)]\n        \n        if remainder == 0:\n            return result[0]\n        \n        # Process fractional part\n        fractional_digits = []\n        remainder_map = {}\n        index = 0\n        \n        while remainder != 0 and remainder not in remainder_map:\n            remainder_map[remainder] = index\n            remainder *= 10\n            digit = remainder // denominator\n            fractional_digits.append(str(digit))\n            remainder = remainder % denominator\n            index += 1\n        \n        if remainder == 0:\n            result.append('.' + ''.join(fractional_digits))\n        else:\n            # Find the start of the repeating part\n            start = remainder_map[remainder]\n            non_repeating = fractional_digits[:start]\n            repeating = fractional_digits[start:]\n            result.append('.' + ''.join(non_repeating) + '(' + ''.join(repeating) + ')')\n        \n        return ''.join(result)\n", "sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0, head)\n        length = self.get_length(head)\n        sub_size = 1\n        \n        while sub_size < length:\n            prev = dummy\n            curr = dummy.next\n            while curr:\n                # Split into 'a' and 'b' sublists\n                a_head = curr\n                a_tail = a_head\n                for _ in range(sub_size - 1):\n                    if a_tail and a_tail.next:\n                        a_tail = a_tail.next\n                    else:\n                        break  # Reached the end of the list\n                \n                # Split 'a' from the rest\n                b_head = a_tail.next\n                a_tail.next = None  # Terminate 'a' sublist\n                curr = b_head\n                \n                # Now split 'b' sublist\n                b_tail = b_head\n                for _ in range(sub_size - 1):\n                    if b_tail and b_tail.next:\n                        b_tail = b_tail.next\n                    else:\n                        break  # Reached the end of the list\n                \n                # Get the next part after 'b'\n                end_next = None\n                if b_tail:\n                    end_next = b_tail.next\n                    b_tail.next = None  # Terminate 'b' sublist\n                else:\n                    end_next = None\n                \n                # Merge 'a' and 'b'\n                merged_head, merged_tail = self.merge(a_head, b_head)\n                prev.next = merged_head\n                if merged_tail:\n                    merged_tail.next = end_next\n                \n                # Move prev to the end of the merged sublist and curr to the next part\n                prev = merged_tail\n                curr = end_next\n            \n            sub_size *= 2\n        \n        return dummy.next\n    \n    def get_length(self, head):\n        count = 0\n        while head:\n            count += 1\n            head = head.next\n        return count\n    \n    def merge(self, l1, l2):\n        dummy = ListNode(0)\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        tail.next = l1 or l2\n        \n        # Move tail to the end of the merged list\n        while tail.next:\n            tail = tail.next\n        return dummy.next, tail\n", "russian-doll-envelopes": "import bisect\n\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort envelopes by width ascending, and by height descending if widths are equal\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Extract the heights to find the LIS\n        heights = [envelope[1] for envelope in envelopes]\n        \n        tails = []\n        for h in heights:\n            # Find the index where h can replace the first number >= h in tails\n            idx = bisect.bisect_left(tails, h)\n            if idx == len(tails):\n                tails.append(h)\n            else:\n                tails[idx] = h\n        \n        return len(tails)\n", "set-matrix-zeroes": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m = len(matrix)\n        if m == 0:\n            return\n        n = len(matrix[0])\n        \n        first_row_has_zero = False\n        first_col_has_zero = False\n        \n        # Check if the first row has any zeros\n        for j in range(n):\n            if matrix[0][j] == 0:\n                first_row_has_zero = True\n                break\n        \n        # Check if the first column has any zeros\n        for i in range(m):\n            if matrix[i][0] == 0:\n                first_col_has_zero = True\n                break\n        \n        # Use the first row and column as markers for zeros in the inner matrix\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        # Set zeros in the inner matrix based on the markers\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        # Set the first row to zero if needed\n        if first_row_has_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n        \n        # Set the first column to zero if needed\n        if first_col_has_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n", "remove-nth-node-from-end-of-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n        \n        # Move first pointer n steps ahead\n        for _ in range(n):\n            first = first.next\n        \n        # Move both pointers until first reaches the end\n        while first.next is not None:\n            first = first.next\n            second = second.next\n        \n        # Remove the nth node from the end\n        second.next = second.next.next\n        \n        return dummy.next\n", "intersection-of-two-arrays": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        return list(set(nums1) & set(nums2))\n", "super-washing-machines": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        max_excess = 0\n        current_balance = 0\n        max_imbalance = 0\n        for m in machines:\n            excess = m - avg\n            current_balance += excess\n            max_imbalance = max(max_imbalance, abs(current_balance))\n            max_excess = max(max_excess, excess)\n        return max(max_excess, max_imbalance)\n", "kth-smallest-number-in-multiplication-table": "class Solution:\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\n        # Swap to ensure m is the smaller dimension for efficiency\n        if m > n:\n            m, n = n, m\n        \n        low, high = 1, m * n\n        \n        while low <= high:\n            mid = (low + high) // 2\n            count = 0\n            \n            for i in range(1, m + 1):\n                if i > mid:\n                    break  # Further rows will contribute 0\n                temp = mid // i\n                count += min(temp, n)\n            \n            if count < k:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return low\n", "convert-sorted-list-to-binary-search-tree": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        values = []\n        current = head\n        while current:\n            values.append(current.val)\n            current = current.next\n        return self.buildBST(values, 0, len(values) - 1)\n    \n    def buildBST(self, values, start, end):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        node = TreeNode(values[mid])\n        node.left = self.buildBST(values, start, mid - 1)\n        node.right = self.buildBST(values, mid + 1, end)\n        return node\n", "merge-two-sorted-lists": "class Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummy = ListNode(0)\n        current = dummy\n        \n        while list1 and list2:\n            if list1.val <= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n        \n        # Attach the remaining nodes of the non-exhausted list\n        current.next = list1 if list1 else list2\n        \n        return dummy.next\n", "maximal-rectangle": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return 0\n\n        rows = len(matrix)\n        cols = len(matrix[0])\n\n        max_area = 0\n        heights = [0] * cols\n\n        for i in range(rows):\n            # Update the heights array for the current row\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            # Calculate the maximum area for the current histogram\n            current_max = self.largestRectangleArea(heights)\n            if current_max > max_area:\n                max_area = current_max\n\n        return max_area\n\n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        n = len(heights)\n        for i in range(n):\n            while stack and heights[i] < heights[stack[-1]]:\n                top = stack.pop()\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, heights[top] * width)\n            stack.append(i)\n        # Process remaining elements in the stack\n        while stack:\n            top = stack.pop()\n            width = n if not stack else n - stack[-1] - 1\n            max_area = max(max_area, heights[top] * width)\n        return max_area\n", "subsets": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = [[]]\n        for num in nums:\n            result += [subset + [num] for subset in result]\n        return result\n", "find-minimum-in-rotated-sorted-array-ii": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        \n        return nums[left]\n", "valid-number": "import re\n\nclass Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        pattern = r'^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$'\n        return bool(re.fullmatch(pattern, s))\n", "integer-to-roman": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        val_sym = [\n            (1000, 'M'),\n            (900, 'CM'),\n            (500, 'D'),\n            (400, 'CD'),\n            (100, 'C'),\n            (90, 'XC'),\n            (50, 'L'),\n            (40, 'XL'),\n            (10, 'X'),\n            (9, 'IX'),\n            (5, 'V'),\n            (4, 'IV'),\n            (1, 'I'),\n        ]\n        roman = ''\n        for value, symbol in val_sym:\n            while num >= value:\n                roman += symbol\n                num -= value\n            if num == 0:\n                break\n        return roman\n", "find-the-difference": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        sum_s = sum(ord(c) for c in s)\n        sum_t = sum(ord(c) for c in t)\n        return chr(sum_t - sum_s)\n", "sudoku-solver": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        self.backtrack(board)\n    \n    def backtrack(self, board):\n        row, col = self.find_empty(board)\n        if row is None:\n            return True  # Solved\n        \n        for num in range(1, 10):\n            if self.is_valid(board, row, col, num):\n                board[row][col] = str(num)\n                if self.backtrack(board):\n                    return True\n                board[row][col] = '.'  # backtrack\n        return False  # trigger backtracking\n    \n    def find_empty(self, board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    return (i, j)\n        return (None, None)\n    \n    def is_valid(self, board, row, col, num):\n        # Check row\n        for i in range(9):\n            if board[row][i] == str(num):\n                return False\n        # Check column\n        for i in range(9):\n            if board[i][col] == str(num):\n                return False\n        # Check subgrid\n        box_row = 3 * (row // 3)\n        box_col = 3 * (col // 3)\n        for i in range(box_row, box_row + 3):\n            for j in range(box_col, box_col + 3):\n                if board[i][j] == str(num):\n                    return False\n        return True\n", "recover-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.prev = None\n        self.first = None\n        self.second = None\n        \n        def inorder(node):\n            if not node:\n                return\n            inorder(node.left)\n            if self.prev and self.prev.val > node.val:\n                if not self.first:\n                    self.first = self.prev\n                    self.second = node\n                else:\n                    self.second = node\n            self.prev = node\n            inorder(node.right)\n        \n        inorder(root)\n        # Swap the values of the two nodes\n        self.first.val, self.second.val = self.second.val, self.first.val\n", "palindrome-linked-list": "class Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow = head\n        fast = head\n        steps = 0  # To track the number of steps to the middle (needed for comparison)\n        \n        # Find the middle of the list using slow and fast pointers\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            steps += 1\n        \n        # Reverse the second half starting at 'slow'\n        reversed_second = self.reverse_list(slow)\n        \n        # Compare the first half (head to slow's previous node) with the reversed second half\n        current1 = head\n        current2 = reversed_second\n        for _ in range(steps):\n            if current1.val != current2.val:\n                return False\n            current1 = current1.next\n            current2 = current2.next\n        \n        return True\n    \n    def reverse_list(self, node):\n        \"\"\"Helper function to reverse a linked list starting at 'node' and return the new head.\"\"\"\n        prev = None\n        current = node\n        while current:\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        return prev\n", "valid-perfect-square": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num < 1:\n            return False\n        \n        low = 1\n        high = (num // 2) + 1  # Optimized upper bound\n        \n        while low <= high:\n            mid = (low + high) // 2\n            square = mid * mid\n            \n            if square == num:\n                return True\n            elif square < num:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False\n", "counting-bits": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans\n", "remove-linked-list-elements": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        current = dummy\n        \n        while current is not None:\n            if current.next and current.next.val == val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        \n        return dummy.next\n", "scramble-string": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        from functools import lru_cache\n        \n        @lru_cache(maxsize=None)\n        def helper(i1, i2, l):\n            if l == 1:\n                return s1[i1] == s2[i2]\n            \n            s1_sub = s1[i1:i1+l]\n            s2_sub = s2[i2:i2+l]\n            if sorted(s1_sub) != sorted(s2_sub):\n                return False\n            \n            for k in range(1, l):\n                # Case 1: No swap\n                if helper(i1, i2, k) and helper(i1 + k, i2 + k, l - k):\n                    return True\n                # Case 2: Swap\n                if helper(i1, i2 + (l - k), k) and helper(i1 + k, i2, l - k):\n                    return True\n            \n            return False\n        \n        return helper(0, 0, n)\n", "simplify-path": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        parts = path.split('/')\n        for part in parts:\n            if part == '' or part == '.':\n                continue\n            elif part == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(part)\n        return '/' + '/'.join(stack)\n", "word-search-ii": "class TrieNode:\n    __slots__ = ['children', 'word']\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        # Build the Trie\n        root = TrieNode()\n        for word in words:\n            node = root\n            for c in word:\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n            node.word = word\n        \n        result = set()\n        m = len(board)\n        n = len(board[0]) if m else 0\n        \n        def dfs(i, j, node):\n            current_char = board[i][j]\n            if current_char not in node.children:\n                return\n            next_node = node.children[current_char]\n            \n            # Check if we found a word\n            if next_node.word is not None:\n                result.add(next_node.word)\n                next_node.word = None  # Mark as found to avoid duplicates\n            \n            # Mark the current cell as visited\n            temp = board[i][j]\n            board[i][j] = '#'\n            \n            # Explore all four directions\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                x = i + dx\n                y = j + dy\n                if 0 <= x < m and 0 <= y < n:\n                    dfs(x, y, next_node)\n            \n            # Restore the cell's original value\n            board[i][j] = temp\n        \n        # Start DFS from each cell on the board\n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, root)\n        \n        return list(result)\n", "valid-anagram": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        return sorted(s) == sorted(t)\n", "valid-sudoku": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        # Check all rows\n        for row in board:\n            nums = [n for n in row if n != '.']\n            if len(nums) != len(set(nums)):\n                return False\n        \n        # Check all columns\n        for j in range(9):\n            column = []\n            for i in range(9):\n                column.append(board[i][j])\n            nums = [n for n in column if n != '.']\n            if len(nums) != len(set(nums)):\n                return False\n        \n        # Check all 3x3 subgrids\n        for block_row in (0, 3, 6):\n            for block_col in (0, 3, 6):\n                subgrid = []\n                for i in range(3):\n                    for j in range(3):\n                        subgrid.append(board[block_row + i][block_col + j])\n                nums = [n for n in subgrid if n != '.']\n                if len(nums) != len(set(nums)):\n                    return False\n        \n        return True\n", "fizz-buzz": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        answer = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer\n", "reverse-words-in-a-string": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        return ' '.join(reversed(s.split()))\n", "excel-sheet-column-number": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            num = ord(char) - ord('A') + 1\n            result = result * 26 + num\n        return result\n", "candy": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(ratings)\n        if n <= 1:\n            return n\n        \n        candies = [1] * n\n        \n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        # Right to left pass\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)\n", "same-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        # Both nodes are None\n        if not p and not q:\n            return True\n        # One of the nodes is None\n        if not p or not q:\n            return False\n        # Check value and recurse on children\n        return (p.val == q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n", "reorder-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        if not head or not head.next:\n            return\n        \n        # Step 1: Find the middle of the list using slow and fast pointers\n        slow = head\n        fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Step 2: Split the list into two halves\n        second_head = slow.next\n        slow.next = None  # Terminate the first half\n        \n        # Step 3: Reverse the second half\n        prev = None\n        current = second_head\n        while current:\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        reversed_second = prev  # Head of the reversed second half\n        \n        # Step 4: Merge the two halves\n        first = head\n        second = reversed_second\n        while second:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n", "word-pattern": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        char_to_word = {}\n        word_to_char = {}\n        \n        for c, w in zip(pattern, words):\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                if w in word_to_char:\n                    return False\n                char_to_word[c] = w\n                word_to_char[w] = c\n        \n        return True\n", "permutations": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [nums]\n        result = []\n        for i in range(len(nums)):\n            first = nums[i]\n            rest = nums[:i] + nums[i+1:]\n            for p in self.permute(rest):\n                result.append([first] + p)\n        return result\n", "search-a-2d-matrix": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        m = len(matrix)\n        if m == 0:\n            return False\n        n = len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            current = matrix[row][col]\n            if current == target:\n                return True\n            elif current < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n", "add-two-numbers": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current = dummy\n        carry = 0\n        \n        while l1 or l2 or carry != 0:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            sum_total = val1 + val2 + carry\n            new_digit = sum_total % 10\n            carry = sum_total // 10\n            \n            new_node = ListNode(new_digit)\n            current.next = new_node\n            current = current.next\n            \n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        return dummy.next\n", "number-complement": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        return num ^ ((1 << num.bit_length()) - 1)\n", "arithmetic-slices-ii-subsequence": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [{} for _ in range(n)]\n        total = 0\n        \n        for i in range(n):\n            for j in range(i):\n                d = nums[i] - nums[j]\n                cnt = dp[j].get(d, 0)\n                total += cnt\n                dp[i][d] = dp[i].get(d, 0) + cnt + 1\n        \n        return total\n", "text-justification": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        lines = []\n        current_line = []\n        current_length = 0\n\n        for word in words:\n            if not current_line:\n                current_line.append(word)\n                current_length = len(word)\n            else:\n                if current_length + 1 + len(word) > maxWidth:\n                    lines.append(current_line)\n                    current_line = [word]\n                    current_length = len(word)\n                else:\n                    current_line.append(word)\n                    current_length += 1 + len(word)\n        if current_line:\n            lines.append(current_line)\n\n        result = []\n        for i in range(len(lines)):\n            line = lines[i]\n            if i == len(lines) - 1:\n                # Last line: left-justify with single spaces and pad end\n                s = ' '.join(line)\n                padded = s + ' ' * (maxWidth - len(s))\n                result.append(padded)\n            else:\n                num_words = len(line)\n                total_letters = sum(len(word) for word in line)\n                spaces_needed = maxWidth - total_letters\n                if num_words == 1:\n                    # Only one word, add all spaces to the end\n                    result.append(line[0] + ' ' * spaces_needed)\n                else:\n                    num_gaps = num_words - 1\n                    base = spaces_needed // num_gaps\n                    rem = spaces_needed % num_gaps\n                    res = []\n                    for j in range(num_words - 1):\n                        sp = ' ' * (base + 1) if j < rem else ' ' * base\n                        res.append(line[j] + sp)\n                    res.append(line[-1])\n                    result_line = ''.join(res)\n                    result.append(result_line)\n        return result\n", "binary-tree-postorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        stack = []\n        if root:\n            stack.append((root, False))\n        \n        while stack:\n            node, visited = stack.pop()\n            if not node:\n                continue\n            if visited:\n                result.append(node.val)\n            else:\n                # Push back the node with visited=True\n                stack.append((node, True))\n                # Push right first, then left so that left is processed first\n                if node.right:\n                    stack.append((node.right, False))\n                if node.left:\n                    stack.append((node.left, False))\n        \n        return result\n", "container-with-most-water": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            current_height = min(height[left], height[right])\n            current_width = right - left\n            current_area = current_height * current_width\n            if current_area > max_area:\n                max_area = current_area\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area\n", "concatenated-words": "", "base-7": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        is_negative = num < 0\n        num = abs(num)\n        digits = []\n        while num > 0:\n            remainder = num % 7\n            digits.append(remainder)\n            num = num // 7\n        # Reverse to get the correct order\n        digits = digits[::-1]\n        s = ''.join(map(str, digits))\n        if is_negative:\n            s = '-' + s\n        return s\n", "nim-game": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0\n", "n-queens-ii": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        cols = set()\n        diag1 = set()  # row - col\n        diag2 = set()  # row + col\n\n        def backtrack(row):\n            nonlocal count\n            if row == n:\n                count += 1\n                return\n            for col in range(n):\n                if col not in cols and (row - col) not in diag1 and (row + col) not in diag2:\n                    cols.add(col)\n                    diag1.add(row - col)\n                    diag2.add(row + col)\n                    backtrack(row + 1)\n                    cols.remove(col)\n                    diag1.remove(row - col)\n                    diag2.remove(row + col)\n\n        backtrack(0)\n        return count\n", "n-queens": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        cols = []\n        \n        def is_valid(row, col):\n            for i in range(row):\n                if cols[i] == col or abs(cols[i] - col) == row - i:\n                    return False\n            return True\n        \n        def backtrack(row):\n            if row == n:\n                # Create the board configuration\n                solution = []\n                for i in range(n):\n                    board_row = ['.'] * n\n                    board_row[cols[i]] = 'Q'\n                    solution.append(\"\".join(board_row))\n                result.append(solution)\n                return\n            for col in range(n):\n                if is_valid(row, col):\n                    cols.append(col)\n                    backtrack(row + 1)\n                    cols.pop()\n        \n        backtrack(0)\n        return result\n", "word-search": "import collections\n\nclass Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        m = len(board)\n        if m == 0:\n            return False\n        n = len(board[0])\n        \n        # Check if the word has more of any character than the board does\n        board_counts = collections.defaultdict(int)\n        for row in board:\n            for c in row:\n                board_counts[c] += 1\n        word_counts = collections.Counter(word)\n        for c, count in word_counts.items():\n            if board_counts[c] < count:\n                return False\n        \n        def dfs(i, j, word_idx):\n            if board[i][j] != word[word_idx]:\n                return False\n            if word_idx == len(word) - 1:\n                return True\n            # Mark the current cell as visited\n            temp = board[i][j]\n            board[i][j] = '#'\n            found = False\n            # Explore all four directions\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni, nj = i + dx, j + dy\n                if 0 <= ni < m and 0 <= nj < n:\n                    if dfs(ni, nj, word_idx + 1):\n                        found = True\n                        break\n            # Restore the cell's original value\n            board[i][j] = temp\n            return found\n        \n        # Iterate through each cell to find starting points\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and dfs(i, j, 0):\n                    return True\n        return False\n", "merge-sorted-array": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m - 1\n        p2 = n - 1\n        write_idx = m + n - 1\n        \n        # Merge from the end towards the beginning\n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] > nums2[p2]:\n                nums1[write_idx] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[write_idx] = nums2[p2]\n                p2 -= 1\n            write_idx -= 1\n        \n        # If there are remaining elements in nums2, copy them\n        while p2 >= 0:\n            nums1[write_idx] = nums2[p2]\n            p2 -= 1\n            write_idx -= 1\n", "third-maximum-number": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        first = second = third = None\n        for num in nums:\n            if num in (first, second, third):\n                continue\n            if first is None or num > first:\n                third = second\n                second = first\n                first = num\n            elif second is None or num > second:\n                third = second\n                second = num\n            elif third is None or num > third:\n                third = num\n        return third if third is not None else first\n"}