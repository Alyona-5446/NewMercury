{"spiral-matrix": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix:\n            return []\n        \n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom = 0, rows - 1\n        left, right = 0, cols - 1\n        result = []\n        \n        while top <= bottom and left <= right:\n            # Traverse from left to right on top row\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n            \n            # Traverse from top to bottom on right column\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                # Traverse from right to left on bottom row\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                # Traverse from bottom to top on left column\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n        \n        return result\n", "summary-ranges": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        if not nums:\n            return []\n        \n        ranges = []\n        start = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1] + 1:\n                if start == nums[i-1]:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(f\"{start}->{nums[i-1]}\")\n                start = nums[i]\n        \n        # Handle the last range\n        if start == nums[-1]:\n            ranges.append(str(start))\n        else:\n            ranges.append(f\"{start}->{nums[-1]}\")\n        \n        return ranges\n", "distinct-subsequences": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        m, n = len(t), len(s)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Base case: empty t can be formed by deleting all characters of s\n        for j in range(n + 1):\n            dp[0][j] = 1\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if t[i-1] == s[j-1]:\n                    dp[i][j] = dp[i][j-1] + dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1]\n        \n        return dp[m][n]\n", "first-missing-positive": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        \n        # Place each positive integer i at position i-1 if possible\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                # Swap nums[i] with nums[nums[i] - 1]\n                correct_pos = nums[i] - 1\n                nums[i], nums[correct_pos] = nums[correct_pos], nums[i]\n        \n        # Find the first position where the number doesn't match the index\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # If all positions are correct, the missing number is n+1\n        return n + 1\n", "permutation-sequence": "import math\n\nclass Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        numbers = list(range(1, n + 1))\n        permutation = []\n        k -= 1  # convert to 0-based index\n        \n        for i in range(n, 0, -1):\n            fact = math.factorial(i - 1)\n            index = k // fact\n            permutation.append(str(numbers.pop(index)))\n            k %= fact\n        \n        return ''.join(permutation)\n", "two-sum-ii-input-array-is-sorted": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            if current_sum == target:\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return [-1, -1]  # as per problem statement, this line is theoretically unreachable\n", "expression-add-operators": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        \n        def backtrack(index, path, value, prev_operand):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n            \n            for i in range(index, len(num)):\n                if i != index and num[index] == '0':\n                    break  # Skip numbers with leading zeros\n                curr_str = num[index:i+1]\n                curr_num = int(curr_str)\n                if index == 0:\n                    backtrack(i+1, curr_str, curr_num, curr_num)\n                else:\n                    backtrack(i+1, path + '+' + curr_str, value + curr_num, curr_num)\n                    backtrack(i+1, path + '-' + curr_str, value - curr_num, -curr_num)\n                    # For multiplication, subtract the previous operand first and then add (prev_operand * current operand)\n                    backtrack(i+1, path + '*' + curr_str, value - prev_operand + prev_operand * curr_num, prev_operand * curr_num)\n        \n        backtrack(0, \"\", 0, 0)\n        return res\n", "sum-root-to-leaf-numbers": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        def dfs(node, current_sum):\n            if not node:\n                return 0\n            current_sum = current_sum * 10 + node.val\n            if not node.left and not node.right:\n                return current_sum\n            return dfs(node.left, current_sum) + dfs(node.right, current_sum)\n        \n        return dfs(root, 0)\n", "license-key-formatting": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        # Remove all dashes and convert to uppercase\n        cleaned = s.replace('-', '').upper()\n        length = len(cleaned)\n        if length == 0:\n            return \"\"\n        \n        # Determine the length of the first group\n        first_group_length = length % k\n        if first_group_length == 0:\n            first_group_length = k\n        \n        # Build the result\n        result = []\n        result.append(cleaned[:first_group_length])\n        \n        # Process remaining groups\n        for i in range(first_group_length, length, k):\n            result.append(cleaned[i:i+k])\n        \n        return '-'.join(result)\n", "gas-station": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        total_gas = 0\n        total_cost = 0\n        current_gas = 0\n        start_index = 0\n        \n        for i in range(len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n            current_gas += gas[i] - cost[i]\n            if current_gas < 0:\n                start_index = i + 1\n                current_gas = 0\n        \n        if total_gas >= total_cost:\n            return start_index\n        else:\n            return -1\n", "burst-balloons": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Add virtual balloons at the beginning and end\n        nums = [1] + nums + [1]\n        n = len(nums)\n        # DP table initialized to zero\n        dp = [[0] * n for _ in range(n)]\n        \n        # We start from length 2 to n-1 (since first and last are 1s)\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # Iterate all possible last burst positions between left+1 and right-1\n                for k in range(left + 1, right):\n                    # Calculate the coins for bursting k last in the current segment\n                    coins = nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right]\n                    if coins > dp[left][right]:\n                        dp[left][right] = coins\n        return dp[0][n - 1]\n", "plus-one": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        carry = 1\n        for i in range(len(digits)-1, -1, -1):\n            digits[i] += carry\n            if digits[i] == 10:\n                digits[i] = 0\n                carry = 1\n            else:\n                carry = 0\n                break\n        if carry == 1:\n            digits.insert(0, 1)\n        return digits\n", "regular-expression-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        \n        # Handle patterns like a*, a*b*, a*b*c* etc. that can match empty string\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]  # consider zero occurrence\n                    if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                else:\n                    dp[i][j] = False\n        return dp[m][n]\n", "create-maximum-number": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def get_max_subarray(nums, k):\n            stack = []\n            n = len(nums)\n            for i, num in enumerate(nums):\n                while stack and stack[-1] < num and len(stack) + (n - i) > k:\n                    stack.pop()\n                if len(stack) < k:\n                    stack.append(num)\n            return stack\n        \n        def merge(nums1, nums2):\n            merged = []\n            i, j = 0, 0\n            while i < len(nums1) or j < len(nums2):\n                if i < len(nums1) and (j >= len(nums2) or nums1[i] > nums2[j]):\n                    merged.append(nums1[i])\n                    i += 1\n                elif j < len(nums2) and (i >= len(nums1) or nums1[i] < nums2[j]):\n                    merged.append(nums2[j])\n                    j += 1\n                else:\n                    # When equal, choose the one with the larger remaining sequence\n                    if greater(nums1, i, nums2, j):\n                        merged.append(nums1[i])\n                        i += 1\n                    else:\n                        merged.append(nums2[j])\n                        j += 1\n            return merged\n        \n        def greater(nums1, i, nums2, j):\n            n, m = len(nums1), len(nums2)\n            while i < n and j < m and nums1[i] == nums2[j]:\n                i += 1\n                j += 1\n            return j == m or (i < n and nums1[i] > nums2[j])\n        \n        max_res = []\n        m, n = len(nums1), len(nums2)\n        for i in range(max(0, k - n), min(k, m) + 1):\n            sub1 = get_max_subarray(nums1, i)\n            sub2 = get_max_subarray(nums2, k - i)\n            merged = merge(sub1, sub2)\n            if not max_res or greater(merged, 0, max_res, 0):\n                max_res = merged\n        return max_res\n", "perfect-number": "import math\n\nclass Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 1:\n            return False\n        \n        sum_divisors = 1  # 1 is a proper divisor for all numbers > 1\n        sqrt_num = int(math.sqrt(num)) + 1\n        \n        for i in range(2, sqrt_num):\n            if num % i == 0:\n                sum_divisors += i\n                corresponding_divisor = num // i\n                if corresponding_divisor != i:\n                    sum_divisors += corresponding_divisor\n        \n        return sum_divisors == num\n", "fibonacci-number": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        \n        prev_prev = 0  # F(n-2)\n        prev = 1       # F(n-1)\n        \n        for i in range(2, n + 1):\n            current = prev_prev + prev\n            prev_prev = prev\n            prev = current\n        \n        return prev\n", "dungeon-game": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(dungeon)\n        n = len(dungeon[0]) if m > 0 else 0\n        \n        # Create a DP table of size m x n\n        dp = [[0]*n for _ in range(m)]\n        \n        # Start from the bottom-right corner\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        # Fill the last row (only can move right)\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        # Fill the last column (only can move down)\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        # Fill the rest of the table\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                min_required = min(dp[i+1][j], dp[i][j+1])\n                dp[i][j] = max(1, min_required - dungeon[i][j])\n        \n        return dp[0][0]\n", "find-k-th-smallest-pair-distance": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        left = 0\n        right = nums[-1] - nums[0]\n        \n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            i = 0\n            for j in range(n):\n                while nums[j] - nums[i] > mid:\n                    i += 1\n                count += j - i\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n", "number-of-segments-in-a-string": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.split())\n", "reverse-vowels-of-a-string": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        s_list = list(s)\n        left, right = 0, len(s) - 1\n        \n        while left < right:\n            while left < right and s_list[left] not in vowels:\n                left += 1\n            while left < right and s_list[right] not in vowels:\n                right -= 1\n            if left < right:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n        return ''.join(s_list)\n", "longest-consecutive-sequence": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        num_set = set(nums)\n        longest_streak = 0\n        \n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                current_streak = 1\n                \n                while current_num + 1 in num_set:\n                    current_num += 1\n                    current_streak += 1\n                \n                longest_streak = max(longest_streak, current_streak)\n        \n        return longest_streak\n", "missing-number": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        expected_sum = n * (n + 1) // 2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum\n", "word-ladder": "from collections import deque\n\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        if endWord not in wordList:\n            return 0\n        \n        wordSet = set(wordList)\n        queue = deque([(beginWord, 1)])\n        \n        while queue:\n            current_word, level = queue.popleft()\n            for i in range(len(current_word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    next_word = current_word[:i] + c + current_word[i+1:]\n                    if next_word == endWord:\n                        return level + 1\n                    if next_word in wordSet:\n                        wordSet.remove(next_word)\n                        queue.append((next_word, level + 1))\n        return 0\n", "add-binary": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        i = len(a) - 1\n        j = len(b) - 1\n        carry = 0\n        result = []\n        \n        while i >= 0 or j >= 0 or carry:\n            total = carry\n            if i >= 0:\n                total += int(a[i])\n                i -= 1\n            if j >= 0:\n                total += int(b[j])\n                j -= 1\n            carry = total // 2\n            result.append(str(total % 2))\n        \n        return ''.join(reversed(result))\n", "find-first-and-last-position-of-element-in-sorted-array": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        def find_first(nums, target):\n            left, right = 0, len(nums) - 1\n            first = -1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    first = mid\n                    right = mid - 1  # look for earlier occurrences\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return first\n        \n        def find_last(nums, target):\n            left, right = 0, len(nums) - 1\n            last = -1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    last = mid\n                    left = mid + 1  # look for later occurrences\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return last\n        \n        first_occurrence = find_first(nums, target)\n        if first_occurrence == -1:\n            return [-1, -1]\n        last_occurrence = find_last(nums, target)\n        return [first_occurrence, last_occurrence]\n", "remove-duplicates-from-sorted-array": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        k = 1\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1]:\n                nums[k] = nums[i]\n                k += 1\n        return k\n", "jump-game-ii": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        jumps = 0\n        current_end = 0\n        max_reach = 0\n        \n        for i in range(n - 1):\n            max_reach = max(max_reach, i + nums[i])\n            \n            if i == current_end:\n                jumps += 1\n                current_end = max_reach\n                \n                if current_end >= n - 1:\n                    break\n        \n        return jumps\n", "best-time-to-buy-and-sell-stock-iv": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(prices)\n        if n <= 1 or k == 0:\n            return 0\n        \n        # If k is large enough, the problem becomes the same as unlimited transactions\n        if k >= n // 2:\n            max_profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i-1]:\n                    max_profit += prices[i] - prices[i-1]\n            return max_profit\n        \n        # Initialize DP tables\n        buy = [-float('inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i-1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[k]\n", "convert-a-number-to-hexadecimal": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        # Handle two's complement for negative numbers\n        if num < 0:\n            num += 2 ** 32\n        hex_digits = \"0123456789abcdef\"\n        result = []\n        while num > 0:\n            digit = num % 16\n            result.append(hex_digits[digit])\n            num = num // 16\n        return ''.join(reversed(result))\n", "first-unique-character-in-a-string": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        from collections import defaultdict\n        \n        char_count = defaultdict(int)\n        \n        # Count the occurrences of each character\n        for char in s:\n            char_count[char] += 1\n        \n        # Find the first character with count 1\n        for index, char in enumerate(s):\n            if char_count[char] == 1:\n                return index\n        \n        return -1\n", "contains-duplicate-iii": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        if valueDiff < 0 or indexDiff < 0:\n            return False\n        \n        bucket_dict = {}\n        bucket_size = valueDiff + 1\n        \n        for i, num in enumerate(nums):\n            bucket_id = num // bucket_size\n            \n            # Check if the current bucket has a number that satisfies the condition\n            if bucket_id in bucket_dict:\n                return True\n            # Check the previous bucket\n            if (bucket_id - 1) in bucket_dict and abs(num - bucket_dict[bucket_id - 1]) <= valueDiff:\n                return True\n            # Check the next bucket\n            if (bucket_id + 1) in bucket_dict and abs(num - bucket_dict[bucket_id + 1]) <= valueDiff:\n                return True\n            \n            # Add the current number to its bucket\n            bucket_dict[bucket_id] = num\n            \n            # Remove the bucket outside the window of size indexDiff\n            if i >= indexDiff:\n                old_num = nums[i - indexDiff]\n                old_bucket_id = old_num // bucket_size\n                del bucket_dict[old_bucket_id]\n        \n        return False\n", "sort-colors": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low, mid, high = 0, 0, len(nums) - 1\n        \n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n", "max-consecutive-ones": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_count = 0\n        current_count = 0\n        for num in nums:\n            if num == 1:\n                current_count += 1\n                if current_count > max_count:\n                    max_count = current_count\n            else:\n                current_count = 0\n        return max_count\n", "count-complete-tree-nodes": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            # Left subtree is perfect, right subtree is complete\n            return (1 << left_height) + self.countNodes(root.right)\n        else:\n            # Right subtree is perfect (one less height), left subtree is complete\n            return (1 << right_height) + self.countNodes(root.left)\n    \n    def get_height(self, node):\n        height = 0\n        while node:\n            height += 1\n            node = node.left\n        return height\n", "add-strings": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        result = []\n        \n        while i >= 0 or j >= 0 or carry > 0:\n            digit1 = int(num1[i]) if i >= 0 else 0\n            digit2 = int(num2[j]) if j >= 0 else 0\n            \n            total = digit1 + digit2 + carry\n            carry = total // 10\n            current_digit = total % 10\n            result.append(str(current_digit))\n            \n            i -= 1\n            j -= 1\n        \n        return ''.join(reversed(result))\n", "basic-calculator": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        stack = []\n        result = 0\n        num = 0\n        sign = 1  # 1 represents positive, -1 represents negative\n        \n        for char in s:\n            if char.isdigit():\n                num = num * 10 + int(char)\n            elif char == '+':\n                result += sign * num\n                num = 0\n                sign = 1\n            elif char == '-':\n                result += sign * num\n                num = 0\n                sign = -1\n            elif char == '(':\n                stack.append(result)\n                stack.append(sign)\n                result = 0\n                sign = 1\n            elif char == ')':\n                result += sign * num\n                num = 0\n                result *= stack.pop()  # pop the sign before the parenthesis\n                result += stack.pop()  # pop the result before the parenthesis\n            # else for space, do nothing\n        result += sign * num\n        return result\n", "ipo": "import heapq\n\nclass Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        projects = sorted(zip(capital, profits), key=lambda x: x[0])\n        max_heap = []\n        current_capital = w\n        index = 0\n        n = len(projects)\n        \n        for _ in range(k):\n            # Push all projects that can be started with current_capital into the max-heap\n            while index < n and projects[index][0] <= current_capital:\n                capital_req, profit = projects[index]\n                heapq.heappush(max_heap, -profit)  # Using max heap via min heap with negative values\n                index += 1\n            \n            if not max_heap:\n                break  # No more projects can be done\n            \n            # Select the project with the highest profit\n            current_capital += -heapq.heappop(max_heap)\n        \n        return current_capital\n", "valid-parentheses": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        bracket_map = {')': '(', '}': '{', ']': '['}\n        \n        for char in s:\n            if char in bracket_map:\n                # It's a closing bracket\n                if stack:\n                    top_element = stack.pop()\n                else:\n                    top_element = '#'\n                if bracket_map[char] != top_element:\n                    return False\n            else:\n                # It's an opening bracket\n                stack.append(char)\n        \n        return not stack\n", "next-permutation": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        pivot = -1\n        \n        # Step 1: Find the pivot\n        for i in range(n - 1, 0, -1):\n            if nums[i - 1] < nums[i]:\n                pivot = i - 1\n                break\n        \n        if pivot == -1:\n            # The array is in descending order, reverse to get the first permutation\n            nums.reverse()\n            return\n        \n        # Step 2: Find the element to swap with the pivot\n        for i in range(n - 1, pivot, -1):\n            if nums[i] > nums[pivot]:\n                # Swap the elements\n                nums[pivot], nums[i] = nums[i], nums[pivot]\n                break\n        \n        # Step 3: Reverse the elements after the pivot\n        left = pivot + 1\n        right = n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n", "contains-duplicate-ii": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        num_indices = {}\n        for i, num in enumerate(nums):\n            if num in num_indices and abs(i - num_indices[num]) <= k:\n                return True\n            num_indices[num] = i\n        return False\n", "maximum-gap": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return 0\n        \n        min_val, max_val = min(nums), max(nums)\n        if min_val == max_val:\n            return 0\n        \n        n = len(nums)\n        bucket_size = max(1, (max_val - min_val) // (n - 1))\n        bucket_count = (max_val - min_val) // bucket_size + 1\n        buckets = [[None, None] for _ in range(bucket_count)]\n        \n        for num in nums:\n            bucket_idx = (num - min_val) // bucket_size\n            bucket = buckets[bucket_idx]\n            if bucket[0] is None:\n                bucket[0] = bucket[1] = num\n            else:\n                bucket[0] = min(bucket[0], num)\n                bucket[1] = max(bucket[1], num)\n        \n        max_gap = 0\n        prev_max = buckets[0][1]\n        for i in range(1, bucket_count):\n            if buckets[i][0] is not None:\n                max_gap = max(max_gap, buckets[i][0] - prev_max)\n                prev_max = buckets[i][1]\n        \n        return max_gap\n", "binary-tree-level-order-traversal": "from collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(current_level)\n        \n        return result\n", "couples-holding-hands": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        pos = {val: idx for idx, val in enumerate(row)}\n        swaps = 0\n        for i in range(0, len(row), 2):\n            x = row[i]\n            if x % 2 == 0:\n                y = x + 1\n            else:\n                y = x - 1\n            if row[i+1] != y:\n                j = pos[y]\n                row[i+1], row[j] = row[j], row[i+1]\n                pos[row[j]] = j\n                pos[row[i+1]] = i+1\n                swaps += 1\n        return swaps\n", "interleaving-string": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        len_s1, len_s2, len_s3 = len(s1), len(s2), len(s3)\n        if len_s1 + len_s2 != len_s3:\n            return False\n        \n        # Use a 1D DP array to optimize space\n        dp = [False] * (len_s2 + 1)\n        dp[0] = True\n        \n        for j in range(1, len_s2 + 1):\n            dp[j] = dp[j-1] and (s2[j-1] == s3[j-1])\n        \n        for i in range(1, len_s1 + 1):\n            dp[0] = dp[0] and (s1[i-1] == s3[i-1])\n            for j in range(1, len_s2 + 1):\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n        \n        return dp[len_s2]\n", "assign-cookies": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        \n        child_ptr = 0\n        cookie_ptr = 0\n        satisfied = 0\n        \n        while child_ptr < len(g) and cookie_ptr < len(s):\n            if s[cookie_ptr] >= g[child_ptr]:\n                satisfied += 1\n                child_ptr += 1\n                cookie_ptr += 1\n            else:\n                cookie_ptr += 1\n        \n        return satisfied\n", "keyboard-row": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        result = []\n        for word in words:\n            lowercase_word = word.lower()\n            if set(lowercase_word).issubset(row1) or set(lowercase_word).issubset(row2) or set(lowercase_word).issubset(row3):\n                result.append(word)\n        return result\n", "reverse-linked-list-ii": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        pre_left = dummy\n        \n        # Move pre_left to the node before the left position\n        for _ in range(left - 1):\n            pre_left = pre_left.next\n        \n        # Start reversing from current (left node)\n        current = pre_left.next\n        prev = None\n        for _ in range(right - left + 1):\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        \n        # Connect the reversed part back\n        pre_left.next.next = current\n        pre_left.next = prev\n        \n        return dummy.next\n", "shortest-palindrome": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return s\n        rev_s = s[::-1]\n        combined = s + '#' + rev_s\n        lps = [0] * len(combined)\n        \n        for i in range(1, len(combined)):\n            j = lps[i-1]\n            while j > 0 and combined[i] != combined[j]:\n                j = lps[j-1]\n            if combined[i] == combined[j]:\n                j += 1\n            lps[i] = j\n        \n        max_len = lps[-1]\n        return rev_s[:len(s) - max_len] + s\n", "minimum-window-substring": "from collections import defaultdict\n\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if not s or not t or len(s) < len(t):\n            return \"\"\n        \n        # Dictionary to keep a count of all the unique characters in t\n        t_counts = defaultdict(int)\n        for char in t:\n            t_counts[char] += 1\n        \n        required = len(t_counts)  # Number of unique characters in t\n        formed = 0  # Keeps track of how many unique characters in t are present in the current window with the desired frequency\n        \n        # Dictionary to keep a count of all the unique characters in the current window\n        window_counts = defaultdict(int)\n        \n        # Left and right pointers\n        left, right = 0, 0\n        # Variables to remember the minimum window\n        min_len = float('inf')\n        result = \"\"\n        \n        while right < len(s):\n            char = s[right]\n            window_counts[char] += 1\n            \n            # If the current character's count in the window matches the desired count in t, increment formed\n            if char in t_counts and window_counts[char] == t_counts[char]:\n                formed += 1\n            \n            # Try to contract the window from the left\n            while left <= right and formed == required:\n                current_window_len = right - left + 1\n                if current_window_len < min_len:\n                    min_len = current_window_len\n                    result = s[left:right + 1]\n                \n                # The character at the left pointer is being removed from the window\n                left_char = s[left]\n                window_counts[left_char] -= 1\n                if left_char in t_counts and window_counts[left_char] < t_counts[left_char]:\n                    formed -= 1\n                left += 1\n            \n            right += 1\n        \n        return result\n", "self-crossing": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        n = len(distance)\n        if n <= 3:\n            return False\n        \n        for i in range(3, n):\n            # Case 1: current line crosses the line 3 steps behind\n            if distance[i] >= distance[i-2] and distance[i-1] <= distance[i-3]:\n                return True\n            # Case 2: current line crosses the line 4 steps behind\n            if i >= 4:\n                if distance[i-1] == distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                    return True\n            # Case 3: current line crosses the line 5 steps behind\n            if i >= 5:\n                if distance[i-2] >= distance[i-4] and distance[i-3] >= distance[i-1] and distance[i-1] + distance[i-5] >= distance[i-3] and distance[i] + distance[i-4] >= distance[i-2]:\n                    return True\n        return False\n", "remove-duplicates-from-sorted-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        current = head\n        while current and current.next:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        return head\n", "longest-palindrome": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        from collections import defaultdict\n\n        freq = defaultdict(int)\n        for char in s:\n            freq[char] += 1\n        \n        length = 0\n        odd_found = False\n        \n        for count in freq.values():\n            if count % 2 == 0:\n                length += count\n            else:\n                length += count - 1\n                odd_found = True\n        \n        if odd_found:\n            length += 1\n        \n        return length\n", "construct-binary-tree-from-inorder-and-postorder-traversal": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        # Create a hashmap to store the indices of inorder elements for quick lookup\n        in_order_map = {val: idx for idx, val in enumerate(inorder)}\n        \n        def helper(in_start, in_end, post_start, post_end):\n            if in_start > in_end or post_start > post_end:\n                return None\n            \n            root_val = postorder[post_end]\n            root = TreeNode(root_val)\n            \n            root_pos_in_inorder = in_order_map[root_val]\n            \n            left_subtree_size = root_pos_in_inorder - in_start\n            right_subtree_size = in_end - root_pos_in_inorder\n            \n            root.left = helper(in_start, root_pos_in_inorder - 1, post_start, post_start + left_subtree_size - 1)\n            root.right = helper(root_pos_in_inorder + 1, in_end, post_start + left_subtree_size, post_end - 1)\n            \n            return root\n        \n        return helper(0, len(inorder) - 1, 0, len(postorder) - 1)\n", "cut-off-trees-for-golf-event": "from collections import deque\n\nclass Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not forest or not forest[0]:\n            return 0\n        \n        m, n = len(forest), len(forest[0])\n        trees = []\n        \n        # Collect all trees and their coordinates\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        \n        # Sort trees based on their height\n        trees.sort()\n        \n        total_steps = 0\n        start_i, start_j = 0, 0\n        \n        for height, target_i, target_j in trees:\n            # Find the steps from current position (start_i, start_j) to (target_i, target_j)\n            steps = self.bfs(forest, start_i, start_j, target_i, target_j, m, n)\n            if steps == -1:\n                return -1\n            total_steps += steps\n            # Update current position to the tree's position after cutting\n            start_i, start_j = target_i, target_j\n            # Mark the cell as walked through (optional, as problem states once cut, it's 1)\n            forest[start_i][start_j] = 1\n        \n        return total_steps\n    \n    def bfs(self, forest, start_i, start_j, target_i, target_j, m, n):\n        # Handle the case where start is the target\n        if start_i == target_i and start_j == target_j:\n            return 0\n        \n        queue = deque()\n        queue.append((start_i, start_j))\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        visited[start_i][start_j] = True\n        steps = 0\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        while queue:\n            steps += 1\n            level_size = len(queue)\n            for _ in range(level_size):\n                i, j = queue.popleft()\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < m and 0 <= nj < n and forest[ni][nj] != 0 and not visited[ni][nj]:\n                        if ni == target_i and nj == target_j:\n                            return steps\n                        visited[ni][nj] = True\n                        queue.append((ni, nj))\n        return -1\n", "minimum-depth-of-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        left_depth = self.minDepth(root.left) if root.left else float('inf')\n        right_depth = self.minDepth(root.right) if root.right else float('inf')\n        return min(left_depth, right_depth) + 1\n", "count-of-range-sum": "import bisect\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n    \n    def update(self, index, delta=1):\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n    \n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        prefix_sums = [0]\n        current_sum = 0\n        for num in nums:\n            current_sum += num\n            prefix_sums.append(current_sum)\n        \n        # Coordinate compression\n        sorted_sums = sorted(prefix_sums)\n        # Create a mapping from value to its rank\n        # We need to handle all possible s, s-lower, s-upper\n        # So collect all possible values and sort them, then assign ranks\n        sorted_values = []\n        for s in prefix_sums:\n            sorted_values.extend([s, s - lower, s - upper])\n        sorted_values = sorted(set(sorted_values))\n        rank_map = {v: i + 1 for i, v in enumerate(sorted_values)}  # 1-based indexing\n        \n        ft = FenwickTree(len(sorted_values))\n        res = 0\n        # The initial prefix sum is 0, process it first\n        for s in prefix_sums:\n            # The query is for s - upper <= prev_s <= s - lower\n            left = s - upper\n            right = s - lower\n            # Find the ranks\n            left_rank = bisect.bisect_left(sorted_values, left) + 1\n            right_rank = bisect.bisect_right(sorted_values, right)  # because right is included\n            # The number of valid previous sums is query(right_rank) - query(left_rank - 1)\n            count = ft.query(right_rank) - ft.query(left_rank - 1)\n            res += count\n            # Insert current s into Fenwick tree\n            s_rank = rank_map[s]\n            ft.update(s_rank)\n        return res\n", "arranging-coins": "import math\n\nclass Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int((math.sqrt(8 * n + 1) - 1) // 2)\n", "longest-uncommon-subsequence-i": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n", "binary-tree-level-order-traversal-ii": "from collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        \n        while queue:\n            level_size = len(queue)\n            current_level = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(current_level)\n        \n        return result[::-1]\n", "palindrome-number": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        if x < 0:\n            return False\n        original = x\n        reversed_num = 0\n        while x > 0:\n            digit = x % 10\n            reversed_num = reversed_num * 10 + digit\n            x = x // 10\n        return original == reversed_num\n", "decode-ways": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        if s[0] == '0':\n            dp[1] = 0\n        else:\n            dp[1] = 1\n        \n        for i in range(2, n + 1):\n            # Check single digit\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            # Check two digits\n            two_digit = int(s[i-2:i])\n            if 10 <= two_digit <= 26:\n                dp[i] += dp[i-2]\n        return dp[n]\n", "is-subsequence": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        i, j = 0, 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)\n", "gray-code": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        if n == 0:\n            return [0]\n        # Initialize the sequence for n=1\n        sequence = [0, 1]\n        for i in range(2, n+1):\n            # The next sequence is the current sequence followed by the reverse of the current sequence\n            # with 2^(i-1) added to each element of the reversed sequence\n            reversed_sequence = [x + (1 << (i-1)) for x in reversed(sequence)]\n            sequence += reversed_sequence\n        return sequence\n", "climbing-stairs": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]\n", "word-break": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        word_set = set(wordDict)\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True  # empty string\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]\n", "validate-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def validate(node, low=-float('inf'), high=float('inf')):\n            if not node:\n                return True\n            if node.val <= low or node.val >= high:\n                return False\n            return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n        \n        return validate(root)\n", "insert-interval": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n        \n        # Add all intervals that come before the newInterval\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        \n        # Merge overlapping intervals\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n        \n        # Add all remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        \n        return result\n", "palindrome-partitioning": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        def is_palindrome(sub):\n            return sub == sub[::-1]\n        \n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                substring = s[start:end]\n                if is_palindrome(substring):\n                    backtrack(end, path + [substring])\n        \n        result = []\n        backtrack(0, [])\n        return result\n", "smallest-range-covering-elements-from-k-lists": "import heapq\n\nclass Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        min_heap = []\n        current_max = -float('inf')\n        k = len(nums)\n        \n        # Initialize the heap with the first element of each list, and track the current_max\n        for i in range(k):\n            heapq.heappush(min_heap, (nums[i][0], i, 0))\n            current_max = max(current_max, nums[i][0])\n        \n        min_range = [-float('inf'), float('inf')]\n        \n        while True:\n            current_min, list_idx, elem_idx = heapq.heappop(min_heap)\n            \n            # Check if current range is smaller than the found min_range\n            if current_max - current_min < min_range[1] - min_range[0]:\n                min_range = [current_min, current_max]\n            elif current_max - current_min == min_range[1] - min_range[0] and current_min < min_range[0]:\n                min_range = [current_min, current_max]\n            \n            # Move to the next element in the current list\n            if elem_idx + 1 < len(nums[list_idx]):\n                next_elem = nums[list_idx][elem_idx + 1]\n                heapq.heappush(min_heap, (next_elem, list_idx, elem_idx + 1))\n                current_max = max(current_max, next_elem)\n            else:\n                break  # one of the lists is exhausted\n        \n        return min_range\n", "poor-pigs": "import math\n\nclass Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        if buckets == 1:\n            return 0\n        tests = minutesToTest // minutesToDie\n        pigs = 0\n        while (tests + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs\n", "swim-in-rising-water": "import heapq\n\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        # Use Dijkstra's algorithm: priority queue stores (max elevation so far, i, j)\n        heap = []\n        heapq.heappush(heap, (grid[0][0], 0, 0))\n        visited = [[False for _ in range(n)] for _ in range(n)]\n        visited[0][0] = True\n        \n        while heap:\n            current_max, i, j = heapq.heappop(heap)\n            if i == n - 1 and j == n - 1:\n                return current_max\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < n and not visited[ni][nj]:\n                    visited[ni][nj] = True\n                    new_max = max(current_max, grid[ni][nj])\n                    heapq.heappush(heap, (new_max, ni, nj))\n        return -1\n", "unique-paths": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # We use combinatorial approach: (m+n-2 choose m-1) or (m+n-2 choose n-1)\n        total = m + n - 2\n        k = min(m - 1, n - 1)\n        result = 1\n        # Compute combination(total, k)\n        for i in range(1, k + 1):\n            result = result * (total - k + i) // i\n        return result\n", "multiply-strings": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        m, n = len(num1), len(num2)\n        result = [0] * (m + n)\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                product = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                total = product + result[i + j + 1]\n                result[i + j + 1] = total % 10\n                result[i + j] += total // 10\n        \n        # Convert result array to string, skipping leading zeros\n        start = 0\n        while start < len(result) and result[start] == 0:\n            start += 1\n        \n        result_str = ''.join(map(str, result[start:]))\n        return result_str\n", "best-time-to-buy-and-sell-stock-iii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        \n        # Initialize the four states\n        first_buy = -float('inf')\n        first_sell = 0\n        second_buy = -float('inf')\n        second_sell = 0\n        \n        for price in prices:\n            # Update first buy: the max between previous first_buy or buying at current price\n            first_buy = max(first_buy, -price)\n            # Update first sell: the max between previous first_sell or selling the first bought stock at current price\n            first_sell = max(first_sell, first_buy + price)\n            # Update second buy: the max between previous second_buy or buying at current price with the profit from first_sell\n            second_buy = max(second_buy, first_sell - price)\n            # Update second sell: the max between previous second_sell or selling the second bought stock at current price\n            second_sell = max(second_sell, second_buy + price)\n        \n        return second_sell\n", "combination-sum-ii": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        candidates.sort()\n        \n        def backtrack(start, target, path):\n            if target == 0:\n                res.append(path.copy())\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                path.append(candidates[i])\n                backtrack(i + 1, target - candidates[i], path)\n                path.pop()\n        \n        backtrack(0, target, [])\n        return res\n", "detect-capital": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        # Check if all letters are capitals\n        if word == word.upper():\n            return True\n        # Check if all letters are lowercase\n        if word == word.lower():\n            return True\n        # Check if only the first letter is capital and the rest are lowercase\n        if word[0] == word[0].upper() and word[1:] == word[1:].lower():\n            return True\n        return False\n", "best-time-to-buy-and-sell-stock": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        min_price = float('inf')\n        max_profit = 0\n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        return max_profit\n", "binary-tree-inorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        # Recursive approach\n        # if not root:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative approach\n        res = []\n        stack = []\n        current = root\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            res.append(current.val)\n            current = current.right\n        return res\n", "construct-binary-tree-from-preorder-and-inorder-traversal": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not preorder or not inorder:\n            return None\n        \n        root_val = preorder.pop(0)\n        root = TreeNode(root_val)\n        root_index = inorder.index(root_val)\n        \n        root.left = self.buildTree(preorder, inorder[:root_index])\n        root.right = self.buildTree(preorder, inorder[root_index + 1:])\n        \n        return root\n", "remove-invalid-parentheses": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        def is_valid(expr):\n            count = 0\n            for ch in expr:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = list(filter(is_valid, level))\n            if valid:\n                return valid\n            new_level = set()\n            for expr in level:\n                for i in range(len(expr)):\n                    if expr[i] in '()':\n                        new_expr = expr[:i] + expr[i+1:]\n                        new_level.add(new_expr)\n            level = new_level\n", "merge-k-sorted-lists": "import heapq\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        # Create a min-heap\n        heap = []\n        # Use a counter to avoid comparing ListNode objects directly in the heap\n        counter = 0\n        \n        # Initialize the heap with the first node of each list\n        for i in range(len(lists)):\n            if lists[i] is not None:\n                heapq.heappush(heap, (lists[i].val, counter, lists[i]))\n                counter += 1\n        \n        # Create a dummy node to build the result\n        dummy = ListNode(0)\n        current = dummy\n        \n        # Process the heap until it's empty\n        while heap:\n            val, _, node = heapq.heappop(heap)\n            current.next = node\n            current = current.next\n            if node.next is not None:\n                heapq.heappush(heap, (node.next.val, counter, node.next))\n                counter += 1\n        \n        return dummy.next\n", "palindrome-partitioning-ii": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        n = len(s)\n        if n == 0:\n            return 0\n        \n        # Create a 2D array to store if s[i..j] is a palindrome\n        is_palindrome = [[False] * n for _ in range(n)]\n        \n        # Initialize the DP array for minimum cuts\n        dp = [0] * n\n        \n        for i in range(n):\n            min_cut = i  # Maximum cuts needed for s[0..i] is i (each character separate)\n            for j in range(i + 1):\n                if s[j] == s[i] and (i - j < 2 or is_palindrome[j + 1][i - 1]):\n                    is_palindrome[j][i] = True\n                    if j == 0:\n                        min_cut = 0  # No cut needed if s[0..i] is a palindrome\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n        \n        return dp[-1]\n", "preimage-size-of-factorial-zeroes-function": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def count_trailing_zeros(x):\n            count = 0\n            while x > 0:\n                x = x // 5\n                count += x\n            return count\n        \n        left = 0\n        right = 5 * (k + 1)\n        \n        # Find the lower bound: first x where count_trailing_zeros(x) >= k\n        while left < right:\n            mid = (left + right) // 2\n            zeros = count_trailing_zeros(mid)\n            if zeros < k:\n                left = mid + 1\n            else:\n                right = mid\n        \n        lower = left\n        \n        # Find the upper bound: first x where count_trailing_zeros(x) > k\n        left = 0\n        right = 5 * (k + 1)\n        while left < right:\n            mid = (left + right) // 2\n            zeros = count_trailing_zeros(mid)\n            if zeros <= k:\n                left = mid + 1\n            else:\n                right = mid\n        \n        upper = left\n        \n        return upper - lower\n", "palindrome-pairs": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        word_index = {word: i for i, word in enumerate(words)}\n        result = []\n        \n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                if prefix == prefix[::-1]:\n                    suffix_reversed = suffix[::-1]\n                    if suffix_reversed in word_index and word_index[suffix_reversed] != i:\n                        result.append([word_index[suffix_reversed], i])\n                \n                if j != n and suffix == suffix[::-1]:\n                    prefix_reversed = prefix[::-1]\n                    if prefix_reversed in word_index and word_index[prefix_reversed] != i:\n                        result.append([i, word_index[prefix_reversed]])\n        \n        # Remove duplicates like when empty string is involved, but the above might capture (i,j) and (j,i) multiple times\n        # So we need to dedup, but actually the checks above might produce some duplicates when j=0 or j=n in certain cases\n        # For example, in case of empty string, j=0 and j=n (since n=0) will both trigger the checks.\n        # So for the same pair, it might add twice. Hence, we need to deduplicate the result.\n        # Convert each pair to a tuple, then use a set to dedup, then convert back to list.\n        unique_result = []\n        seen = set()\n        for pair in result:\n            tuple_pair = tuple(pair)\n            if tuple_pair not in seen:\n                seen.add(tuple_pair)\n                unique_result.append(list(tuple_pair))\n        \n        return unique_result\n", "convert-sorted-array-to-binary-search-tree": "# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)\n", "contain-virus": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        m, n = len(isInfected), len(isInfected[0])\n        walls = 0\n        \n        while True:\n            # Each iteration is a day\n            regions = []  # list of tuples: (number of uninfected neighbors, wall count, cells in region)\n            affected = []  # list of sets representing affected uninfected cells per region\n            visited = [[False for _ in range(n)] for _ in range(m)]\n            \n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1 and not visited[i][j]:\n                        # BFS to find the region and affected uninfected cells\n                        queue = [(i, j)]\n                        visited[i][j] = True\n                        region_cells = [(i, j)]\n                        affected_set = set()\n                        walls_needed = 0\n                        \n                        while queue:\n                            x, y = queue.pop(0)\n                            for dx, dy in directions:\n                                nx, ny = x + dx, y + dy\n                                if 0 <= nx < m and 0 <= ny < n:\n                                    if isInfected[nx][ny] == 0:\n                                        affected_set.add((nx, ny))\n                                        walls_needed += 1\n                                    elif isInfected[nx][ny] == 1 and not visited[nx][ny]:\n                                        visited[nx][ny] = True\n                                        region_cells.append((nx, ny))\n                                        queue.append((nx, ny))\n                        regions.append((len(affected_set), walls_needed, region_cells))\n                        affected.append(affected_set)\n            \n            if not regions:\n                break  # no more regions to process\n            \n            # Find the region with the most affected uninfected cells\n            max_index = 0\n            max_affected = -1\n            for i in range(len(regions)):\n                if regions[i][0] > max_affected:\n                    max_affected = regions[i][0]\n                    max_index = i\n            \n            # Add walls for this region\n            walls += regions[max_index][1]\n            \n            # Quarantine the region (set to -1)\n            for x, y in regions[max_index][2]:\n                isInfected[x][y] = -1\n            \n            # Spread the virus to other regions\n            for i in range(len(regions)):\n                if i != max_index:\n                    for x, y in affected[i]:\n                        isInfected[x][y] = 1\n        \n        return walls\n", "longest-increasing-path-in-a-matrix": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return 0\n        \n        rows, cols = len(matrix), len(matrix[0])\n        dp = [[0] * cols for _ in range(rows)]  # dp[i][j] stores the longest increasing path starting at (i,j)\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            max_length = 1\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < rows and 0 <= nj < cols and matrix[ni][nj] > matrix[i][j]:\n                    current_length = 1 + dfs(ni, nj)\n                    if current_length > max_length:\n                        max_length = current_length\n            dp[i][j] = max_length\n            return max_length\n        \n        max_path = 0\n        for i in range(rows):\n            for j in range(cols):\n                current_path = dfs(i, j)\n                if current_path > max_path:\n                    max_path = current_path\n        return max_path\n", "number-of-digit-one": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 0:\n            return 0\n        count = 0\n        i = 1  # current digit position (units, tens, hundreds,...)\n        while i <= n:\n            # Split the number into higher, current, and lower parts\n            higher = n // (i * 10)\n            current = (n // i) % 10\n            lower = n % i\n            \n            if current == 0:\n                count += higher * i\n            elif current == 1:\n                count += higher * i + lower + 1\n            else:\n                count += (higher + 1) * i\n            \n            i *= 10\n        return count\n", "word-break-ii": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        wordSet = set(wordDict)\n        memo = {}\n\n        def backtrack(s):\n            if s in memo:\n                return memo[s]\n            if not s:\n                return [\"\"]\n            res = []\n            for word in wordSet:\n                if s.startswith(word):\n                    remaining = s[len(word):]\n                    sub_sentences = backtrack(remaining)\n                    for sentence in sub_sentences:\n                        if sentence:\n                            res.append(word + \" \" + sentence)\n                        else:\n                            res.append(word)\n            memo[s] = res\n            return res\n        \n        return backtrack(s)\n", "binary-tree-zigzag-level-order-traversal": "from collections import deque\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        left_to_right = True  # Flag to indicate the direction\n        \n        while queue:\n            level_size = len(queue)\n            level_nodes = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                level_nodes.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            if not left_to_right:\n                level_nodes = level_nodes[::-1]\n            \n            result.append(level_nodes)\n            left_to_right = not left_to_right\n        \n        return result\n", "binary-watch": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        def count_bits(n):\n            return bin(n).count('1')\n        \n        valid_times = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    time = f\"{h}:{m:02d}\"\n                    valid_times.append(time)\n        return valid_times\n", "pascals-triangle": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0:\n            return []\n        \n        triangle = [[1]]\n        \n        for i in range(1, numRows):\n            prev_row = triangle[i-1]\n            current_row = [1]\n            \n            for j in range(1, i):\n                current_row.append(prev_row[j-1] + prev_row[j])\n            \n            current_row.append(1)\n            triangle.append(current_row)\n        \n        return triangle\n", "power-of-three": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        return 1162261467 % n == 0\n", "binary-tree-maximum-path-sum": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.max_sum = float('-inf')\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            # Recursively get the max gains from left and right subtrees\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            # The price to start a new path where 'node' is the highest node\n            price_newpath = node.val + left_gain + right_gain\n            \n            # Update the global max if it's better\n            self.max_sum = max(self.max_sum, price_newpath)\n            \n            # Return the max gain if continue the same path\n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum\n", "trapping-rain-water-ii": "import heapq\n\nclass Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        heap = []\n        \n        # Push all the boundary cells into the heap\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        res = 0\n        max_height = 0\n        \n        while heap:\n            height, x, y = heapq.heappop(heap)\n            max_height = max(max_height, height)\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                    if heightMap[nx][ny] < max_height:\n                        res += max_height - heightMap[nx][ny]\n                    visited[nx][ny] = True\n                    heapq.heappush(heap, (heightMap[nx][ny], nx, ny))\n        \n        return res\n", "valid-palindrome": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # Initialize an empty list to hold alphanumeric characters\n        filtered_chars = []\n        for char in s:\n            if char.isalnum():\n                filtered_chars.append(char.lower())\n        # Join the list into a string\n        processed_str = ''.join(filtered_chars)\n        # Check if the processed string is equal to its reverse\n        return processed_str == processed_str[::-1]\n", "sliding-window-median": "import heapq\n\nclass Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        max_heap = []  # stores the smaller half, using negative values for max heap\n        min_heap = []   # stores the larger half\n        heap_dict = defaultdict(int)  # to keep track of elements to be removed\n        \n        # Initialize the heaps for the first window\n        for i in range(k):\n            heapq.heappush(max_heap, -nums[i])\n            heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            if len(min_heap) > len(max_heap):\n                heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        \n        medians = []\n        # Function to get the median based on current heaps\n        def get_median():\n            if k % 2 == 1:\n                return float(-max_heap[0])\n            else:\n                return (-max_heap[0] + min_heap[0]) / 2.0\n        \n        medians.append(get_median())\n        \n        for i in range(k, len(nums)):\n            out_num = nums[i - k]\n            in_num = nums[i]\n            \n            # Determine which heap the outgoing number belongs to\n            if out_num <= -max_heap[0]:\n                balance = -1  # it's in max_heap\n            else:\n                balance = 1    # it's in min_heap\n            heap_dict[out_num] += 1  # mark for removal\n            \n            # Incoming number handling\n            if max_heap and in_num <= -max_heap[0]:\n                heapq.heappush(max_heap, -in_num)\n                balance += 1\n            else:\n                heapq.heappush(min_heap, in_num)\n                balance -= 1\n            \n            # Rebalance the heaps\n            if balance < 0:\n                heapq.heappush(max_heap, -heapq.heappop(min_heap))\n                balance += 1\n            elif balance > 0:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n                balance -= 1\n            \n            # Remove elements that are marked for deletion if they are at the top\n            while max_heap and heap_dict.get(-max_heap[0], 0) > 0:\n                val = -heapq.heappop(max_heap)\n                heap_dict[val] -= 1\n                if heap_dict[val] == 0:\n                    del heap_dict[val]\n            \n            while min_heap and heap_dict.get(min_heap[0], 0) > 0:\n                val = heapq.heappop(min_heap)\n                heap_dict[val] -= 1\n                if heap_dict[val] == 0:\n                    del heap_dict[val]\n            \n            # Calculate the median for the current window\n            medians.append(get_median())\n        \n        return medians\n", "rotate-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or k == 0:\n            return head\n        \n        # Step 1: Find the length of the linked list and the tail node\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        # Step 2: Compute the effective k\n        k = k % length\n        if k == 0:\n            return head\n        \n        # Step 3: Find the new tail, which is (length - k - 1) steps from the head\n        new_tail = head\n        for _ in range(length - k - 1):\n            new_tail = new_tail.next\n        \n        # Step 4: The new head is the next node of new_tail\n        new_head = new_tail.next\n        \n        # Step 5: Break the link and form the rotated list\n        new_tail.next = None\n        tail.next = head\n        \n        return new_head\n", "ugly-number": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in [2, 3, 5]:\n            while n % p == 0:\n                n = n // p\n        return n == 1\n", "falling-squares": "class Solution:\n    def fallingSquares(self, positions):\n        # This list will store tuples of (left, right, height) for each square\n        intervals = []\n        res = []\n        max_height = 0\n        \n        for left, size in positions:\n            right = left + size\n            current_height = 0\n            for (l, r, h) in intervals:\n                # Check if the new interval overlaps with any existing interval\n                if not (right <= l or left >= r):\n                    current_height = max(current_height, h)\n            new_height = current_height + size\n            intervals.append((left, right, new_height))\n            max_height = max(max_height, new_height)\n            res.append(max_height)\n        \n        return res\n", "sum-of-left-leaves": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        \n        sum_left = 0\n        \n        if root.left:\n            if not root.left.left and not root.left.right:\n                sum_left += root.left.val\n            else:\n                sum_left += self.sumOfLeftLeaves(root.left)\n        \n        sum_left += self.sumOfLeftLeaves(root.right)\n        \n        return sum_left\n", "max-sum-of-rectangle-no-larger-than-k": "import bisect\n\nclass Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        m = len(matrix)\n        n = len(matrix[0]) if m > 0 else 0\n        max_sum = float('-inf')\n        \n        # Prefer to iterate over the smaller dimension for better time complexity\n        for left in range(n):\n            row_sum = [0] * m\n            for right in range(left, n):\n                # Update the row sum for each row from left to right column\n                for i in range(m):\n                    row_sum[i] += matrix[i][right]\n                \n                # Find the maximum sum no larger than k in the row_sum array\n                prefix_sums = [0]\n                current_sum = 0\n                for num in row_sum:\n                    current_sum += num\n                    # Find the first prefix sum >= current_sum - k\n                    idx = bisect.bisect_left(prefix_sums, current_sum - k)\n                    if idx < len(prefix_sums):\n                        if current_sum - prefix_sums[idx] > max_sum:\n                            max_sum = current_sum - prefix_sums[idx]\n                    # Insert current_sum into the prefix_sums to keep it sorted\n                    bisect.insort(prefix_sums, current_sum)\n                    if max_sum == k:\n                        return k\n        return max_sum\n", "divide-two-integers": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        # Handle overflow case\n        MAX_INT = 2**31 - 1\n        MIN_INT = -2**31\n        \n        if dividend == MIN_INT and divisor == -1:\n            return MAX_INT\n        \n        # Determine the sign of the result\n        negative = (dividend < 0) != (divisor < 0)\n        \n        # Work with absolute values\n        dividend_abs = abs(dividend)\n        divisor_abs = abs(divisor)\n        \n        quotient = 0\n        while dividend_abs >= divisor_abs:\n            temp_divisor = divisor_abs\n            multiple = 1\n            while dividend_abs >= (temp_divisor << 1):\n                if temp_divisor << 1 < temp_divisor:  # Check for overflow\n                    break\n                temp_divisor <<= 1\n                multiple <<= 1\n            dividend_abs -= temp_divisor\n            quotient += multiple\n        \n        if negative:\n            quotient = -quotient\n        \n        # Clamp the result to the 32-bit signed integer range\n        if quotient < MIN_INT:\n            return MIN_INT\n        if quotient > MAX_INT:\n            return MAX_INT\n        return quotient\n", "surrounded-regions": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        # Step 1: Mark all 'O's connected to the border as 'T' using DFS\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        \n        # Check borders\n        for i in range(m):\n            if board[i][0] == 'O':\n                dfs(i, 0)\n            if board[i][n-1] == 'O':\n                dfs(i, n-1)\n        \n        for j in range(n):\n            if board[0][j] == 'O':\n                dfs(0, j)\n            if board[m-1][j] == 'O':\n                dfs(m-1, j)\n        \n        # Step 2: Flip remaining 'O's to 'X' and revert 'T's back to 'O's\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'\n", "two-sum": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        num_to_index = {}\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_to_index:\n                return [num_to_index[complement], index]\n            num_to_index[num] = index\n        return []\n", "24-game": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        EPSILON = 1e-6\n        \n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < EPSILON\n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i == j:\n                        continue\n                    next_nums = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    a, b = nums[i], nums[j]\n                    # Try all possible operations\n                    for op in range(4):\n                        # Skip commutative operations to avoid redundancy\n                        if op < 2 and j > i:\n                            continue\n                        if op == 0:\n                            next_nums.append(a + b)\n                        elif op == 1:\n                            next_nums.append(a * b)\n                        elif op == 2:\n                            next_nums.append(a - b)\n                        elif op == 3:\n                            if abs(b) > EPSILON:\n                                next_nums.append(a / b)\n                            else:\n                                continue\n                        if dfs(next_nums):\n                            return True\n                        next_nums.pop()  # backtrack\n            return False\n        \n        return dfs(cards)\n", "wildcard-matching": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        \n        for j in range(1, n + 1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j-1] == '?':\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1])\n        \n        return dp[m][n]\n", "majority-element": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate\n", "reconstruct-itinerary": "from collections import defaultdict\n\nclass Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        # Create a graph where each node maps to a list of its destinations in sorted order\n        graph = defaultdict(list)\n        for src, dst in sorted(tickets):\n            graph[src].append(dst)\n        \n        itinerary = []\n        def dfs(node):\n            while graph[node]:\n                next_node = graph[node].pop(0)\n                dfs(next_node)\n            itinerary.append(node)\n        \n        dfs(\"JFK\")\n        return itinerary[::-1]\n", "4sum": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        result = []\n        \n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left = j + 1\n                right = n - 1\n                while left < right:\n                    current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                    if current_sum == target:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        left += 1\n                        right -= 1\n                        while left < right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right + 1]:\n                            right -= 1\n                    elif current_sum < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return result\n", "the-skyline-problem": "import heapq\n\nclass Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        events = []\n        for left, right, height in buildings:\n            events.append((left, -height, right))  # start event\n            events.append((right, 0, 0))  # end event, height 0 is ignored\n        \n        # Sort the events\n        events.sort()\n        \n        res = []\n        max_heap = [(0, float('inf'))]  # (negative height, right)\n        heapq.heapify(max_heap)\n        prev_max = 0\n        \n        for x, neg_h, right in events:\n            # Process all buildings that end before x\n            while max_heap and max_heap[0][1] <= x:\n                heapq.heappop(max_heap)\n            \n            if neg_h != 0:\n                heapq.heappush(max_heap, (neg_h, right))\n            \n            current_max = -max_heap[0][0] if max_heap else 0\n            if current_max != prev_max:\n                res.append([x, current_max])\n                prev_max = current_max\n        \n        return res\n", "reverse-string": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n", "reverse-linked-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Iterative solution\n        prev = None\n        current = head\n        while current:\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        return prev\n    \n    def reverseListRecursive(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Recursive solution\n        if not head or not head.next:\n            return head\n        reversed_head = self.reverseListRecursive(head.next)\n        head.next.next = head\n        head.next = None\n        return reversed_head\n", "triangle": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not triangle:\n            return 0\n        \n        # Start from the second last row and move upwards\n        for row in range(len(triangle)-2, -1, -1):\n            for col in range(len(triangle[row])):\n                # Update the current cell with the minimum of the two adjacent cells from the row below\n                triangle[row][col] += min(triangle[row+1][col], triangle[row+1][col+1])\n        \n        return triangle[0][0]\n", "integer-to-english-words": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"Zero\"\n        \n        # Mapping numbers to their word representations\n        units = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \n                 \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \n                \"Eighty\", \"Ninety\"]\n        scales = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        words = []\n        scale_index = 0\n        \n        while num > 0:\n            chunk = num % 1000\n            num = num // 1000\n            if chunk != 0:\n                chunk_words = []\n                hundred = chunk // 100\n                remainder = chunk % 100\n                if hundred > 0:\n                    chunk_words.append(units[hundred] + \" Hundred\")\n                if remainder > 0:\n                    if remainder < 10:\n                        chunk_words.append(units[remainder])\n                    elif 10 <= remainder < 20:\n                        chunk_words.append(teens[remainder - 10])\n                    else:\n                        ten_part = remainder // 10\n                        unit_part = remainder % 10\n                        if ten_part > 0:\n                            chunk_words.append(tens[ten_part])\n                        if unit_part > 0:\n                            chunk_words.append(units[unit_part])\n                if scale_index > 0:\n                    chunk_words.append(scales[scale_index])\n                words.append(' '.join(chunk_words))\n            scale_index += 1\n        \n        # The chunks were processed from least significant to most, so reverse them\n        words.reverse()\n        return ' '.join(words)\n", "k-inverse-pairs-array": "class Solution(object):\n    def kInversePairs(self, n, k):\n        MOD = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = 1  # base case: 0 elements, 0 inverse pairs\n        \n        for current_n in range(1, n + 1):\n            max_possible_k = min(k, current_n * (current_n - 1) // 2)\n            prefix = [0] * (k + 2)\n            prefix[0] = 0\n            for j in range(k + 1):\n                prefix[j + 1] = prefix[j] + dp[current_n - 1][j]\n                prefix[j + 1] %= MOD\n            \n            for current_k in range(0, k + 1):\n                # The maximum i can be min(current_k, current_n - 1)\n                # dp[current_n][current_k] = sum_{i=0 to min(current_k, current_n - 1)} dp[current_n-1][current_k - i]\n                # We can compute this using prefix sums\n                min_i = max(0, current_k - (current_n - 1))\n                max_i = current_k\n                if min_i > max_i:\n                    dp[current_n][current_k] = 0\n                else:\n                    val = (prefix[max_i + 1] - prefix[min_i]) % MOD\n                    dp[current_n][current_k] = val\n        return dp[n][k]\n", "swap-nodes-in-pairs": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Create a dummy node to simplify the head handling\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n            \n            # Swapping\n            first.next = second.next\n            second.next = first\n            prev.next = second\n            \n            # Move to the next pair\n            prev = first\n        \n        return dummy.next\n", "path-sum": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n        # Check if it's a leaf node and the remaining sum matches the leaf's value\n        if not root.left and not root.right:\n            return targetSum == root.val\n        # Recursively check the left and right subtrees with updated targetSum\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n", "partition-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        # Create dummy nodes for the two partitions\n        left_dummy = ListNode(0)\n        right_dummy = ListNode(0)\n        \n        # Pointers to the current end of each partition\n        left_tail = left_dummy\n        right_tail = right_dummy\n        \n        current = head\n        \n        while current is not None:\n            if current.val < x:\n                left_tail.next = current\n                left_tail = left_tail.next\n            else:\n                right_tail.next = current\n                right_tail = right_tail.next\n            current = current.next\n        \n        # Connect the two partitions\n        left_tail.next = right_dummy.next\n        right_tail.next = None\n        \n        return left_dummy.next\n", "redundant-connection-ii": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        n = len(edges)\n        parent = [0] * (n + 1)\n        candidates = []\n        # Step 1: Check if any node has two parents\n        for u, v in edges:\n            if parent[v] != 0:\n                candidates.append([parent[v], v])\n                candidates.append([u, v])\n            else:\n                parent[v] = u\n        \n        # Step 2: If there's a node with two parents, process candidates\n        if candidates:\n            # Try removing the later edge first\n            # Check if the graph is a tree without the last candidate\n            u, v = candidates[1]\n            root = 0\n            seen = set()\n            # Check if the remaining edges form a cycle\n            # Temporarily remove the candidate edge\n            temp_edges = [edge for edge in edges if edge != [u, v]]\n            # Now check if the remaining edges have a cycle\n            dsu = UnionFind(n)\n            has_cycle = False\n            for a, b in temp_edges:\n                if not dsu.union(a, b):\n                    has_cycle = True\n                    break\n            if not has_cycle:\n                return [u, v]\n            else:\n                return candidates[0]\n        else:\n            # No node has two parents, so find the edge creating the cycle\n            dsu = UnionFind(n)\n            for u, v in edges:\n                if not dsu.union(u, v):\n                    return [u, v]\n        return []\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = [i for i in range(size + 1)]\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        fx = self.find(x)\n        fy = self.find(y)\n        if fx == fy:\n            return False\n        self.parent[fy] = fx\n        return True\n", "permutations-ii": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()  # Sort to easily skip duplicates\n        res = []\n        used = [False] * len(nums)\n        self.backtrack(nums, [], used, res)\n        return res\n    \n    def backtrack(self, nums, path, used, res):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                continue\n            used[i] = True\n            path.append(nums[i])\n            self.backtrack(nums, path, used, res)\n            path.pop()\n            used[i] = False\n", "add-digits": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 0\n        return 9 if num % 9 == 0 else num % 9\n", "single-number": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n", "length-of-last-word": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # Split the string into words, handling multiple spaces\n        words = s.split()\n        # If there are no words, return 0 (but constraints say at least one word exists)\n        if not words:\n            return 0\n        # Return the length of the last word\n        return len(words[-1])\n", "cherry-pickup": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        n = len(grid)\n        memo = {}\n        \n        def dp(r1, c1, r2):\n            c2 = r1 + c1 - r2\n            if (r1 == n - 1 and c1 == n - 1):\n                return grid[r1][c1]\n            if r1 >= n or c1 >= n or r2 >= n or c2 >= n:\n                return float('-inf')\n            if grid[r1][c1] == -1 or grid[r2][c2] == -1:\n                return float('-inf')\n            if (r1, c1, r2) in memo:\n                return memo[(r1, c1, r2)]\n            \n            res = grid[r1][c1]\n            if r1 != r2 or c1 != c2:\n                res += grid[r2][c2]\n            \n            res += max(\n                dp(r1 + 1, c1, r2 + 1),  # both down\n                dp(r1, c1 + 1, r2),       # first right, second down (since r2 + c2 must equal r1 + c1)\n                dp(r1 + 1, c1, r2),       # first down, second right\n                dp(r1, c1 + 1, r2 + 1)    # both right\n            )\n            memo[(r1, c1, r2)] = res\n            return res\n        \n        result = max(0, dp(0, 0, 0))\n        return result\n", "student-attendance-record-ii": "class Solution(object):\n    def checkRecord(self, n):\n        MOD = 10**9 + 7\n        # dp[i][j][k] represents the number of sequences of length i with j 'A's and ending with k consecutive 'L's\n        # Initialize dp for sequences of length 0 (base case)\n        # For n=0, the only possibility is empty string, but since we build from length 1, we start with length 1\n        # We'll use a DP table that is updated iteratively\n        \n        # We can optimize space by only keeping track of the previous step's DP values\n        # Initialize for sequences of length 1\n        # j can be 0 or 1 (0 or 1 'A's)\n        # k can be 0, 1 (since for length 1, consecutive L's can be 0 or 1)\n        dp = [[0] * 3 for _ in range(2)]\n        # for length 1:\n        dp[0][0] = 1  # 'P'\n        dp[0][1] = 1  # 'L'\n        dp[1][0] = 1  # 'A'\n        \n        for _ in range(2, n+1):\n            new_dp = [[0] * 3 for _ in range(2)]\n            # For sequences ending with P:\n            for a in range(2):\n                for l in range(3):\n                    new_dp[a][0] = (new_dp[a][0] + dp[a][l]) % MOD\n            \n            # For sequences ending with L:\n            for a in range(2):\n                for l in range(1, 3):\n                    new_dp[a][l] = (new_dp[a][l] + dp[a][l-1]) % MOD\n            \n            # For sequences ending with A:\n            for l in range(3):\n                new_dp[1][0] = (new_dp[1][0] + dp[0][l]) % MOD\n            \n            dp = new_dp\n        \n        # Sum all possible states in dp\n        total = 0\n        for a in range(2):\n            for l in range(3):\n                total = (total + dp[a][l]) % MOD\n        return total\n", "happy-number": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            sum_squares = 0\n            while n > 0:\n                digit = n % 10\n                sum_squares += digit * digit\n                n = n // 10\n            n = sum_squares\n        return n == 1\n", "search-insert-position": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n", "jump-game": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        max_reach = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n            if max_reach >= n - 1:\n                return True\n        return True\n", "minimum-path-sum": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(grid)\n        n = len(grid[0]) if m > 0 else 0\n        \n        # Initialize a DP table with the same dimensions as grid\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        \n        # Fill the first row\n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        # Fill the first column\n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        # Fill the rest of the table\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]\n", "count-and-say": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        if n == 1:\n            return \"1\"\n        previous = self.countAndSay(n - 1)\n        result = []\n        count = 1\n        for i in range(1, len(previous)):\n            if previous[i] == previous[i-1]:\n                count += 1\n            else:\n                result.append(str(count) + previous[i-1])\n                count = 1\n        result.append(str(count) + previous[-1])\n        return ''.join(result)\n", "split-array-largest-sum": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        def is_possible(max_sum):\n            current_sum = 0\n            splits = 1\n            for num in nums:\n                current_sum += num\n                if current_sum > max_sum:\n                    splits += 1\n                    current_sum = num\n                    if splits > k:\n                        return False\n            return True\n        \n        left = max(nums)\n        right = sum(nums)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if is_possible(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n", "search-in-rotated-sorted-array": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            \n            # Check if the left half is sorted\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n", "letter-combinations-of-a-phone-number": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        combinations = ['']\n        for digit in digits:\n            current_letters = digit_to_letters[digit]\n            new_combinations = []\n            for combination in combinations:\n                for letter in current_letters:\n                    new_combinations.append(combination + letter)\n            combinations = new_combinations\n        return combinations\n", "combination-sum": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        \n        def backtrack(start, path, remaining):\n            if remaining == 0:\n                result.append(path[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remaining:\n                    continue\n                path.append(candidates[i])\n                backtrack(i, path, remaining - candidates[i])\n                path.pop()\n        \n        backtrack(0, [], target)\n        return result\n", "find-the-closest-palindrome": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        num = int(n)\n        length = len(n)\n        candidates = set()\n        \n        # Generate candidates of the form 10^n + 1 and 10^(n-1) - 1\n        candidates.add(10 ** (length) + 1)\n        candidates.add(10 ** (length - 1) - 1)\n        \n        # Get the first half and generate candidates by mirroring\n        half = (length + 1) // 2\n        prefix = n[:half]\n        prefix_num = int(prefix)\n        \n        for delta in (-1, 0, 1):\n            new_prefix = str(prefix_num + delta)\n            if length % 2 == 0:\n                candidate = new_prefix + new_prefix[::-1]\n            else:\n                candidate = new_prefix + new_prefix[:-1][::-1]\n            candidates.add(int(candidate))\n        \n        # Remove the original number if it's a palindrome itself\n        candidates.discard(num)\n        \n        # Find the candidate with the minimal absolute difference\n        min_diff = float('inf')\n        result = 0\n        for candidate in sorted(candidates):\n            diff = abs(candidate - num)\n            if diff < min_diff:\n                min_diff = diff\n                result = candidate\n            elif diff == min_diff and candidate < result:\n                result = candidate\n        \n        return str(result)\n", "spiral-matrix-ii": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        num = 1\n        \n        while left <= right and top <= bottom:\n            # Traverse from left to right on top\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            # Traverse from top to bottom on right\n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            if top <= bottom:\n                # Traverse from right to left on bottom\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            \n            if left <= right:\n                # Traverse from bottom to top on left\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n                \n        return matrix\n", "reverse-integer": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        sign = -1 if x < 0 else 1\n        x_abs = abs(x)\n        reversed_num = 0\n        \n        while x_abs != 0:\n            digit = x_abs % 10\n            reversed_num = reversed_num * 10 + digit\n            x_abs = x_abs // 10\n        \n        reversed_num *= sign\n        \n        # Check for 32-bit integer overflow\n        if reversed_num < -2**31 or reversed_num > 2**31 - 1:\n            return 0\n        else:\n            return reversed_num\n", "rotate-image": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        \n        # Step 1: Transpose the matrix\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # Step 2: Reverse each row\n        for i in range(n):\n            matrix[i].reverse()\n", "maximum-product-subarray": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        current_max = nums[0]\n        current_min = nums[0]\n        \n        for num in nums[1:]:\n            temp = current_max\n            current_max = max(num, current_max * num, current_min * num)\n            current_min = min(num, temp * num, current_min * num)\n            \n            max_product = max(max_product, current_max)\n        \n        return max_product\n", "frog-jump": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        stone_positions = {stone: set() for stone in stones}\n        stone_positions[0].add(0)\n        \n        for current in stones:\n            for k in stone_positions[current]:\n                for step in [k - 1, k, k + 1]:\n                    if step > 0 and current + step in stone_positions:\n                        stone_positions[current + step].add(step)\n        \n        return len(stone_positions[stones[-1]]) > 0\n", "relative-ranks": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        # Create a list of tuples containing the score and original index\n        indexed_scores = [(s, i) for i, s in enumerate(score)]\n        # Sort the list in descending order of score\n        indexed_scores.sort(reverse=True, key=lambda x: x[0])\n        \n        # Initialize the result list with empty strings\n        result = [\"\"] * len(score)\n        \n        for rank in range(len(indexed_scores)):\n            original_index = indexed_scores[rank][1]\n            if rank == 0:\n                result[original_index] = \"Gold Medal\"\n            elif rank == 1:\n                result[original_index] = \"Silver Medal\"\n            elif rank == 2:\n                result[original_index] = \"Bronze Medal\"\n            else:\n                result[original_index] = str(rank + 1)\n        \n        return result\n", "longest-substring-without-repeating-characters": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        char_set = set()\n        left = 0\n        max_length = 0\n        \n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length\n", "substring-with-concatenation-of-all-words": "from collections import defaultdict\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not words or not s:\n            return []\n        \n        word_len = len(words[0])\n        num_words = len(words)\n        total_len = word_len * num_words\n        s_len = len(s)\n        \n        if s_len < total_len:\n            return []\n        \n        word_count = defaultdict(int)\n        for word in words:\n            word_count[word] += 1\n        \n        result = []\n        \n        for i in range(word_len):\n            left = i\n            current_count = defaultdict(int)\n            count = 0\n            for j in range(i, s_len - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_count:\n                    current_count[word] += 1\n                    count += 1\n                    while current_count[word] > word_count[word]:\n                        left_word = s[left:left+word_len]\n                        current_count[left_word] -= 1\n                        count -= 1\n                        left += word_len\n                    if count == num_words:\n                        result.append(left)\n                        left_word = s[left:left+word_len]\n                        current_count[left_word] -= 1\n                        count -= 1\n                        left += word_len\n                else:\n                    current_count.clear()\n                    count = 0\n                    left = j + word_len\n        return result\n", "max-chunks-to-make-sorted-ii": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return 0\n        \n        # Precompute the max from left to right\n        max_left = [0] * n\n        max_left[0] = arr[0]\n        for i in range(1, n):\n            max_left[i] = max(max_left[i-1], arr[i])\n        \n        # Precompute the min from right to left\n        min_right = [0] * n\n        min_right[-1] = arr[-1]\n        for i in range(n-2, -1, -1):\n            min_right[i] = min(min_right[i+1], arr[i])\n        \n        res = 0\n        for i in range(n-1):\n            if max_left[i] <= min_right[i+1]:\n                res += 1\n        \n        return res + 1\n", "insertion-sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)  # Dummy node to serve as the starting point of the sorted list\n        current = head       # Current node to be inserted\n        \n        while current:\n            prev = dummy\n            next_node = current.next  # Store the next node before we change current.next\n            \n            # Find the correct position to insert the current node\n            while prev.next and prev.next.val < current.val:\n                prev = prev.next\n            \n            # Insert the current node into the sorted part\n            current.next = prev.next\n            prev.next = current\n            \n            # Move to the next node in the original list\n            current = next_node\n        \n        return dummy.next\n", "remove-duplicates-from-sorted-list-ii": "class Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # Create a dummy node to handle cases where the head is part of duplicates\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while head:\n            # If current node has duplicates, skip all nodes with the same value\n            if head.next and head.val == head.next.val:\n                # Move head to the last duplicate node\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                # Skip all duplicates\n                prev.next = head.next\n            else:\n                # No duplicates, move prev to the current node\n                prev = prev.next\n            # Move to the next node\n            head = head.next\n        \n        return dummy.next\n", "3sum": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        n = len(nums)\n        \n        for i in range(n - 2):\n            # Skip duplicate elements for i\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            \n            left, right = i + 1, n - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if current_sum == 0:\n                    result.append([nums[i], nums[left], nums[right]])\n                    # Skip duplicates for left and right\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif current_sum < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return result\n", "edit-distance": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        m = len(word1)\n        n = len(word2)\n        # Create a DP table of size (m+1) x (n+1)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        # Base cases\n        for i in range(m + 1):\n            dp[i][0] = i  # word2 is empty, delete all characters in word1\n        for j in range(n + 1):\n            dp[0][j] = j  # word1 is empty, insert all characters of word2\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i][j - 1],    # Insert\n                                      dp[i - 1][j],     # Delete\n                                      dp[i - 1][j - 1])  # Replace\n        return dp[m][n]\n", "hamming-distance": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        xor = x ^ y\n        distance = 0\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance\n", "binary-tree-paths": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        def construct_paths(node, path, paths):\n            if node:\n                path += str(node.val)\n                if not node.left and not node.right:  # if it's a leaf\n                    paths.append(path)  # add the path to paths\n                else:\n                    path += \"->\"  # extend the path for children\n                    construct_paths(node.left, path, paths)\n                    construct_paths(node.right, path, paths)\n        \n        paths = []\n        construct_paths(root, \"\", paths)\n        return paths\n", "reverse-pairs": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def merge_sort(nums, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(nums, start, mid) + merge_sort(nums, mid + 1, end)\n            j = mid + 1\n            # Count the number of reverse pairs\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n            # Merge the two halves\n            nums[start:end+1] = sorted(nums[start:end+1])\n            return count\n        \n        return merge_sort(nums, 0, len(nums) - 1)\n", "reaching-points": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                if ty == sy:\n                    return (tx - sx) % ty == 0\n                tx %= ty\n            else:\n                if tx == sx:\n                    return (ty - sy) % tx == 0\n                ty %= tx\n        return False\n", "compare-version-numbers": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        # Split the versions into revisions\n        v1_revisions = version1.split('.')\n        v2_revisions = version2.split('.')\n        \n        # Determine the maximum length between the two versions\n        max_len = max(len(v1_revisions), len(v2_revisions))\n        \n        for i in range(max_len):\n            # Get the current revision for each version, default to 0 if out of bounds\n            v1 = int(v1_revisions[i]) if i < len(v1_revisions) else 0\n            v2 = int(v2_revisions[i]) if i < len(v2_revisions) else 0\n            \n            if v1 < v2:\n                return -1\n            elif v1 > v2:\n                return 1\n        \n        # If all revisions are equal\n        return 0\n", "best-time-to-buy-and-sell-stock-ii": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        max_profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i-1]:\n                max_profit += prices[i] - prices[i-1]\n        return max_profit\n", "course-schedule-iii": "import heapq\n\nclass Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort courses by their deadline\n        courses.sort(key=lambda x: x[1])\n        max_heap = []\n        time = 0\n        for duration, last_day in courses:\n            if time + duration <= last_day:\n                heapq.heappush(max_heap, -duration)\n                time += duration\n            elif max_heap and -max_heap[0] > duration:\n                # Replace the longest duration course with the current one\n                longest = -heapq.heappop(max_heap)\n                time -= longest\n                time += duration\n                heapq.heappush(max_heap, -duration)\n        return len(max_heap)\n", "reverse-nodes-in-k-group": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        current = head\n        \n        def get_length(node):\n            length = 0\n            while node:\n                length += 1\n                node = node.next\n            return length\n        \n        length = get_length(head)\n        for i in range(length // k):\n            # Reverse each group of size k\n            last = prev.next\n            current = last.next\n            for j in range(1, k):\n                last.next = current.next\n                current.next = prev.next\n                prev.next = current\n                current = last.next\n            prev = last\n        return dummy.next\n", "repeated-substring-pattern": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                substring = s[:i]\n                if substring * (n // i) == s:\n                    return True\n        return False\n", "unique-binary-search-trees": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # Initialize a DP array where dp[i] represents the number of unique BSTs for i nodes\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case: 1 tree (empty tree)\n        dp[1] = 1  # Base case: 1 tree with one node\n        \n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        \n        return dp[n]\n", "single-number-ii": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ones = 0\n        twos = 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones\n", "stickers-to-spell-word": "from collections import deque\n\nclass Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        # Preprocess each sticker into a character count dictionary\n        sticker_counts = []\n        for sticker in stickers:\n            count = {}\n            for c in sticker:\n                count[c] = count.get(c, 0) + 1\n            sticker_counts.append(count)\n        \n        # Initialize a queue for BFS. Each element is a tuple (remaining_target, steps)\n        # Start with the full target and 0 steps\n        queue = deque()\n        queue.append((target, 0))\n        \n        # A set to keep track of visited states to avoid reprocessing\n        visited = set()\n        visited.add(target)\n        \n        while queue:\n            remaining, steps = queue.popleft()\n            \n            # If remaining is empty, return steps\n            if not remaining:\n                return steps\n            \n            # Try every sticker to see if it can contribute to the remaining characters\n            for sticker in sticker_counts:\n                # Check if the sticker has any characters in common with remaining\n                # If not, skip this sticker as it's useless for the current remaining\n                if not self.has_common_char(sticker, remaining):\n                    continue\n                \n                # Build the new remaining string after applying the current sticker\n                new_remaining = self.get_new_remaining(sticker, remaining)\n                \n                if new_remaining not in visited:\n                    visited.add(new_remaining)\n                    queue.append((new_remaining, steps + 1))\n        \n        return -1\n    \n    def has_common_char(self, sticker, remaining):\n        # Check if the sticker has any characters that are in remaining\n        for c in remaining:\n            if c in sticker and sticker[c] > 0:\n                return True\n        return False\n    \n    def get_new_remaining(self, sticker, remaining):\n        # Create a frequency count of the remaining characters\n        remaining_count = {}\n        for c in remaining:\n            remaining_count[c] = remaining_count.get(c, 0) + 1\n        \n        # Subtract the sticker's characters from remaining_count\n        for c in sticker:\n            if c in remaining_count:\n                remaining_count[c] -= sticker[c]\n                if remaining_count[c] <= 0:\n                    del remaining_count[c]\n        \n        # Reconstruct the new remaining string\n        new_remaining = []\n        for c in remaining:\n            if c in remaining_count and remaining_count[c] > 0:\n                new_remaining.append(c)\n                remaining_count[c] -= 1\n        \n        return ''.join(new_remaining)\n", "strange-printer": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i+1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    min_turns = float('inf')\n                    for k in range(i, j):\n                        min_turns = min(min_turns, dp[i][k] + dp[k+1][j])\n                    dp[i][j] = min_turns\n        return dp[0][n-1]\n", "sqrtx": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x == 0 or x == 1:\n            return x\n        \n        left, right = 1, x\n        res = 0\n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n                res = mid\n            else:\n                right = mid - 1\n        return res\n", "roman-to-integer": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        total = 0\n        n = len(s)\n        for i in range(n):\n            if i < n - 1 and roman_map[s[i]] < roman_map[s[i+1]]:\n                total -= roman_map[s[i]]\n            else:\n                total += roman_map[s[i]]\n        return total\n", "contains-duplicate": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n", "sliding-window-maximum": "from collections import deque\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return []\n        if k == 1:\n            return nums\n        \n        deq = deque()\n        result = []\n        \n        for i in range(len(nums)):\n            # Remove indices of elements not in the current window\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n            \n            # Remove indices of elements smaller than the current element\n            while deq and nums[deq[-1]] < nums[i]:\n                deq.pop()\n            \n            deq.append(i)\n            \n            # Add to result once the window size is reached\n            if i >= k - 1:\n                result.append(nums[deq[0]])\n        \n        return result\n", "median-of-two-sorted-arrays": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        # Ensure nums1 is the smaller array to perform binary search on the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        left, right = 0, m\n        total_length = m + n\n        half = (total_length + 1) // 2  # The +1 ensures it works for both even and odd total lengths\n        \n        while left <= right:\n            # Partition nums1\n            i = (left + right) // 2\n            # Partition nums2 such that left partitions have exactly half elements\n            j = half - i\n            \n            # Handle cases where i or j might be out of bounds\n            nums1_left = nums1[i-1] if i > 0 else float('-inf')\n            nums1_right = nums1[i] if i < m else float('inf')\n            nums2_left = nums2[j-1] if j > 0 else float('-inf')\n            nums2_right = nums2[j] if j < n else float('inf')\n            \n            # Check if the partition is correct\n            if nums1_left <= nums2_right and nums2_left <= nums1_right:\n                # Calculate the median\n                if total_length % 2 == 1:\n                    return max(nums1_left, nums2_left)\n                else:\n                    return (max(nums1_left, nums2_left) + min(nums1_right, nums2_right)) / 2.0\n            elif nums1_left > nums2_right:\n                # Move the partition in nums1 leftwards\n                right = i - 1\n            else:\n                # Move the partition in nums1 rightwards\n                left = i + 1\n        return 0.0\n", "find-minimum-in-rotated-sorted-array": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n", "pascals-triangle-ii": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        row = [1] * (rowIndex + 1)\n        for i in range(1, rowIndex):\n            for j in range(i, 0, -1):\n                row[j] += row[j - 1]\n        return row\n", "path-sum-ii": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        self.dfs(root, targetSum, [], result)\n        return result\n    \n    def dfs(self, node, remaining_sum, path, result):\n        if not node:\n            return\n        path.append(node.val)\n        if not node.left and not node.right and remaining_sum == node.val:\n            result.append(list(path))\n        self.dfs(node.left, remaining_sum - node.val, path, result)\n        self.dfs(node.right, remaining_sum - node.val, path, result)\n        path.pop()\n", "construct-the-rectangle": "import math\n\nclass Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        width = int(math.sqrt(area))\n        while width > 0:\n            if area % width == 0:\n                return [area // width, width]\n            width -= 1\n        return [area, 1]\n", "word-ladder-ii": "from collections import defaultdict, deque\n\nclass Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        # To facilitate BFS\n        adjacency = defaultdict(list)\n        \n        # BFS to build the adjacency graph and find the shortest paths\n        visited = defaultdict(int)\n        q = deque([beginWord])\n        visited[beginWord] = 0\n        found = False\n        level = 0\n        \n        while q and not found:\n            level += 1\n            for _ in range(len(q)):\n                word = q.popleft()\n                for i in range(len(word)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        next_word = word[:i] + c + word[i+1:]\n                        if next_word == word:\n                            continue\n                        if next_word in wordSet:\n                            if next_word not in visited:\n                                visited[next_word] = level\n                                q.append(next_word)\n                            if visited[next_word] == level:\n                                adjacency[word].append(next_word)\n                            if next_word == endWord:\n                                found = True\n        \n        # Now perform DFS to collect all paths from beginWord to endWord\n        result = []\n        path = [beginWord]\n        \n        def dfs(node):\n            if node == endWord:\n                result.append(list(path))\n                return\n            for neighbor in adjacency[node]:\n                if visited[neighbor] == visited[node] + 1:\n                    path.append(neighbor)\n                    dfs(neighbor)\n                    path.pop()\n        \n        dfs(beginWord)\n        return result\n", "balanced-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def check(node):\n            if not node:\n                return 0\n            left_height = check(node.left)\n            if left_height == -1:\n                return -1\n            right_height = check(node.right)\n            if right_height == -1:\n                return -1\n            if abs(left_height - right_height) > 1:\n                return -1\n            return max(left_height, right_height) + 1\n        \n        return check(root) != -1\n", "power-of-two": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n > 0 and (n & (n - 1)) == 0\n", "subsets-ii": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        res = []\n        self.backtrack(nums, 0, [], res)\n        return res\n    \n    def backtrack(self, nums, start, path, res):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            self.backtrack(nums, i + 1, path, res)\n            path.pop()\n", "largest-rectangle-in-histogram": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        index = 0\n        n = len(heights)\n        \n        while index < n:\n            if not stack or heights[index] >= heights[stack[-1]]:\n                stack.append(index)\n                index += 1\n            else:\n                top_of_stack = stack.pop()\n                width = index if not stack else index - stack[-1] - 1\n                area = heights[top_of_stack] * width\n                max_area = max(max_area, area)\n        \n        while stack:\n            top_of_stack = stack.pop()\n            width = n if not stack else n - stack[-1] - 1\n            area = heights[top_of_stack] * width\n            max_area = max(max_area, area)\n        \n        return max_area\n", "evaluate-reverse-polish-notation": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # Truncate towards zero\n                    res = a / b\n                    if res >= 0:\n                        res = int(res)\n                    else:\n                        res = int(-(-a // b) if b > 0 else a // -b)\n                    stack.append(res)\n            else:\n                stack.append(int(token))\n        return stack.pop()\n", "perfect-rectangle": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if not rectangles:\n            return False\n        \n        min_x = min_y = float('inf')\n        max_a = max_b = -float('inf')\n        total_area = 0\n        corners = set()\n        \n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_a = max(max_a, a)\n            max_b = max(max_b, b)\n            \n            total_area += (a - x) * (b - y)\n            \n            # All four corners of the current rectangle\n            rect_corners = [(x, y), (x, b), (a, y), (a, b)]\n            for corner in rect_corners:\n                if corner in corners:\n                    corners.remove(corner)\n                else:\n                    corners.add(corner)\n        \n        # The four corners of the bounding rectangle should be the only ones remaining, appearing once each\n        expected_corners = {(min_x, min_y), (min_x, max_b), (max_a, min_y), (max_a, max_b)}\n        if corners != expected_corners:\n            return False\n        \n        # Check if the total area matches the area of the bounding rectangle\n        bounding_area = (max_a - min_x) * (max_b - min_y)\n        return total_area == bounding_area\n", "excel-sheet-column-title": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        result = []\n        while columnNumber > 0:\n            columnNumber -= 1\n            remainder = columnNumber % 26\n            result.append(chr(65 + remainder))\n            columnNumber = columnNumber // 26\n        return ''.join(reversed(result))\n", "maximum-subarray": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        max_current = max_global = nums[0]\n        \n        for num in nums[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n                \n        return max_global\n", "sliding-puzzle": "from collections import deque\n\nclass Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        target = ((1, 2, 3), (4, 5, 0))\n        \n        # Convert the initial board into a tuple of tuples for hashability\n        initial = tuple(tuple(row) for row in board)\n        \n        if initial == target:\n            return 0\n        \n        # Directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        # BFS setup\n        queue = deque()\n        queue.append((initial, 0))\n        visited = set()\n        visited.add(initial)\n        \n        while queue:\n            current_state, moves = queue.popleft()\n            \n            # Find the position of 0\n            for i in range(2):\n                for j in range(3):\n                    if current_state[i][j] == 0:\n                        x, y = i, j\n                        break\n                else:\n                    continue\n                break\n            \n            # Generate all possible next states\n            for dx, dy in directions:\n                new_x = x + dx\n                new_y = y + dy\n                if 0 <= new_x < 2 and 0 <= new_y < 3:\n                    # Create new state by swapping 0 and adjacent number\n                    temp = [list(row) for row in current_state]\n                    temp[x][y], temp[new_x][new_y] = temp[new_x][new_y], temp[x][y]\n                    new_state = tuple(tuple(row) for row in temp)\n                    \n                    if new_state not in visited:\n                        if new_state == target:\n                            return moves + 1\n                        visited.add(new_state)\n                        queue.append((new_state, moves + 1))\n        \n        return -1\n", "isomorphic-strings": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for char_s, char_t in zip(s, t):\n            if char_s in s_to_t:\n                if s_to_t[char_s] != char_t:\n                    return False\n            else:\n                s_to_t[char_s] = char_t\n            \n            if char_t in t_to_s:\n                if t_to_s[char_t] != char_s:\n                    return False\n            else:\n                t_to_s[char_t] = char_s\n        \n        return True\n", "search-in-rotated-sorted-array-ii": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            # Handle the case where left, mid, and right are the same\n            if nums[left] == nums[mid] and nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                # Left half is sorted\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                # Right half is sorted\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n", "unique-paths-ii": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0]) if m > 0 else 0\n        \n        # If the starting cell has an obstacle, return 0\n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        # Initialize DP table\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = 1\n        \n        # Fill the first row: can only come from the left\n        for j in range(1, n):\n            if obstacleGrid[0][j] == 0 and dp[0][j-1] == 1:\n                dp[0][j] = 1\n            else:\n                dp[0][j] = 0\n        \n        # Fill the first column: can only come from above\n        for i in range(1, m):\n            if obstacleGrid[i][0] == 0 and dp[i-1][0] == 1:\n                dp[i][0] = 1\n            else:\n                dp[i][0] = 0\n        \n        # Fill the rest of the table\n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                else:\n                    dp[i][j] = 0\n        \n        return dp[m-1][n-1]\n", "decode-ways-ii": "class Solution(object):\n    def numDecodings(self, s):\n        MOD = 10**9 + 7\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        if s[0] == '*':\n            dp[1] = 9\n        elif s[0] == '0':\n            dp[1] = 0\n        else:\n            dp[1] = 1\n            \n        for i in range(2, n + 1):\n            # Single digit case\n            current_char = s[i-1]\n            if current_char == '*':\n                single = 9 * dp[i-1]\n            elif current_char == '0':\n                single = 0\n            else:\n                single = dp[i-1]\n            \n            # Two digits case\n            prev_char = s[i-2]\n            two_digit = 0\n            if prev_char == '*':\n                if current_char == '*':\n                    two_digit = 15  # 11-19 (9) + 21-26 (6) \u2192 9+6=15\n                elif '0' <= current_char <= '6':\n                    two_digit = 2  # 1x or 2x (x is 0-6)\n                elif '7' <= current_char <= '9':\n                    two_digit = 1  # only 1x (since 2x is >26)\n            elif prev_char == '1':\n                if current_char == '*':\n                    two_digit = 9  # 11-19\n                else:\n                    two_digit = 1  # 1x is valid (10-19)\n            elif prev_char == '2':\n                if current_char == '*':\n                    two_digit = 6  # 21-26\n                elif '0' <= current_char <= '6':\n                    two_digit = 1  # 20-26\n                else:\n                    two_digit = 0  # 27-29 invalid\n            else:  # prev_char is 0 or 3-9\n                two_digit = 0  # no valid two-digit\n            \n            if i >= 2:\n                dp[i] = (single + two_digit * dp[i-2]) % MOD\n            else:\n                dp[i] = single % MOD\n        \n        return dp[n]\n", "3sum-closest": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        closest_sum = float('inf')\n        n = len(nums)\n        \n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if current_sum == target:\n                    return current_sum\n                if abs(current_sum - target) < abs(closest_sum - target):\n                    closest_sum = current_sum\n                if current_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest_sum\n", "maximum-depth-of-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        return max(left_depth, right_depth) + 1\n", "intersection-of-two-arrays-ii": "from collections import defaultdict\n\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Count the frequency of each number in nums1\n        freq = defaultdict(int)\n        for num in nums1:\n            freq[num] += 1\n        \n        result = []\n        # Iterate through nums2 and check against the frequency map\n        for num in nums2:\n            if freq[num] > 0:\n                result.append(num)\n                freq[num] -= 1\n        \n        return result\n", "minimum-absolute-difference-in-bst": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # Initialize a list to hold the in-order traversal values\n        nodes = []\n        \n        # Perform in-order traversal to populate the list\n        def inorder(node):\n            if node is None:\n                return\n            inorder(node.left)\n            nodes.append(node.val)\n            inorder(node.right)\n        \n        inorder(root)\n        \n        min_diff = float('inf')\n        # Iterate through the list to find the minimum difference\n        for i in range(1, len(nodes)):\n            diff = nodes[i] - nodes[i-1]\n            if diff < min_diff:\n                min_diff = diff\n        \n        return min_diff\n", "find-mode-in-binary-search-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        \n        self.current_val = None\n        self.current_count = 0\n        self.max_count = 0\n        self.modes = []\n        \n        def inorder(node):\n            if not node:\n                return\n            inorder(node.left)\n            handle_value(node.val)\n            inorder(node.right)\n        \n        def handle_value(val):\n            if val != self.current_val:\n                self.current_val = val\n                self.current_count = 0\n            self.current_count += 1\n            if self.current_count > self.max_count:\n                self.max_count = self.current_count\n                self.modes = [val]\n            elif self.current_count == self.max_count:\n                self.modes.append(val)\n        \n        inorder(root)\n        return self.modes\n", "find-the-index-of-the-first-occurrence-in-a-string": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n        len_haystack = len(haystack)\n        len_needle = len(needle)\n        if len_needle > len_haystack:\n            return -1\n        for i in range(len_haystack - len_needle + 1):\n            if haystack[i:i+len_needle] == needle:\n                return i\n        return -1\n", "strong-password-checker": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        n = len(password)\n        missing_types = 3\n        has_lower = has_upper = has_digit = False\n        \n        for ch in password:\n            if not has_lower and ch.islower():\n                has_lower = True\n            if not has_upper and ch.isupper():\n                has_upper = True\n            if not has_digit and ch.isdigit():\n                has_digit = True\n        \n        missing_types = 3 - (has_lower + has_upper + has_digit)\n        \n        # Handle cases with length < 6\n        if n < 6:\n            return max(6 - n, missing_types)\n        \n        # Handle cases where length is between 6 and 20\n        replace = 0\n        one_seq = 0  # sequences that can be fixed by one replacement (len %3 == 0)\n        two_seq = 0   # sequences that can be fixed by two replacements (len %3 == 1)\n        i = 2\n        while i < n:\n            if password[i] == password[i-1] == password[i-2]:\n                length = 2\n                while i < n and password[i] == password[i-1]:\n                    length += 1\n                    i += 1\n                replace += length // 3\n                if length % 3 == 0:\n                    one_seq += 1\n                elif length % 3 == 1:\n                    two_seq += 1\n            else:\n                i += 1\n        \n        if n <= 20:\n            return max(replace, missing_types)\n        \n        # Handle cases where n > 20\n        delete = n - 20\n        \n        # Each deletion in a sequence of length 3k can reduce replace by 1\n        replace -= min(delete, one_seq * 1) // 1\n        replace -= max(0, min(delete - one_seq, two_seq * 2)) // 2\n        replace -= max(0, delete - one_seq - 2 * two_seq) // 3\n        \n        return delete + max(replace, missing_types)\n", "factorial-trailing-zeroes": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count\n", "zigzag-conversion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1 or len(s) <= numRows:\n            return s\n        \n        rows = [\"\" for _ in range(numRows)]\n        current_row = 0\n        going_down = False\n        \n        for char in s:\n            rows[current_row] += char\n            if current_row == 0 or current_row == numRows - 1:\n                going_down = not going_down\n            current_row += 1 if going_down else -1\n        \n        return ''.join(rows)\n", "trapping-rain-water": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        trapped_water = 0\n        \n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                trapped_water += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                trapped_water += right_max - height[right]\n        \n        return trapped_water\n", "find-all-numbers-disappeared-in-an-array": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Mark each number that appears by negating the value at its corresponding index\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] > 0:\n                nums[index] = -nums[index]\n        \n        # Collect all indices that are still positive (1-based)\n        result = []\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                result.append(i + 1)\n        return result\n", "count-of-smaller-numbers-after-self": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        # Coordinate compression to handle negative numbers and large values\n        unique_nums = sorted(set(nums))\n        rank = {v: i+1 for i, v in enumerate(unique_nums)}  # 1-based indexing\n        \n        max_rank = len(unique_nums)\n        fenwick_tree = FenwickTree(max_rank)\n        res = []\n        \n        # Traverse from right to left\n        for num in reversed(nums):\n            r = rank[num]\n            # Query the count of numbers smaller than current num (ranks less than r)\n            count = fenwick_tree.query(r - 1)\n            res.append(count)\n            # Update Fenwick tree with current num's rank\n            fenwick_tree.update(r, 1)\n        \n        # Reverse the result to match the original order\n        return res[::-1]\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (self.size + 1)  # 1-based indexing\n    \n    def update(self, index, delta=1):\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n    \n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n", "set-intersection-size-at-least-two": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort intervals by end, then by start in reverse\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = []\n        for start, end in intervals:\n            # Check how many numbers in the current interval are already in res\n            count = 0\n            left = len(res) - 1\n            # Check the last two elements in res that might be in [start, end]\n            # since res is built in order, the relevant elements are the last few\n            for num in res[-2:]:\n                if start <= num <= end:\n                    count += 1\n            if count == 0:\n                res.append(end - 1)\n                res.append(end)\n            elif count == 1:\n                res.append(end)\n        return len(res)\n", "symmetric-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return self.isMirror(root.left, root.right)\n    \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\n", "number-of-atoms": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        stack = [{}]\n        i = 0\n        n = len(formula)\n        \n        while i < n:\n            if formula[i] == '(':\n                stack.append({})\n                i += 1\n            elif formula[i] == ')':\n                top = stack.pop()\n                i += 1\n                # Get the multiplier\n                start = i\n                while i < n and formula[i].isdigit():\n                    i += 1\n                num = int(formula[start:i]) if start != i else 1\n                # Multiply the counts in the top context and merge into the new top\n                for atom in top:\n                    if atom in stack[-1]:\n                        stack[-1][atom] += top[atom] * num\n                    else:\n                        stack[-1][atom] = top[atom] * num\n            else:\n                # Parse the atom and its count\n                # Atom starts with uppercase, followed by lowercase letters\n                start = i\n                i += 1\n                while i < n and formula[i].islower():\n                    i += 1\n                atom = formula[start:i]\n                # Parse the number\n                start = i\n                while i < n and formula[i].isdigit():\n                    i += 1\n                num = int(formula[start:i]) if start != i else 1\n                # Update the current top dictionary\n                if atom in stack[-1]:\n                    stack[-1][atom] += num\n                else:\n                    stack[-1][atom] = num\n        \n        # The remaining dictionary is stack[0]\n        counts = stack[0]\n        # Sort the atoms alphabetically\n        sorted_atoms = sorted(counts.keys())\n        result = []\n        for atom in sorted_atoms:\n            result.append(atom)\n            if counts[atom] > 1:\n                result.append(str(counts[atom]))\n        return ''.join(result)\n", "binary-tree-preorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        # Iterative approach using stack\n        if not root:\n            return []\n        stack = [root]\n        result = []\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            # Push right first so left is processed first\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result\n", "power-of-four": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\n", "invert-binary-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        \n        # Swap the left and right children\n        root.left, root.right = root.right, root.left\n        \n        # Recursively invert the subtrees\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root\n", "generate-parentheses": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        def backtrack(s, left, right):\n            if len(s) == 2 * n:\n                result.append(s)\n                return\n            if left < n:\n                backtrack(s + '(', left + 1, right)\n            if right < left:\n                backtrack(s + ')', left, right + 1)\n        \n        backtrack(\"\", 0, 0)\n        return result\n", "patching-array": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        patches = 0\n        i = 0\n        miss = 1  # smallest missing number\n        length = len(nums)\n        \n        while miss <= n:\n            if i < length and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patches += 1\n        \n        return patches\n", "longest-valid-parentheses": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        max_len = 0\n        stack = [-1]\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    current_len = i - stack[-1]\n                    if current_len > max_len:\n                        max_len = current_len\n        return max_len\n", "fraction-to-recurring-decimal": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        if numerator == 0:\n            return \"0\"\n        \n        # Determine the sign\n        sign = \"-\" if (numerator < 0) ^ (denominator < 0) else \"\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        integer_part = numerator // denominator\n        remainder = numerator % denominator\n        if remainder == 0:\n            return sign + str(integer_part)\n        \n        # Decimal part\n        decimal_part = []\n        remainder_map = {}\n        index = 0\n        repeating_start = -1\n        \n        while remainder != 0:\n            if remainder in remainder_map:\n                repeating_start = remainder_map[remainder]\n                break\n            remainder_map[remainder] = index\n            index += 1\n            digit = (remainder * 10) // denominator\n            decimal_part.append(str(digit))\n            remainder = (remainder * 10) % denominator\n        \n        if repeating_start != -1:\n            decimal_part.insert(repeating_start, \"(\")\n            decimal_part.append(\")\")\n            decimal_str = \"\".join(decimal_part)\n        else:\n            decimal_str = \"\".join(decimal_part)\n        \n        return sign + str(integer_part) + \".\" + decimal_str\n", "sort-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        # Split the list into two halves\n        left = head\n        right = self.getMid(head)\n        tmp = right.next\n        right.next = None\n        right = tmp\n        \n        # Recursively sort each half\n        left = self.sortList(left)\n        right = self.sortList(right)\n        \n        # Merge the sorted halves\n        return self.merge(left, right)\n    \n    def getMid(self, head):\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n    \n    def merge(self, list1, list2):\n        dummy = ListNode()\n        tail = dummy\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n        \n        if list1:\n            tail.next = list1\n        if list2:\n            tail.next = list2\n        \n        return dummy.next\n", "russian-doll-envelopes": "import bisect\n\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # Sort the envelopes by width in ascending order, and by height in descending order\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Now find the LIS in the heights array\n        heights = [envelope[1] for envelope in envelopes]\n        tails = []\n        for h in heights:\n            idx = bisect.bisect_left(tails, h)\n            if idx == len(tails):\n                tails.append(h)\n            else:\n                tails[idx] = h\n        return len(tails)\n", "set-matrix-zeroes": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m = len(matrix)\n        n = len(matrix[0]) if m > 0 else 0\n        \n        first_row_has_zero = False\n        first_col_has_zero = False\n        \n        # Check if the first row has any zeros\n        for j in range(n):\n            if matrix[0][j] == 0:\n                first_row_has_zero = True\n                break\n        \n        # Check if the first column has any zeros\n        for i in range(m):\n            if matrix[i][0] == 0:\n                first_col_has_zero = True\n                break\n        \n        # Use the first row and column to mark zeros\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        # Zero out cells based on marks in first row and column\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        # Zero out the first row if needed\n        if first_row_has_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n        \n        # Zero out the first column if needed\n        if first_col_has_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n", "remove-nth-node-from-end-of-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        dummy.next = head\n        fast = dummy\n        slow = dummy\n        \n        # Move fast ahead by n+1 steps to create the gap\n        for _ in range(n + 1):\n            fast = fast.next\n        \n        # Move both pointers until fast reaches the end\n        while fast is not None:\n            slow = slow.next\n            fast = fast.next\n        \n        # Remove the nth node from the end\n        slow.next = slow.next.next\n        \n        return dummy.next\n", "intersection-of-two-arrays": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        set1 = set(nums1)\n        set2 = set(nums2)\n        return list(set1 & set2)\n", "super-washing-machines": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        target = total // n\n        moves = 0\n        balance = 0\n        for load in machines:\n            diff = load - target\n            balance += diff\n            moves = max(moves, diff, abs(balance))\n        return moves\n", "kth-smallest-number-in-multiplication-table": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        low = 1\n        high = m * n\n        \n        def count_less_equal(x):\n            count = 0\n            for i in range(1, m + 1):\n                add = min(x // i, n)\n                if add == 0:\n                    break\n                count += add\n            return count\n        \n        while low < high:\n            mid = (low + high) // 2\n            if count_less_equal(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n", "convert-sorted-list-to-binary-search-tree": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        # Convert the linked list into an array\n        values = []\n        while head:\n            values.append(head.val)\n            head = head.next\n        \n        # Helper function to build BST from array\n        def buildBST(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            node = TreeNode(values[mid])\n            node.left = buildBST(left, mid - 1)\n            node.right = buildBST(mid + 1, right)\n            return node\n        \n        return buildBST(0, len(values) - 1)\n", "merge-two-sorted-lists": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        # Create a dummy node to serve as the starting point of the merged list\n        dummy = ListNode(-1)\n        current = dummy\n        \n        # Traverse both lists and compare the nodes\n        while list1 and list2:\n            if list1.val <= list2.val:\n                current.next = list1\n                list1 = list1.next\n            else:\n                current.next = list2\n                list2 = list2.next\n            current = current.next\n        \n        # Attach the remaining elements of list1 or list2\n        current.next = list1 if list1 else list2\n        \n        return dummy.next\n", "maximal-rectangle": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return 0\n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_area = 0\n        heights = [0] * cols\n        \n        for i in range(rows):\n            # Update the heights array for the current row\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            # Calculate the largest rectangle in the current histogram\n            stack = []\n            for j in range(cols + 1):\n                h = heights[j] if j < cols else 0\n                while stack and heights[stack[-1]] > h:\n                    height = heights[stack.pop()]\n                    width = j if not stack else j - stack[-1] - 1\n                    max_area = max(max_area, height * width)\n                stack.append(j)\n        return max_area\n", "subsets": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        n = len(nums)\n        \n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, n):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        backtrack(0, [])\n        return res\n", "find-minimum-in-rotated-sorted-array-ii": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n                \n        return nums[left]\n", "valid-number": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        # Define the DFA states and transitions\n        state = [\n            # State 0: initial state\n            {\"digit\": 1, \"sign\": 2, \"dot\": 3},\n            # State 1: digits found before any dot or exponent\n            {\"digit\": 1, \"dot\": 4, \"exponent\": 5},\n            # State 2: sign found before any digits\n            {\"digit\": 1, \"dot\": 3},\n            # State 3: dot found before any digits (like \".123\")\n            {\"digit\": 4},\n            # State 4: dot found with preceding or following digits (like \"123.\", \"123.45\", or \".45\")\n            {\"digit\": 4, \"exponent\": 5},\n            # State 5: exponent found\n            {\"sign\": 6, \"digit\": 7},\n            # State 6: sign found after exponent\n            {\"digit\": 7},\n            # State 7: digits found after exponent\n            {\"digit\": 7}\n        ]\n        \n        current_state = 0\n        for c in s:\n            if c.isdigit():\n                transition = \"digit\"\n            elif c in ['+', '-']:\n                transition = \"sign\"\n            elif c in ['e', 'E']:\n                transition = \"exponent\"\n            elif c == '.':\n                transition = \"dot\"\n            else:\n                return False\n            \n            if transition not in state[current_state]:\n                return False\n            current_state = state[current_state][transition]\n        \n        # Check if the final state is one of the accepting states\n        return current_state in {1, 4, 7}\n", "integer-to-roman": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        val_sym = [\n            (1000, 'M'),\n            (900, 'CM'),\n            (500, 'D'),\n            (400, 'CD'),\n            (100, 'C'),\n            (90, 'XC'),\n            (50, 'L'),\n            (40, 'XL'),\n            (10, 'X'),\n            (9, 'IX'),\n            (5, 'V'),\n            (4, 'IV'),\n            (1, 'I')\n        ]\n        roman_num = []\n        for value, symbol in val_sym:\n            while num >= value:\n                roman_num.append(symbol)\n                num -= value\n            if num == 0:\n                break\n        return ''.join(roman_num)\n", "find-the-difference": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        result = 0\n        for char in s:\n            result ^= ord(char)\n        for char in t:\n            result ^= ord(char)\n        return chr(result)\n", "sudoku-solver": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        def is_valid(board, row, col, num):\n            # Check the row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n            # Check the column\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            # Check the 3x3 sub-box\n            start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n            for i in range(3):\n                for j in range(3):\n                    if board[start_row + i][start_col + j] == num:\n                        return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in map(str, range(1, 10)):\n                            if is_valid(board, i, j, num):\n                                board[i][j] = num\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'  # backtrack\n                        return False  # trigger backtracking\n            return True  # all cells filled\n        \n        solve(board)\n", "recover-binary-search-tree": "class Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        # Initialize pointers for Morris Traversal\n        current = root\n        prev = TreeNode(float('-inf'))\n        first = None\n        second = None\n        \n        # Morris In-order Traversal\n        while current is not None:\n            if current.left is None:\n                # Process current node\n                if prev.val > current.val:\n                    if first is None:\n                        first = prev\n                    second = current\n                prev = current\n                current = current.right\n            else:\n                # Find the inorder predecessor\n                pre = current.left\n                while pre.right is not None and pre.right != current:\n                    pre = pre.right\n                \n                if pre.right is None:\n                    # Make current as the right child of the inorder predecessor\n                    pre.right = current\n                    current = current.left\n                else:\n                    # Revert the changes and process current node\n                    pre.right = None\n                    if prev.val > current.val:\n                        if first is None:\n                            first = prev\n                        second = current\n                    prev = current\n                    current = current.right\n        \n        # Swap the values of the two nodes\n        if first and second:\n            first.val, second.val = second.val, first.val\n", "palindrome-linked-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        # Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half\n        prev = None\n        current = slow\n        while current:\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        \n        # Compare the first half and the reversed second half\n        left = head\n        right = prev\n        while right:\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n        \n        return True\n", "valid-perfect-square": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num < 1:\n            return False\n        left, right = 1, num\n        while left <= right:\n            mid = (left + right) // 2\n            square = mid * mid\n            if square == num:\n                return True\n            elif square < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n", "counting-bits": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans\n", "remove-linked-list-elements": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        # Create a dummy node to handle cases where the head needs to be removed\n        dummy = ListNode(0)\n        dummy.next = head\n        current = dummy\n        \n        while current.next is not None:\n            if current.next.val == val:\n                current.next = current.next.next\n            else:\n                current = current.next\n                \n        return dummy.next\n", "scramble-string": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        memo = {}\n        def helper(s1, s2):\n            if (s1, s2) in memo:\n                return memo[(s1, s2)]\n            if len(s1) != len(s2):\n                memo[(s1, s2)] = False\n                return False\n            if s1 == s2:\n                memo[(s1, s2)] = True\n                return True\n            if sorted(s1) != sorted(s2):\n                memo[(s1, s2)] = False\n                return False\n            n = len(s1)\n            for i in range(1, n):\n                # Case 1: No swap\n                if helper(s1[:i], s2[:i]) and helper(s1[i:], s2[i:]):\n                    memo[(s1, s2)] = True\n                    return True\n                # Case 2: Swap\n                if helper(s1[:i], s2[n-i:]) and helper(s1[i:], s2[:n-i]):\n                    memo[(s1, s2)] = True\n                    return True\n            memo[(s1, s2)] = False\n            return False\n        return helper(s1, s2)\n", "simplify-path": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        components = path.split('/')\n        \n        for component in components:\n            if component == '' or component == '.':\n                continue\n            elif component == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(component)\n        \n        canonical_path = '/' + '/'.join(stack)\n        return canonical_path\n", "word-search-ii": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\nclass Solution:\n    def findWords(self, board, words):\n        root = TrieNode()\n        \n        # Build the Trie\n        for word in words:\n            node = root\n            for ch in word:\n                if ch not in node.children:\n                    node.children[ch] = TrieNode()\n                node = node.children[ch]\n            node.word = word  # Store the word at the end node\n        \n        rows = len(board)\n        cols = len(board[0])\n        result = []\n        \n        def backtrack(row, col, parent):\n            letter = board[row][col]\n            curr_node = parent.children[letter]\n            \n            # Check if we found a word\n            if curr_node.word is not None:\n                result.append(curr_node.word)\n                curr_node.word = None  # To avoid duplicates\n            \n            # Mark the cell as visited\n            board[row][col] = '#'\n            \n            # Explore neighboring cells\n            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n            for dr, dc in directions:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < rows and 0 <= new_col < cols:\n                    if board[new_row][new_col] in curr_node.children:\n                        backtrack(new_row, new_col, curr_node)\n            \n            # Restore the cell's value\n            board[row][col] = letter\n            \n            # Optimization: prune the leaf nodes\n            if not curr_node.children:\n                parent.children.pop(letter)\n        \n        for row in range(rows):\n            for col in range(cols):\n                if board[row][col] in root.children:\n                    backtrack(row, col, root)\n        \n        return result\n", "valid-anagram": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) != len(t):\n            return False\n        \n        char_counts = {}\n        \n        for char in s:\n            char_counts[char] = char_counts.get(char, 0) + 1\n        \n        for char in t:\n            if char not in char_counts:\n                return False\n            char_counts[char] -= 1\n            if char_counts[char] < 0:\n                return False\n        \n        return all(count == 0 for count in char_counts.values())\n", "valid-sudoku": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        # Check each row\n        for row in board:\n            seen = set()\n            for num in row:\n                if num != '.':\n                    if num in seen:\n                        return False\n                    seen.add(num)\n        \n        # Check each column\n        for col in range(9):\n            seen = set()\n            for row in range(9):\n                num = board[row][col]\n                if num != '.':\n                    if num in seen:\n                        return False\n                    seen.add(num)\n        \n        # Check each 3x3 sub-box\n        for box_row in range(0, 9, 3):\n            for box_col in range(0, 9, 3):\n                seen = set()\n                for i in range(3):\n                    for j in range(3):\n                        num = board[box_row + i][box_col + j]\n                        if num != '.':\n                            if num in seen:\n                                return False\n                            seen.add(num)\n        \n        return True\n", "fizz-buzz": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        answer = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer\n", "reverse-words-in-a-string": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        words = s.split()\n        words.reverse()\n        return ' '.join(words)\n", "excel-sheet-column-number": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            value = ord(char) - ord('A') + 1\n            result = result * 26 + value\n        return result\n", "candy": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(ratings)\n        if n == 0:\n            return 0\n        candies = [1] * n\n        \n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        # Right to left pass\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                if candies[i] <= candies[i+1]:\n                    candies[i] = candies[i+1] + 1\n        \n        return sum(candies)\n", "same-tree": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n", "reorder-list": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        if not head or not head.next:\n            return\n        \n        # Step 1: Find the middle of the list\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Split the list into two halves\n        second = slow.next\n        slow.next = None  # Break the link between first and second half\n        \n        # Step 2: Reverse the second half\n        prev = None\n        current = second\n        while current:\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n        second = prev  # second now points to the head of the reversed second half\n        \n        # Step 3: Merge the two halves alternately\n        first = head\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2\n", "word-pattern": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        char_to_word = {}\n        word_to_char = {}\n        \n        for char, word in zip(pattern, words):\n            if char in char_to_word:\n                if char_to_word[char] != word:\n                    return False\n            else:\n                if word in word_to_char:\n                    return False\n                char_to_word[char] = word\n                word_to_char[word] = char\n        return True\n", "permutations": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        def backtrack(start, end):\n            if start == end:\n                result.append(nums[:])\n            for i in range(start, end):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1, end)\n                nums[start], nums[i] = nums[i], nums[start]\n        \n        result = []\n        backtrack(0, len(nums))\n        return result\n", "search-a-2d-matrix": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return False\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        left = 0\n        right = m * n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n", "add-two-numbers": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode(0)\n        current = dummy\n        carry = 0\n        \n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            total = val1 + val2 + carry\n            carry = total // 10\n            current.next = ListNode(total % 10)\n            current = current.next\n            \n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        return dummy.next\n", "number-complement": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        if num == 0:\n            return 1\n        mask = 1\n        while mask <= num:\n            mask <<= 1\n        mask -= 1\n        return num ^ mask\n", "arithmetic-slices-ii-subsequence": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        total = 0\n        dp = [{} for _ in range(n)]  # dp[i] is a dictionary where key is the difference, value is the count of sequences ending at i with that difference\n        \n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                # The number of sequences ending at j with difference 'diff'\n                count = dp[j].get(diff, 0)\n                total += count\n                # Update dp[i][diff] to include the new sequence from j to i\n                dp[i][diff] = dp[i].get(diff, 0) + count + 1\n        \n        return total\n", "text-justification": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        lines = []\n        current_line = []\n        current_length = 0\n        \n        for word in words:\n            # Check if adding the current word exceeds the maxWidth\n            # The + len(current_line) accounts for at least one space between words\n            if current_length + len(word) + len(current_line) > maxWidth:\n                # Process the current line\n                total_spaces = maxWidth - current_length\n                word_count = len(current_line)\n                \n                if word_count == 1:\n                    # Left justified if only one word\n                    line = current_line[0] + ' ' * total_spaces\n                else:\n                    # Distribute spaces between words\n                    space_per_gap = total_spaces // (word_count - 1)\n                    extra_spaces = total_spaces % (word_count - 1)\n                    \n                    line = []\n                    for i in range(len(current_line) - 1):\n                        line.append(current_line[i])\n                        line.append(' ' * (space_per_gap + (1 if i < extra_spaces else 0)))\n                    line.append(current_line[-1])\n                    line = ''.join(line)\n                \n                lines.append(line)\n                \n                # Reset for the next line\n                current_line = []\n                current_length = 0\n            \n            current_line.append(word)\n            current_length += len(word)\n        \n        # Handle the last line (left justified)\n        last_line = ' '.join(current_line)\n        last_line += ' ' * (maxWidth - len(last_line))\n        lines.append(last_line)\n        \n        return lines\n", "binary-tree-postorder-traversal": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        # Recursive solution\n        # result = []\n        # self._postorder_recursive(root, result)\n        # return result\n        \n        # Iterative solution\n        if not root:\n            return []\n        \n        stack = []\n        result = []\n        prev = None\n        stack.append(root)\n        \n        while stack:\n            current = stack[-1]\n            # Traverse down the tree\n            if not prev or prev.left == current or prev.right == current:\n                if current.left:\n                    stack.append(current.left)\n                elif current.right:\n                    stack.append(current.right)\n                else:\n                    result.append(stack.pop().val)\n            # Coming up from the left\n            elif current.left == prev:\n                if current.right:\n                    stack.append(current.right)\n                else:\n                    result.append(stack.pop().val)\n            # Coming up from the right\n            elif current.right == prev:\n                result.append(stack.pop().val)\n            prev = current\n        \n        return result\n    \n    # Helper function for recursive solution\n    def _postorder_recursive(self, node, result):\n        if node:\n            self._postorder_recursive(node.left, result)\n            self._postorder_recursive(node.right, result)\n            result.append(node.val)\n", "container-with-most-water": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            current_area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, current_area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area\n", "concatenated-words": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        word_set = set(words)\n        result = []\n        \n        def can_form(word):\n            if not word:\n                return False\n            n = len(word)\n            dp = [False] * (n + 1)\n            dp[0] = True\n            for i in range(1, n + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        if j == 0 and i == n:\n                            continue  # avoid using the word itself\n                        dp[i] = True\n                        break\n            return dp[n]\n        \n        for word in words:\n            if can_form(word):\n                result.append(word)\n        return result\n", "base-7": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        if num == 0:\n            return \"0\"\n        is_negative = False\n        if num < 0:\n            is_negative = True\n            num = -num\n        res = []\n        while num > 0:\n            res.append(str(num % 7))\n            num = num // 7\n        if is_negative:\n            res.append('-')\n        return ''.join(reversed(res))\n", "nim-game": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        return n % 4 != 0\n", "n-queens-ii": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            solutions = 0\n            for col in range(n):\n                d1 = row - col\n                d2 = row + col\n                if col in cols or d1 in diag1 or d2 in diag2:\n                    continue\n                cols.add(col)\n                diag1.add(d1)\n                diag2.add(d2)\n                solutions += backtrack(row + 1, cols, diag1, diag2)\n                cols.remove(col)\n                diag1.remove(d1)\n                diag2.remove(d2)\n            return solutions\n        \n        return backtrack(0, set(), set(), set())\n", "n-queens": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def create_board(state):\n            board = []\n            for row in state:\n                board_row = ['.'] * n\n                board_row[row] = 'Q'\n                board.append(\"\".join(board_row))\n            return board\n        \n        def backtrack(row, cols, diagonals, anti_diagonals, state):\n            if row == n:\n                solutions.append(create_board(state))\n                return\n            for col in range(n):\n                curr_diagonal = row - col\n                curr_anti_diagonal = row + col\n                if col in cols or curr_diagonal in diagonals or curr_anti_diagonal in anti_diagonals:\n                    continue\n                cols.add(col)\n                diagonals.add(curr_diagonal)\n                anti_diagonals.add(curr_anti_diagonal)\n                state.append(col)\n                backtrack(row + 1, cols, diagonals, anti_diagonals, state)\n                state.pop()\n                cols.remove(col)\n                diagonals.remove(curr_diagonal)\n                anti_diagonals.remove(curr_anti_diagonal)\n        \n        solutions = []\n        backtrack(0, set(), set(), set(), [])\n        return solutions\n", "word-search": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        if not board or not word:\n            return False\n        \n        rows, cols = len(board), len(board[0])\n        word_len = len(word)\n        \n        if word_len > rows * cols:\n            return False\n        \n        # Convert the word into a list for easier access\n        word = list(word)\n        \n        def backtrack(i, j, k, visited):\n            if k == word_len:\n                return True\n            if i < 0 or i >= rows or j < 0 or j >= cols:\n                return False\n            if (i, j) in visited or board[i][j] != word[k]:\n                return False\n            \n            visited.add((i, j))\n            # Explore all four directions\n            res = (backtrack(i+1, j, k+1, visited) or\n                   backtrack(i-1, j, k+1, visited) or\n                   backtrack(i, j+1, k+1, visited) or\n                   backtrack(i, j-1, k+1, visited))\n            visited.remove((i, j))  # Backtrack\n            return res\n        \n        # Convert the board to a list of lists for processing\n        # Check for early termination if the word's characters are not present in the board\n        from collections import defaultdict\n        board_chars = defaultdict(int)\n        for i in range(rows):\n            for j in range(cols):\n                board_chars[board[i][j]] += 1\n        \n        word_chars = defaultdict(int)\n        for c in word:\n            word_chars[c] += 1\n        \n        # Check if all characters in word exist in board with sufficient count\n        for c in word_chars:\n            if word_chars[c] > board_chars.get(c, 0):\n                return False\n        \n        # Check if the first character appears more frequently than the last, reverse word if beneficial\n        # This is a heuristic to potentially reduce the search space\n        if board_chars[word[0]] > board_chars[word[-1]]:\n            word = word[::-1]\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == word[0]:\n                    if backtrack(i, j, 0, set()):\n                        return True\n        return False\n", "merge-sorted-array": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        p1 = m - 1\n        p2 = n - 1\n        p = m + n - 1\n        \n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            p -= 1\n        \n        # If there are remaining elements in nums2, copy them into nums1\n        while p2 >= 0:\n            nums1[p] = nums2[p2]\n            p2 -= 1\n            p -= 1\n", "third-maximum-number": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        first = second = third = -float('inf')\n        for num in nums:\n            if num > first:\n                third = second\n                second = first\n                first = num\n            elif num < first and num > second:\n                third = second\n                second = num\n            elif num < second and num > third:\n                third = num\n        # Check if third maximum exists (i.e., third was updated from -infinity)\n        return third if third != -float('inf') else first\n"}
